---
title: "IActiveScriptParse::ParseScriptText | Microsoft Docs"
ms.custom: ""
ms.date: "01/18/2017"
ms.prod: "windows-script-interfaces"
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "reference"
apiname: IActiveScriptParse.ParseScriptText
apilocation: scrobj.dll
helpviewer_keywords: 
  - "IActiveScriptParse_ParseScriptText"
ms.assetid: 2d237d6c-cc65-415b-8808-72791304a136
caps.latest.revision: 10
author: "mikejo5000"
ms.author: "mikejo"
manager: "ghogen"
caps.handback.revision: 10
---
# IActiveScriptParse::ParseScriptText
Анализирует заданного сценарий кода, а объявления в пространство имен и вычисления код соответственно.  
  
## Синтаксис  
  
```  
HRESULT ParseScriptText(  
    LPCOLESTR pstrCode,              // address of scriptlet text  
    LPCOLESTR pstrItemName,          // address of item name  
    IUnknown *punkContext,           // address of debugging context  
    LPCOLESTR pstrDelimiter,         // address of end-of-scriptlet delimiter  
    DWORD_PTR dwSourceContextCookie, // cookie for debugging  
    ULONG ulStartingLineNumber,      // starting line of the script  
    DWORD dwFlags,                   // scriptlet flags  
    VARIANT *pvarResult,             // address of buffer for results  
    EXCEPINFO *pexcepinfo            // address of buffer for error data  
);  
```  
  
#### Параметры  
  
|||  
|-|-|  
|`pstrCode`|\[in\] Адрес текста скриптлета для вычисления.  Интерпретация этой строки зависит от скриптового языка.|  
|`pstrItemName`|\[in\] Адрес имени элемента, которое предоставляет контекст, в котором необходимо вычислить скриптлет.  Если этот параметр равен NULL, то код вычисляется в глобальном контексте обработчика скриптов.|  
|`punkContext`|\[in\] Адрес контекста объекта.  Этот объект зарезервирован для использования в отладке, где такой контекст может быть предоставлен отладчиком, чтобы представить активный контекст среды выполнения.  Если этот параметр равен NULL, то обработчик использует `pstrItemName` для определения контекста.|  
|`pstrDelimiter`|\[in\] Адрес разделителя конца скриптлета.  При синтаксическом анализе `pstrCode` из потока текста узел обычно использует разделитель, например две одинарные кавычки \(''\), чтобы определить конец скриптлета.  Этот параметр задает разделитель, используемый узлом, что позволяет обработчику скриптов выполнять некоторую условную предобработку примитивов \(например, заменяя одиночные кавычки \['\] 2 одинарными кавычками для использования в качестве разделителя\).  То, как обработчик скриптов использует эту информацию \(и использует ли он ее вообще\), зависит от обработчика скриптов.  Установите этот параметр в значение `NULL`, если узел не используется разделитель для отметки конца сценария.|  
|`dwSourceContextCookie`|\[in\] Файл cookie, используемый для отладки.|  
|`ulStartingLineNumber`|\[in\] Отсчитываемое от нуля значение, которое указывает, с какой строки начинается синтаксический анализ.|  
|`dwFlags`|\[in\] Флаги, связанные со скриптлетом.  Может быть сочетанием следующих значений:|  
  
|Значение|Значение|  
|--------------|--------------|  
|SCRIPTTEXT\_ISEXPRESSION|Если различие между вычислительным выражением и оператором играет важную роль, но синтаксически неоднозначно в скриптовом языке, этот флаг указывает, что сценарий должен рассматриваться как выражение, а не как оператор или список операторов.  По умолчанию предполагается, что это операторы, если правильный вариант нельзя определить по синтаксису текста сценария.|  
|SCRIPTTEXT\_ISPERSISTENT|Указывает, что код, добавленный в процессе этого вызова, должен быть сохранен при сохранении обработчика скриптов \(например, посредством вызова `IPersist*::Save`\) или при сбросе обработчика скриптов посредством перевода его обратно в состояние инициализации.|  
|SCRIPTTEXT\_ISVISIBLE|Указывает, что текст скрипта должен быть видимым \(и, таким образом, его должно быть можно вызывать по имени\) как глобальный метод в пространстве имен скрипта.|  
  
|||  
|-|-|  
|`pvarResult`|\[out\] Адрес буфера, который получает результаты обработки скриптлета, или значение `NULL`, если вызывающий объект не ожидает результата \(то есть значение SCRIPTTEXT\_ISEXPRESSION не задано\).|  
|`pexcepinfo`|\[out\] Адрес структуры, которая получает информацию об исключении.  Эта структура заполнена, если `IActiveScriptParse::ParseScriptText` возвращает DISP\_E\_EXCEPTION.|  
  
## Возвращаемое значение  
 Возвращает одно из следующих значений.  
  
|Возвращаемое значение|Значение|  
|---------------------------|--------------|  
|`S_OK`|Успех.|  
|`DISP_E_EXCEPTION`|Возникло исключение в процессе обработки сценария.  Параметр `pexcepinfo` содержит информацию об исключении.|  
|`E_INVALIDARG`|Аргумент был недопустимым.|  
|`E_POINTER`|Задан недопустимый указатель.|  
|`E_NOTIMPL`|Этот метод не поддерживается.  Обработчик скриптов не поддерживает времени выполнения вычисления выражений или выписок.|  
|`E_UNEXPECTED`|Вызов не ожидался \(например, обработчик скриптов в неинициализированном или закрытом состоянии, или флажок был SCRIPTTEXT\_ISEXPRESSION задания и обработчик скриптов находится в инициализированном состоянии\).|  
|`OLESCRIPT_E_SYNTAX`|Возникла неуказанная синтаксическая ошибка в сценарии.|  
  
## Заметки  
 Если обработчик скриптов находится в инициализированном состоянии, никакой код не будет вычисляться во время этого вызова; вместо этого такой код будет помещен в очередь и выполнен, когда обработчик скриптов перейдет в запущенное состояние или пройдет его.  Поскольку в инициализированном состоянии выполнение не разрешено, вызов этого метода с флагом SCRIPTTEXT\_ISEXPRESSION в инициализированном состоянии является ошибкой.  
  
 Сценарий может быть выражением, выписок списком, или к разрешенным языком скрипта.  Например, этот метод используется в вычислении HTML\-тега \<SCRIPT\>, который позволяет операторам выполняться во время построения страницы HTML, а не просто компилироваться в состояние скрипта.  
  
 Код, который передается этому методу должен быть допустимой, полной частью кода.  Например, в VBScript недопустимо вызывать этот метод один раз с помощью Sub Function\(x\), а затем второй раз с помощью `End Sub`.  Синтаксический анализатор не придется ждать второй вызов для выполнения подпрограммы, а должен вызывать ошибку синтаксического анализа, поскольку было запущено, но не завершилось объявления подпрограммы.  
  
 Дополнительные сведения о состояниях скрипта см. в подразделе "Состояния обработчика скриптов" раздела [Обработчики скриптов Windows](../../winscript/windows-script-engines.md).  
  
## См. также  
 [IActiveScriptParse](../../winscript/reference/iactivescriptparse.md)