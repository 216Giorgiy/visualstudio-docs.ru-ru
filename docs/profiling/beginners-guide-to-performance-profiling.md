---
title: Измерение использования ЦП в приложениях
description: Анализ проблем с производительностью ЦП в приложении с помощью средств диагностики, встроенных в отладчик.
ms.custom: mvc
ms.date: 02/27/2017
ms.technology: vs-ide-debug
ms.topic: tutorial
f1_keywords:
- vs.performance.wizard.intropage
helpviewer_keywords:
- Profiling Tools, quick start
- Diagnostics Tools, CPU Usage
- CPU Usage
- Diagnostics Tools
ms.assetid: da2fbf8a-2d41-4654-a509-dd238532d25a
author: mikejo5000
ms.author: mikejo
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: f206faf2934883c346b39a83c7953f87c98f95dc
ms.sourcegitcommit: 240c8b34e80952d00e90c52dcb1a077b9aff47f6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/23/2018
ms.locfileid: "49898243"
---
# <a name="profile-application-performance-in-visual-studio"></a>Профилирование производительности приложений в Visual Studio
Средства профилирования Visual Studio можно использовать для анализа проблем с производительностью в приложении. Эта процедура демонстрирует работу с вкладкой **Загрузка ЦП** средств диагностики для получения данных о производительности для приложения. Средства диагностики поддерживаются для разработки приложений .NET в Visual Studio, включая ASP.NET, и для разработки машинного кода или кода C++.
  
При приостановке отладчика средство **Загрузка ЦП** собирает сведения о функциях, которые выполняются в приложении. Кроме того, это средство перечисляет функции, которые выполняли максимальный объем работы, а также предоставляет график временной шкалы, который позволяет сосредоточить внимание на определенных сегментах сеанса выборки.

Центр диагностики предоставляет различные возможности по запуску сеансов диагностики и управлению ими. Если средство **Загрузка ЦП** не предоставляет необходимые данные, можно воспользоваться [другими средствами профилирования](../profiling/profiling-feature-tour.md), предоставляющими другие виды информации, которая может оказаться полезной. Как правило, проблемы производительности приложения могут вызываться другими компонентами помимо ЦП, такими как память, отрисовка пользовательского интерфейса или время запроса сети. Центр диагностики предоставляет ряд других параметров для записи и анализа такого рода данных.

| | |
|---------|---------|
| ![значок кинокамеры для видео](../install/media/video-icon.png "Просмотреть видео") | Просмотрите [видео об использовании средств диагностики](https://mva.microsoft.com/en-US/training-courses-embed/getting-started-with-visual-studio-2017-17798/Profiling-with-Diagnostics-Tools-in-Visual-Studio-2017-daHnzMD6D_9211787171), где показано, как можно анализировать загрузку ЦП и использование памяти. |

В этой статье мы обсудим анализ загрузки ЦП в обычном рабочем процессе отладки. Анализировать загрузку ЦП также можно без подключения отладчика — вы можете просто указать выполняющееся приложение. Дополнительные сведения см. в разделе [Сбор данных профилирования без отладки](../profiling/running-profiling-tools-with-or-without-the-debugger.md#collect-profiling-data-without-debugging) и в статье [Выполнение средств профилирования с отладчиком и без него](../profiling/running-profiling-tools-with-or-without-the-debugger.md).

Можно использовать средства профилирования без отладчика с Windows 7 и более поздних версий. Для запуска средств профилирования с отладчиком (окно **Средства диагностики**) требуется Windows 8 и более поздние версии.

В этом руководстве рассмотрены следующие задачи:

> [!div class="checklist"]
> * Сбор данных об использовании ЦП
> * Анализ данных о загрузке ЦП
  
## <a name="step-1-collect-profiling-data"></a>Шаг 1. Сбор данных профилирования 
  
1.  Откройте проект для отладки в Visual Studio и установите точку останова в приложении в точке, где вы хотите проверить загрузку ЦП.

2.  Установите вторую точку останова в конце функции или области кода, который требуется проанализировать.

    > [!TIP]
    > С помощью двух точек останова можно ограничить сбор данных частями кода, которые требуется проанализировать.
  
3.  Окно **Средства диагностики** появится автоматически, если вы не отключали эту функцию. Чтобы снова открыть окно, щелкните **Отладка** > **Окна** > **Показать средства диагностики**.

4.  Вы можете выбрать, что следует просмотреть, [Использование памяти](../profiling/Memory-Usage.md) или **Загрузка ЦП** (либо оба средства), с помощью параметра **Выбор средств** на панели инструментов. В Visual Studio Enterprise также можно включить или отключить IntelliTrace, выбрав **Сервис** > **Параметры** > **IntelliTrace**.

     ![Вывод средств диагностики](../profiling/media/DiagToolsSelectTool.png "DiagToolsSelectTool")

     Нас главным образом интересует загрузка ЦП, поэтому убедитесь, что средство **Загрузка ЦП** включено (оно включено по умолчанию).

5.  Щелкните **Отладка** > **Начать отладку** (**Запустить** на панели инструментов или **F5**).

     По завершении загрузки приложения отображается представление "Сводка" средств диагностики.

     ![Вкладка "Сводка" средств диагностики](../profiling/media/DiagToolsSummaryTab.png "DiagToolsSummaryTab")

     Дополнительные сведения о событиях см. в разделе [Поиск и фильтрация на вкладке "События" окна "Средства диагностики"](http://blogs.msdn.com/b/visualstudioalm/archive/2015/11/12/searching-and-filtering-the-events-tab-of-the-diagnostic-tools-window.aspx).

6.  Запустите сценарий, который вызвал срабатывание первой точки останова.

7.  Приостановив отладчик, включите сбор данных о загрузке ЦП, а затем откройте вкладку **Загрузка ЦП**.

     ![Средства диагностики, "Включить профилирование ЦП"](../profiling/media/DiagToolsEnableCPUProfiling.png "DiagToolsEnableCPUProfiling")

     При выборе пункта **Запись профиля ЦП** Visual Studio начнет записывать функции и сведения о времени их выполнения. Эти собранные данные можно просматривать только в том случае, если приложение останавливается в точке останова.

8.  Нажмите клавишу F5, чтобы запустить приложение до второй точки останова.

     Теперь у вас есть данные о производительности приложения именно для той области кода, которая выполняется между двумя точками останова.

9.  Выберите интересующую вас область на временной шкале ЦП (это должна быть та область, для которой отображаются данные профилирования).

     ![Средства диагностики, выбор сегмента временной шкалы](../profiling/media/DiagToolsSelectTimeSegment.png "DiagToolsSelectTimeSegment")

     Профилировщик начинает подготавливать данные потока. Дождитесь завершения этой операции.

     ![Средства диагностики, подготовка потоков](../profiling/media/DiagToolsPreparingThreads.png "DiagToolsPreparingThreads")
  
     Средство "Загрузка ЦП" выведет отчет на вкладке **Загрузка ЦП**.
  
     ![Средства диагностики, вкладка "Загрузка ЦП"](../profiling/media/DiagToolsCPUUsageTab.png "DiagToolsCPUUsageTab")

     На этом этапе можно начать анализировать данные.

## <a name="step-2-analyze-cpu-usage-data"></a>Шаг 2. Анализ данных о загрузке ЦП

Мы рекомендуем начать анализ данных с проверки списка функций на вкладке "Загрузка ЦП" и выявления функций, выполняющих основную часть работы, а затем подробно рассмотреть каждую из этих функций.

1. В списке функций изучите функции, которые выполняют большую часть работы.

    ![Средства диагностики, список функций на вкладке "Загрузка ЦП"](../profiling/media/DiagToolsCPUUsageFunctionList.png "DiagToolsCPUUsageFunctionList")

    > [!TIP]
    > Функции перечисляются, начиная с тех, которые выполняют большую часть работы (а не в порядке вызова). Это позволяет быстро находить функции, которые выполнялись дольше всего.

2. В списке функций дважды щелкните одну из функций вашего приложения, которая выполняет много работы.

    При двойном щелчке функции в левой панели откроется представление **Вызывающий/вызываемый**. 

    ![Средства диагностики, представление "Вызывающий/вызываемый"](../profiling/media/DiagToolsCallerCallee.png "DiagToolsCallerCallee")

    В этом представлении выбранная функции отображается в заголовке и в поле **Текущая функция** (в этом примере GetNumber). Функция, вызывавшая текущую функцию, отображается в левой части окна в разделе **Вызывающая функция**, а все функции, вызываемые текущей функцией, отображаются в поле **Вызываемые функции** справа. (Можно выбрать любое поле, чтобы изменить текущую функцию.)

    В этом представлении показано общее время (мс) и доля общего времени выполнения приложения, затраченного на выполнение функции.
    В поле **Тело функции** также показан общий объем времени (и доля времени), затраченного в теле функции за исключением времени, затраченного в вызываемых и вызывающих функциях. (В этом примере в теле функции затрачено 3713 из 3729 мс, а оставшиеся 16 мс затрачены во внешнем коде, вызванном этой функцией).

    > [!TIP]
    > Высокие значения в поле **Тело функции** могут свидетельствовать о проблемах производительности внутри самой функции.

3. Если вы хотите увидеть более обобщенное представление, показывающее порядок, в котором вызываются функции, выберите в раскрывающемся списке в верхней части панели пункт **Дерево вызовов**.
 
    Каждая нумерованная область на рисунке соответствует определенному шагу в процедуре.
  
    ![Средства диагностики, дерево вызовов](../profiling/media/DiagToolsCallTree.png "DiagToolsCallTree")
  
|||
|-|-|
|![Шаг 1](../profiling/media/ProcGuid_1.png "ProcGuid_1")|Узел верхнего уровня в деревьях вызовов для использования ЦП представляет собой псевдоузел|  
|![Шаг 2](../profiling/media/ProcGuid_2.png "ProcGuid_2")|В большинстве приложений при отключенном параметре [Показать внешний код](#view-external-code) узлом второго уровня является узел **[Внешний код]** , который содержит код системы и инфраструктуры, запускающий и останавливающий приложение, отрисовывающий пользовательский интерфейс, управляющий планированием потоков и предоставляющий приложению другие низкоуровневые службы.|  
|![Шаг 3](../profiling/media/ProcGuid_3.png "ProcGuid_3")|Дочерними элементами узла второго уровня являются методы пользовательского кода и асинхронные подпрограммы, которые вызываются или создаются кодом системы и инфраструктуры на втором уровне.|
|![Шаг 4](../profiling/media/ProcGuid_4.png "ProcGuid_4")|Дочерние узлы метода содержат данные только для вызова родительского метода. Если параметр **Показать внешний код** отключен, методы приложения также могут содержать узел **[Внешний код]** .|

Ниже приведены дополнительные сведения по значениям столбца.

- Значение **Общее время ЦП** указывает, какой объем работы был выполнен некоторой функцией и всеми вызванными ей функциями. Высокие значения общего времени ЦП указывают на функции, которые в целом являются наиболее ресурсоемкими.
  
- Значение **Собственное время** указывает, какой объем работы был выполнен кодом в теле функции, за исключением работы, выполненной вызванными ей функциями. Высокие значения **собственного времени ЦП** могут свидетельствовать о проблемах производительности внутри самой функции.

- **Модули**. Имя модуля, содержащего функцию, или количество модулей, содержащих функции в узле [Внешний код].

## <a name="view-external-code"></a>Просмотр внешнего кода

Внешний код — это функции в компонентах системы и платформы, которые исполняются вашим кодом. Внешний код включает функции, которые запускают и останавливают приложение, отрисовывают пользовательский интерфейс, управляют потоками и предоставляют приложению другие низкоуровневые службы. В большинстве случаев внешний код вас интересовать не будет, поэтому средство "Загрузка ЦП" собирает внешние функции пользовательского метода в один узел **[Внешний код]**.
  
Если вы захотите посмотреть пути к вызовам внешнего кода, выберите **Показать внешний код** в списке **Представление фильтра** и выберите **Применить**.  
  
![Выбор "Представление фильтра", а затем "Показать внешний код"](../profiling/media/DiagToolsShowExternalCode.png "DiagToolsShowExternalCode")  
  
Помните о том, что многие цепочки вызовов имеют глубокий уровень вложенности, поэтому ширина столбца "Имя функции" может превышать ширину многих мониторов. В этом случае имена функций отображаются в виде **[…]**.
  
Используйте поле поиска, чтобы найти требуемый узел, а затем воспользуйтесь горизонтальной полосой прокрутки для отображения данных в представлении.

> [!TIP]
> Если вы выполняете профилирование внешнего кода, вызывающего функции Windows, следует убедиться, что используются самые новые версии *PDB*-файлов. Без этих файлов имена функций Windows в представлениях отчетов будут отображаться в непонятном или трудном для понимания виде. Дополнительные сведения о том, как убедиться в наличии нужных файлов, см. в статье [Указание файлов символов (.pdb) и файлов с исходным кодом в отладчике Visual Studio](../debugger/specify-symbol-dot-pdb-and-source-files-in-the-visual-studio-debugger.md).

## <a name="next-steps"></a>Следующие шаги

В этом руководстве вы узнали, как собирать и анализировать данные об использовании ЦП. Если вы уже ознакомились с [общими сведениями о средствах профилирования](../profiling/profiling-feature-tour.md), можно перейти к анализу данных об использовании памяти в приложениях.

> [!div class="nextstepaction"]
> [Использование памяти профиля в Visual Studio](../profiling/memory-usage.md) 
