---
title: "DA0039. Очень большое число конфликтов при блокировке | Microsoft Docs"
ms.custom: ""
ms.date: "12/15/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-ide-debug"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vs.performance.39"
  - "vs.performance.DA0039"
  - "vs.performance.rules.DA0039"
ms.assetid: 5a9fc57d-9097-413b-af0c-8726b1a57048
caps.latest.revision: 9
caps.handback.revision: 9
author: "mikejo5000"
ms.author: "mikejo"
manager: "ghogen"
---
# DA0039. Очень большое число конфликтов при блокировке
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

|||  
|-|-|  
|Идентификатор правила|DA0039|  
|Категория|Использование .NET Framework|  
|Методы профилирования|Дискретизация<br /><br /> Инструментирование<br /><br /> Память .NET|  
|Сообщение|Очень много конфликтов блокировки .NET.  Проанализируйте причину данного конфликта блокировки, воспользовавшись профилем параллелизма.|  
|Тип правила|Предупреждение|  
  
 При профилировании методом выборки, памяти .NET или конфликтов ресурсов необходимо собрать не меньше 25 экземпляров, чтобы вызвать срабатывание правила.  
  
## Причина  
 Данные о производительности системы, собранные вместе с данными профилирования, свидетельствуют о слишком большом числе конфликтов блокировки, возникающих во время выполнения приложения.  Рекомендуется повторить профилирование с использованием метода профилирования параллелизма для поиска причины конфликта.  
  
## Описание правила  
 Блокировки используются для защиты критичных участков кода, которые должны выполняться в многопоточных приложениях последовательно, по одному потоку за раз.  В среде CLR платформы Microsoft .NET предусмотрен полный набор примитивов синхронизации и блокировки.  Например, язык C\# поддерживает оператор блокировки \(SyncLock в Visual Basic\).  Управляемое приложение может вызывать методы Monitor.Enter и Monitor.Exit в пространстве имен System.Threading для непосредственного наложения и снятия блокировки.  Платформа .NET Framework поддерживает дополнительные примитивы синхронизации и блокировки, включая классы, поддерживающие мьютексы, блокировки чтения и записи и семафоры.  Дополнительные сведения см. в документе [Overview of Synchronization Primitives](http://go.microsoft.com/fwlink/?LinkId=177867) в руководстве разработчика по .NET Framework на веб\-сайте MSDN.  Сами по себе классы .NET Framework расположены на более высоком уровне по сравнению с низкоуровневыми службами синхронизации, встроенными в операционную систему Windows.  К их числу относятся объекты критичных участков и множество различных функций ожидания и функций сигнализации о событиях.  Дополнительные сведения см. в разделе [Синхронизация](http://go.microsoft.com/fwlink/?LinkId=177869) разработки COM и Win32 в библиотеке MSDN  
  
 И базовые классы .NET Framework, и объекты Windows в машинном коде, используемые для синхронизации и блокировки, располагаются в общей памяти. Их расположение следует изменить с помощью сблокированных операций.  Для сблокированных операций используются особые аппаратные инструкции, которые выполняются с адресами в общей памяти для изменения их состояния с помощью атомарных операций.  Для атомарных операций гарантируется единообразное выполнение на всех процессорах в компьютере.  Блокировки и объекты WaitHandle – это объекты .NET, которые автоматически используют сблокированные операции при их назначении или сбрасывании.  В приложении могут существовать другие структуры данных в общей памяти, для которых также необходимо воспользоваться сблокированными операциями для обновления в потокобезопасном режиме.  Дополнительные сведения см. в разделе [Блокируемые операции](http://go.microsoft.com/fwlink/?LinkId=177870) .NET Framework библиотеки MSDN  
  
 Синхронизация и блокировка – это механизмы, используемые для обеспечения надлежащего выполнения многопоточных приложений.  Каждый поток многопоточного приложения представляет собой независимый блок выполнения, который независимо планируется операционной системой.  Конфликт блокировки происходит в случае задержки потока, пытающего наложить блокировку, из\-за наложения блокировки другим потоком.  
  
 Блокировки зачастую бывают вложенными.  Вкладывание происходит, если поток, выполняющий критичный участок, выполняет функцию, для которой затем требуется другая блокировка.  Определенная степень вложения блокировок является неизбежной.  Для проверки потокобезопасности критичный участок может вызвать метод .NET Framework, зависящий от блокировок.  Вызов из критичного участка приложения метода .NET Framework, который также выполняет блокировку с другим дескриптором блокировки, приводит к вложению блокировок.  Наличие вложенных блокировок может привести к проблемам производительности, которые, как известно, очень сложно обнаружить и устранить.  
  
 Это правило применяется, если измерения, проведенные во время сеанса профилирования, свидетельствуют о большом числе конфликтов блокировки.  Конфликты блокировки приводят к задержке выполнения потоков, ожидающих блокировки.  Даже весьма незначительное число конфликтов блокировки в модульных или нагрузочных тестах, выполняемых на оборудовании с ограниченными возможностями, требует изучения.  
  
> [!NOTE]
>  Если количество конфликтов блокировки в данных профилирования существенное но не чрезмерное, вместо предупреждающего сообщения выдается уведомительное сообщение [DA0038. Большое число конфликтов при блокировке](../profiling/da0038-high-rate-of-lock-contentions.md)  
  
## Анализ предупреждения  
 Дважды щелкните сообщение, чтобы перейти в представление данных профилирования [Метки](../profiling/marks-view.md).  Найдите столбец **.NET CLR LocksAndThreads\\Конфликтов в секунду**.  Установите, есть ли какие\-либо этапы выполнения программы, на которых число конфликтов блокировки значительно выше, чем на других этапах.  
  
 Это правило применяется, только если не используется метод профилирования параллелизма.  Метод профилирования параллелизма – это лучшее средство для диагностики проблем производительности, связанных с конфликтами блокировки в приложении.  Чтобы получить представление о поведении приложения при блокировании, соберите данные профилирования параллелизма.  Это, в том числе, позволит установить наиболее частые блокировки, длительность задержки времени выполнения потока в ожидании конфликтующих блокировок и конкретный код, в котором они происходят.  Профили параллелизма позволяют собирать данные обо всех конфликтах блокировки, в том числе данные о поведении средств Windows в машинном коде, сведения о классах платформы .NET Framework и информацию о любых других библиотеках сторонних разработчиков, на которые ссылается приложение.  Дополнительные сведения о профилировании параллелизма из интерфейса IDE [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] см. в разделе [Сбор данных о параллелизме потоков и процессов](../profiling/collecting-thread-and-process-concurrency-data.md).  Ссылки на сведения о профилировании параллелизма из командной см. в разделе **Using the Concurrency Method to Collect Resource Contention and Thread Activity Data** документа [Использование методов профилирования из командной строки](../profiling/using-profiling-methods-to-collect-performance-data-from-the-command-line.md).