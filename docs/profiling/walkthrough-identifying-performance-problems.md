---
title: "Пошаговое руководство. Профилирование приложений | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-ide-debug"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "средства профилирования, пошаговые руководства"
  - "средства повышения производительности, пошаговые руководства"
  - "производительность, анализ"
  - "профилирование приложений, пошаговые руководства"
ms.assetid: 36f6f123-0c14-4763-99c3-bd60ecb95b87
caps.latest.revision: 53
author: "mikejo5000"
ms.author: "mikejo"
manager: "ghogen"
caps.handback.revision: 53
---
# Пошаговое руководство. Профилирование приложений
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

В данном пошаговом руководстве показано, как выполнить профилирование приложения для выявления проблем производительности.  
  
 В этом руководстве приводится пошаговое описания процесса профилирования управляемого приложения. Для поиска и определения проблем производительности приложения используются методы выборки и инструментирования.  
  
 В этом пошаговом руководстве выполняются следующие действия.  
  
-   Профилирование приложения с помощью метода выборки.  
  
-   Анализ результатов профилирования с выборкой для выявления и исправления проблем производительности.  
  
-   Профилирование приложения с помощью метода инструментирования.  
  
-   Анализ результатов профилирования с инструментированием для выявления и исправления проблем производительности.  
  
## Обязательные компоненты  
  
-   Средний уровень знания языка C\#.  
  
-   Копия примера [Пример PeopleTrax](../profiling/peopletrax-sample-profiling-tools.md).  
  
 Для работы со сведениями, полученными при профилировании, рекомендуется включить отладочные символы.  
  
## Профилирование с помощью метода выборки  
 Выборка — это метод профилирования, при котором анализируемый процесс периодически опрашивается с целью определения активной функции.  Результирующие данные показывают, как часто анализируемая функция находилась на вершине стека вызовов при выборочном опросе процесса.  
  
#### Профилирование приложения с помощью метода выборки  
  
1.  Откройте [!INCLUDE[vs_current_short](../code-quality/includes/vs_current_short_md.md)] с правами администратора.  Выполнение с правами администратора необходимо для профилирования.  
  
2.  Откройте решение PeopleTrax.  
  
     Решение PeopleTrax отобразится в обозревателе решений.  
  
3.  Установите для параметра конфигурации проекта значение **Выпуск**.  
  
     Для обнаружения проблем производительности приложения следует использовать выпускное построение.  Выпускная сборка рекомендуется для профилирования по той причине, что отладочная сборка содержит дополнительные сведения, скомпилированные при построении, которые могут отрицательно сказаться на производительности и не позволят адекватно продемонстрировать проблемы производительности.  
  
4.  В меню **Анализ** щелкните **Запустить мастер производительности**.  
  
     Откроется мастер производительности.  
  
5.  Убедитесь, что выбран параметр **ЦП Выборка \(рекомендуется\)** и нажмите кнопку **Далее**.  
  
6.  В поле **Какое приложение выбрано для профилирования** выберите PeopleTrax, а затем нажмите кнопку **Далее**.  
  
     [!INCLUDE[vs_current_short](../code-quality/includes/vs_current_short_md.md)] выполнит построение проекта и запустит профилирование приложения.  Открывается окно приложения **PeopleTrax**.  
  
7.  Щелкните **Получить пользователей**.  
  
8.  Щелкните **Экспорт данных**.  
  
     Откроется Блокнот, в котором будет отображен новый файл, содержащий данные, экспортированные из средства **PeopleTrax**.  
  
9. Закройте Блокнот и приложение **PeopleTrax**.  
  
     Профилировщик создает файл данных профилирования \(\*.vsp\), указывает имя этого файла в окне обозревателя производительности и автоматически загружает представление **Сводка** файла данных в основном окне [!INCLUDE[vs_current_short](../code-quality/includes/vs_current_short_md.md)].  
  
#### Анализ результатов профилирования с выборкой  
  
1.  В представлении "Сводка" отображается временная шкала использования ЦП в процессе выполнения профилирования, список **Горячий путь**, представляющий наиболее активную ветвь дерева вызовов, и список **Функции, выполняющие максимальную индивидуальную работу**, в котором отображаются функции, во время выполнения кода в теле которых выполнялась наиболее интенсивная выборка.  
  
     Проанализируйте список **Горячий путь** и обратите внимание на то, что метод PeopleNS.People.GetNames является функцией PeopleTrax, ближайшей к концу списка.  Его положение делает его отличным кандидатом для анализа.  Щелкните имя этой функции для отображения данных о GetNames в представлении **Сведения о функции**.  
  
2.  В представлении **Сведения о функции** содержится два окна.  В окне "Распределение стоимости" содержится графическое представление работы, выполняемой данной функцией, работы, выполняемой функциями, которые она вызывает, а также влияние функций, вызвавших данную функцию, на число экземпляров, для которых выполняется выборка.  Щелкнув имя функции можно изменить функцию, для которой в представлении отображаются данные.  Например, можно щелкнуть PeopleNS.People.GetPeople, чтобы выбранной функцией стала функция GetPeople.  
  
     В окне **Представление кода функции** отображается исходный код выбранной функции, если он доступен, и выделяются ее наиболее ресурсоемкие строки.  Если выбран метод GetNames, то, как можно видеть, эта функция считывает строку из ресурсов приложения, а затем использует <xref:System.IO.StringReader> для добавления каждой строки кода в строке в класс <xref:System.Collections.ArrayList>.  Очевидный способ оптимизации этой функции отсутствует.  
  
3.  Поскольку PeopleNS.People.GetPeople – это единственная вызывающая функция GetNames, щелкните GetPeople в окне "Распределение стоимости", чтобы проанализировать код.  Этот метод возвращает класс <xref:System.Collections.ArrayList> объектов PersonInformationNS.PersonInformation из списка имен лиц и названий компаний, созданных методом GetNames.  Однако GetNames вызывается дважды при каждом создании объекта PersonInformation.  Как можно видеть, метод можно легко оптимизировать, создав списки только один раз при запуске метода и проиндексировав их во время цикла создания PersonInformation.  
  
4.  Вместе с примером кода приложения предоставляется альтернативная версия GetPeople. Оптимизированную функцию можно вызвать, добавив символ условной компиляции в свойства построения.  В окне "Обозреватель решений" щелкните правой кнопкой мыши проект People и выберите команду **Свойства**.  Выберите пункт **Построение** в меню страницы свойств и введите **OPTIMIZED\_GETPEOPLE** текстовом поле символа условной компиляции.  Оптимизированная версия GetPeople заменит исходный метод в следующем построении.  
  
5.  Перезапустите сеанс анализа производительности.  На панели инструментов обозревателя производительности щелкните **Запустить с профилированием**.  Щелкните **Получить пользователей**, а затем выберите **Экспорт данных**.  Закройте отобразившееся окно блокнота, а затем закройте приложение People Trax.  
  
     Создается новый файл данных профилирования, а в основном окне [!INCLUDE[vs_current_short](../code-quality/includes/vs_current_short_md.md)] для новых данных отображается представление **Сводка**.  
  
6.  Для сравнения двух сеансов профилирования выберите два файла данных в обозревателе производительности, щелкните правой кнопкой мыши файлы, а затем выберите команду **Сравнить отчеты о производительности**.  В основном окне [!INCLUDE[vs_current_short](../code-quality/includes/vs_current_short_md.md)] отобразится окно "Отчет о сравнении".  В столбце **Разностная версия** отобразится переход от более раннего **базового** значения производительности функций к более позднему **сравнительному** значению.  В раскрывающемся списке **Столбец** можно выбрать значения для сравнения.  Выберите **Включающие выборки %**.  
  
     Обратите внимание, что методы GetPeople и GetNames снова демонстрируют достаточно высокую производительность.  
  
## Профилирование с помощью метода инструментирования  
 Инструментирование – это метод профилирования, в котором профилировщик вставляет функции\-зонды в специально построенные версии профилируемых двоичных файлов.  Функции\-зонды собирают данные о времени при входе в функции и выходе из них в инструментированных модулях и во всех местах вызова в этих функциях.  Процесс инструментирования полезен для анализа проблем, связанных с операциями ввода\-вывода, такими как запись на диск и обмен данными по сети.  Инструментирование предоставляет более подробные сведения, чем выборка, однако сильнее влияет на выполнение процесса и приводит к созданию большего числа служебных данных.  Инструментированные двоичные файлы увеличиваются в размере по сравнению с двоичными файлами для отладки или выпуска. Кроме того, такие файлы не предназначены для развертывания.  
  
 В этом разделе пошагового руководства метод инструментирования будет использован для выявления дополнительного кода, пригодного для оптимизации, в приложении PeopleTrax, которое профилировалось ранее.  С помощью фильтра временной шкалы представления "Сводка" в качестве основного объекта анализа будет выбран сценарий экспорта данных в профилируемом приложении, в котором список лиц записывается в файл в Блокноте.  
  
#### Профилирование существующего приложения с помощью метода инструментирования  
  
1.  При необходимости откройте приложение PeopleTrax в Visual Studio.  
  
     Убедитесь, что приложение было открыто с правами администратора и что для конфигурации построения решения задано значение **Выпуск**.  
  
2.  В обозревателе производительности щелкните **Инструментирование**.  
  
3.  На панели инструментов обозревателя производительности щелкните **Запустить с профилированием**.  
  
     Профилировщик выполнит построение проекта и запустит профилирование приложения.  Откроется окно приложения PeopleTrax.  
  
4.  Щелкните **Получить пользователей**.  
  
     Выполняется заполнение таблицы данных PeopleTrax.  
  
5.  Подождите около 10 секунд и нажмите кнопку **Экспорт данных**.  
  
     Открывается **Блокнот**, в котором отображается новый файл, содержащий список пользователей проекта PeopleTrax.  Ожидание упрощает определение процедуры экспорта данных для фильтрации.  
  
6.  Закройте **Блокнот** и приложение **PeopleTrax**.  
  
     [!INCLUDE[vs_current_short](../code-quality/includes/vs_current_short_md.md)] создает отчет сеанса производительности \(\*.vsp\).  
  
#### Анализ результатов профилирования с инструментированием  
  
1.  На графе временной шкалы представления **Сводка** отчета отображается использование ЦП программой на протяжении сеанса профилирования.  Операция экспорта данных должна выглядеть как большой пик или полка в правой части графа.  Чтобы вывести и проанализировать только данные, собранные в ходе операции экспорта, можно отфильтровать сеанс анализа производительности.  Щелкните слева от точки на графе, в которой началась операция экспорта данных.  Щелкните еще раз справа от операции.  Затем выберите в списке связей справа от временной шкалы пункт **Фильтр по выделенному**.  
  
     В дереве **Горячий путь** будет указано, что метод <xref:System.String.Concat%2A>, вызываемый методом PeopleTrax.Form1.ExportData, занимает большой процент времени.  Поскольку метод **System.String.Concat** также находится вверху списка **Функции с максимальной индивидуальной работой**, сокращение времени, затрачиваемого в функции, вероятнее всего свидетельствует об оптимизации.  
  
2.  Щелкните дважды **System.String.Concat** в любой из таблиц сводки для просмотра дополнительных сведений в представлении "Сведения о функции".  
  
3.  Как можно видеть, PeopleTrax.Form1.ExportData – это единственный метод, который вызывает метод Concat.  Щелкните **PeopleTrax.Form1.ExportData** в списке **Вызов функций**, чтобы выбрать этот метод в качестве целевого объекта представления "Сведения о функции".  
  
4.  Проанализируйте метод в окне "Представление кода функции".  Обратите внимание на отсутствие непосредственных вызовов метода **System.String.Concat**.  Вместо этого в коде несколько раз используется операнд \+\=, который компилятор заменяет вызовом функции **System.String.Concat**.  Любые изменения строки в платформе .NET Framework приводят к выделению памяти для новой строки.  В .NET Framework содержится класс <xref:System.Text.StringBuilder>, оптимизированный для объединения строк.  
  
5.  Чтобы заменить данную проблемную область оптимизированным кодом, добавьте символ условной компиляции OPTIMIZED\_EXPORTDATA в проект PeopleTrax.  
  
6.  В обозревателе решений щелкните правой кнопкой мыши проект PeopleTrax и выберите команду **Свойства**.  
  
     Откроется форма свойств проекта PeopleTrax.  
  
7.  Перейдите на вкладку **Построение**.  
  
8.  В текстовом поле **Символы условной компиляции** введите OPTIMIZED\_EXPORTDATA.  
  
9. Закройте форму свойств проекта и при появлении соответствующего приглашения выберите **Сохранить все**.  
  
 Если запустить приложение еще раз, можно заметить, что производительность заметно повысилась.  Рекомендуется запустить сеанс профилирования еще раз даже в том случае, если наблюдается очевидное повышение производительности.  После устранения проблемы важно еще раз просмотреть данные, поскольку первая проблема могла скрывать некоторые другие проблемы.  
  
## См. также  
 [Разделы общих сведений](../profiling/overviews-performance-tools.md)   
 [Начало работы](../profiling/getting-started-with-performance-tools.md)   
 [\/Z7, \/Zi, \/ZI \(формат отладочной информации\)](/visual-cpp/build/reference/z7-zi-zi-debug-information-format)