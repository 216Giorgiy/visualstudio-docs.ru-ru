---
title: "Сравнение свойств и элементов | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-ide-sdk"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "MSBuild свойства msbuild"
ms.assetid: b9da45ae-d6a6-4399-8628-397deed31486
caps.latest.revision: 16
caps.handback.revision: 16
author: "kempb"
ms.author: "kempb"
manager: "ghogen"
---
# Сравнение свойств и элементов
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

Свойства и элементы MSBuild используются для передачи информации задачам, оценки условий и хранят значения, которые будут указывать ссылки в файле проекта.  
  
-   Свойства представляют собой пары имя значение. Дополнительные сведения см. в разделе [свойства MSBuild](../msbuild/msbuild-properties.md).  
  
-   Элементы являются объектами, которые обычно представляют собой файлы. Объекты элементов могут быть связанные коллекции метаданных. Метаданные представляют собой пары имя значение. Дополнительные сведения см. в разделе [элементы](../msbuild/msbuild-items.md).  
  
## <a name="scalars-and-vectors"></a>Скаляры и векторы  
 Поскольку свойства MSBuild являются парами имя значение с одним строковым значением, они часто описываются как *скалярные*. Так как типы элементов MSBuild представляют собой списки элементов, они часто описываются как *вектор*. Однако на практике свойства могут представлять несколько значений и типов элементов может иметь ноль или один элементов.  
  
### <a name="target-dependency-injection"></a>Внедрение зависимости  
 Чтобы увидеть, как свойства могут представлять несколько значений, рассмотрим общий принцип добавления целевого объекта в список целевых объектов для построения. Обычно этот список представлен значением свойства, имена целевых объектов, разделенных точкой с запятой.  
  
```  
<PropertyGroup>  
    <BuildDependsOn>  
        BeforeBuild;  
        CoreBuild;  
        AfterBuild  
    </BuildDependsOn>  
</PropertyGroup>  
```  
  
  `BuildDependsOn` Свойство обычно используется в качестве аргумента целевой объект `DependsOnTargets` атрибут, эффективно его преобразует в список элементов. Это свойство можно переопределить для добавления цели или изменить порядок выполнения целевых объектов. Например:  
  
```  
<PropertyGroup>  
    <BuildDependsOn>  
        $(BuildDependsOn);  
        CustomBuild;  
    </BuildDependsOn>  
</PropertyGroup>  
```  
  
 Добавляет цель CustomBuild в целевой список, предоставляя `BuildDependsOn` значение `BeforeBuild;CoreBuild;AfterBuild;CustomBuild`.  
  
 Начиная с MSBuild 4.0 внедрение зависимости является устаревшим. Используйте `AfterTargets` и `BeforeTargets` вместо атрибутов. Дополнительные сведения см. в разделе [порядок построения целевого объекта](../msbuild/target-build-order.md).  
  
### <a name="conversions-between-strings-and-item-lists"></a>Преобразование строк и списков элементов  
 MSBuild выполняет преобразование из типов элементов и строковые значения, при необходимости. Чтобы увидеть, как список элементов может стать строковое значение, рассмотрим, что происходит, когда тип элемента используется в качестве значения свойства MSBuild:  
  
```  
<ItemGroup>  
    <OutputDir Include="KeyFiles\;Certificates\" />  
  </ItemGroup>  
<PropertyGroup>  
    <OutputDirList>@(OutputDir)</OutputDirList>  
</PropertyGroup>  
```  
  
 Тип элемента, который имеет OutputDir `Include` атрибут со значением «ключевых файлов\\; Сертификаты\\». MSBuild анализирует эту строку в двух элементов: сертификаты и KeyFiles\\\. При использовании типа элемента OutputDir в качестве значения свойства OutputDirList MSBuild преобразует или «сведение» тип элементов в строке, разделенных точкой с запятой «ключевых файлов\\; Сертификаты\\».  
  
## <a name="properties-and-items-in-tasks"></a>Свойства и элементы в задачах  
 Свойства и элементы используются в качестве входных и выходных данных для задач MSBuild. Дополнительные сведения см. в разделе [задачи](../msbuild/msbuild-tasks.md).  
  
 Свойства передаются в задачи как атрибуты. В рамках задачи свойство MSBuild представляется тип свойства, значение которого можно преобразовать в строку и обратно. Поддерживаемые типы свойства включают `bool`, `char`, `DateTime`, `Decimal`, `Double`, `int`, `string`, и любой тип, <xref:System.Convert.ChangeType%2A> может обрабатывать.  
  
 Элементы передаются в задачи в виде <xref:Microsoft.Build.Framework.ITaskItem> объектов. В рамках задачи <xref:Microsoft.Build.Framework.ITaskItem.ItemSpec%2A> представляет значение элемента и <xref:Microsoft.Build.Framework.ITaskItem.GetMetadata%2A> извлекает его метаданные.  
  
 Список элементов типа элементов можно передать как массив `ITaskItem` объектов. Начиная с .NET Framework 3.5, элементы могут быть удалены из списка элементов в целевом объекте с помощью `Remove` атрибута. Поскольку элементы могут быть удалены из списка элементов, возможно, тип элемента может не иметь элементов. Если список элементов передается в задачу, код в задаче должен проверить наличие такой возможности.  
  
## <a name="property-and-item-evaluation-order"></a>Свойства и порядок вычисления элемента  
 На этапе оценки построения импортированные файлы внедряются в построение в порядке, в котором они появляются. Свойства и элементы определяются за три прохода в следующем порядке:  
  
-   Свойства определяются и изменяются в порядке, в котором они появляются.  
  
-   Определения элементов определяются и изменяются в порядке, в котором они появляются.  
  
-   Элементы определяются и изменяются в порядке, в котором они появляются.  
  
 На этапе выполнения построения свойства и элементы, определенные в рамках целевых объектов вычисляются вместе в один этап в порядке, в котором они появляются.  
  
 Однако это не полный текст. Если определено свойство, определение элемента или элемент, выполняется оценка его значения. Средство оценки выражения расширяет строку, определяющую значение. Расширение строки зависит от этапа сборки. Вот более подробные порядок вычисления свойств и элементов:  
  
-   На этапе оценки построения:  
  
    -   Свойства определяются и изменяются в порядке, в котором они появляются. Выполняются функции свойства. Значения свойств в виде $(PropertyName) раскрываются внутри выражений. Для расширенного выражения задать значение свойства.  
  
    -   Определения элементов определяются и изменяются в порядке, в котором они появляются. Функции свойств уже расширены в рамках выражений. Для расширенных выражений задаются значения метаданных.  
  
    -   Типы элементов определяются и изменяются в порядке, в котором они появляются. Элемент значения в виде @(ItemType) расширяются. Преобразования элементов также расширяются. Функции и значения свойств уже расширены в рамках выражений. Для расширенных выражений задаются значения элементов списка и метаданных.  
  
-   На этапе выполнения построения:  
  
    -   Свойства и элементы, определенные в рамках целевых объектов вместе вычисляются в порядке, в котором они появляются. Выполняются функции свойства и значения свойств расширены в рамках выражений. Преобразования значений элементов и элементов также расширяются. Для расширенных выражений задаются значения свойств, элемента типа значения и значения метаданных.  
  
### <a name="subtle-effects-of-the-evaluation-order"></a>Слабые эффекты порядка оценки  
 На этапе оценки построения, свойства элементов предшествует оценка. Тем не менее свойства могут иметь значения, которые зависят от значений элементов. Рассмотрим следующий сценарий.  
  
```  
<ItemGroup>  
    <KeyFile Include="KeyFile.cs">  
        <Version>1.0.0.3</Version>  
    </KeyFile>  
</ItemGroup>  
<PropertyGroup>  
    <KeyFileVersion>@(KeyFile->'%(Version)')</KeyFileVersion>  
</PropertyGroup>  
<Target Name="AfterBuild">  
    <Message Text="KeyFileVersion: $(KeyFileVersion)" />  
</Target>  
```  
  
 При выполнении задачи Message отображается сообщение:  
  
```  
KeyFileVersion: 1.0.0.3  
```  
  
 Это, поскольку значение `KeyFileVersion` является на самом деле строка "@(KeyFile->'%(Version)')". элемент и преобразования элементов не были расширены при первом определении свойства, поэтому `KeyFileVersion` свойство было присвоено значение нерасширенной строки.  
  
 На этапе выполнения построения, при обработке задачи Message MSBuild расширяет строку "@(KeyFile->'%(Version)')" выдавала «1.0.0.3».  
  
 Обратите внимание, что то же сообщение появится, даже если были отменены группы свойств и элементов в порядке.  
  
 Во втором примере рассмотрим, что может произойти, когда группы свойств и элементов расположены в целевых объектах.  
  
```  
<Target Name="AfterBuild">  
    <PropertyGroup>  
        <KeyFileVersion>@(KeyFile->'%(Version)')</KeyFileVersion>  
    </PropertyGroup>  
    <ItemGroup>  
        <KeyFile Include="KeyFile.cs">  
            <Version>1.0.0.3</Version>  
        </KeyFile>  
    </ItemGroup>  
    <Message Text="KeyFileVersion: $(KeyFileVersion)" />  
</Target>  
```  
  
 Задача Message отображается сообщение:  
  
```  
KeyFileVersion:   
```  
  
 Это так, как на этапе выполнения построения группы свойств и элементов, определенные в рамках целевых объектов, оцениваются сверху вниз, в то же время. Когда `KeyFileVersion` определен, `KeyFile` неизвестно. Таким образом при преобразовании элементов расширяется пустая строка.  
  
 В этом случае изменение порядка групп свойств и элементов восстанавливает исходное сообщение:  
  
```  
<Target Name="AfterBuild">  
    <ItemGroup>  
        <KeyFile Include="KeyFile.cs">  
            <Version>1.0.0.3</Version>  
        </KeyFile>  
    </ItemGroup>  
    <PropertyGroup>  
        <KeyFileVersion>@(KeyFile->'%(Version)')</KeyFileVersion>  
    </PropertyGroup>  
    <Message Text="KeyFileVersion: $(KeyFileVersion)" />  
</Target>  
```  
  
 Значение `KeyFileVersion` имеет значение «1.0.0.3» и не "@(KeyFile->'%(Version)')". задачи Message отображается сообщение:  
  
```  
KeyFileVersion: 1.0.0.3  
```  
  
## <a name="see-also"></a>См. также  
 [Дополнительные понятия](../msbuild/msbuild-advanced-concepts.md)