---
title: Журнал пикселей графики | Документация Майкрософт
ms.custom: ''
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.reviewer: ''
ms.suite: ''
ms.technology:
- vs-ide-debug
ms.tgt_pltfrm: ''
ms.topic: article
f1_keywords:
- vs.graphics.pixelhistory
ms.assetid: 0a2cbde5-1ad9-487e-857c-a3664158c268
caps.latest.revision: 17
author: mikejo5000
ms.author: mikejo
manager: ghogen
ms.openlocfilehash: 9ac64d352bfb6d6a35ea1bd9027d30f527aab116
ms.sourcegitcommit: 9ceaf69568d61023868ced59108ae4dd46f720ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/12/2018
ms.locfileid: "49208368"
---
# <a name="graphics-pixel-history"></a>Журнал пикселей графики
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Окно журнала пикселей графики в анализаторе графики Visual Studio помогает понять влияние на конкретный пиксель событий Direct3D, которые происходят в кадре вашей игры или приложения.  
  
 Это окно журнала пикселей:  
  
 ![Пиксель с тремя событиями Direct3D в журнале. ](../debugger/media/gfx-diag-demo-pixel-history-orientation.png "gfx_diag_demo_pixel_history_orientation")  
  
## <a name="understanding-the-pixel-history-window"></a>Основные сведения об окне журнала пикселей  
 С помощью журнала пикселей можно проанализировать, как определенный пиксель целевого объекта отрисовки затрагивается событиями Direct3D во время кадра. Можно выявить проблемы отрисовки на уровне конкретного события Direct3D, даже если последующие события — или последующие примитивы в этом же событии — продолжают изменять значение окончательного цвета пикселя. Например, пиксель может быть отрисован неправильно и затем скрыт другим полупрозрачным пикселем, при этом их цвета смешиваются в буфере кадров. Подобные проблемы было бы трудно диагностировать, если бы вы имели для анализа только окончательное содержимое целевого объекта отрисовки.  
  
 В окне журнала пикселей отображается полный журнал пикселя в течение выбранного кадра. **Буфер последнего кадра** в верхней части окна отображает цвет, который записывается в буфер кадров в конце кадра, вместе с дополнительной информацией о пикселе, такой как фрейм, что он поступает из и его экранные координаты. Эта область также содержит **отрисовка альфа-канала** "флажок". Если этот флажок установлен, **буфер последнего кадра** цвета и значения промежуточного цвета отображаются с прозрачностью через шахматной. Если флажок снят, альфа-канал цветовых значений игнорируется.  
  
 В нижней части окна отображаются события, которые имели возможность повлиять на цвет пикселя, вместе с **начальной** и **окончательный** псевдособытиями, представляющие начальные и конечные цветовые значения пикселя в буфере кадров. Начальное значение цвета определяется первым событием, которое изменило цвет пикселя (обычно событием `Clear`). Пиксель всегда имеет эти два псевдособытия в своем журнале даже при отсутствии других событий, повлиявших на него. Если другие события имели возможность повлиять на пиксель, они отображаются между **начальной** и **окончательный** события. События можно разворачивать для просмотра подробных сведений о них. Для простых событий, например, удаляющих целевой объект отрисовки, результатом события будет лишь значение цвета. Более сложные события, такие как вызовы рисования, создают один или несколько примитивов, которые могут вносить свой вклад в цвет пикселя.  
  
 Примитивы, нарисованные событием, идентифицируются по типу примитива и индексу вместе с общим количеством примитивов для объекта. Например, такой идентификатор, как **треугольник (1456) из (6214)** означает, что примитив соответствует 1456-му треугольнику в объекте, который состоит из 6214 треугольников. Слева от каждого идентификатора примитива есть значок, указывающий на то, какое влияние примитив оказал на пиксель. Примитивы, которые влияют на цвет пикселя, представлены скругленным прямоугольником, который заливается результирующим цветом. Примитивы, которые исключаются из оказания влияния на цвет пикселя, представлены значками, указывающими на причину исключения пикселя. Эти значки будут рассмотрены в разделе [исключение примитива](../debugger/graphics-pixel-history.md#exclusion) далее в этой статье.  
  
 Можно развернуть каждый примитив, чтобы проверить, как вывод построителя текстуры объединяется с существующим цветом пикселя для создания результирующего цвета. Здесь также можно проверить или отладить код построителя текстуры, связанного с примитивом, а также можно далее развернуть узел вершинного построителя текстуры для проверки его входных данных.  
  
###  <a name="exclusion"></a> Исключение примитива  
 Примитив может исключаться из оказания влияния на цвет пикселя в силу различных причин. Каждая причина представлена значком, который описан в таблице ниже.  
  
|Значок|Причина исключения|  
|----------|--------------------------|  
|![Значок непройденного теста глубины. ](../debugger/media/vsg-hist-icon-failed-depth.png "vsg_hist_icon_failed_depth")|Пиксель был исключен, поскольку он не прошел тест глубины.|  
|![Значок непройденного теста на отсечение. ](../debugger/media/vsg-hist-icon-failed-scissor.png "vsg_hist_icon_failed_scissor")|Пиксель был исключен, поскольку он не прошел тест на отсечение.|  
|![Значок непройденного теста трафарета. ](../debugger/media/vsg-hist-icon-failed-stencil.png "vsg_hist_icon_failed_stencil")|Пиксель был исключен, поскольку он не прошел тест трафарета.|  
  
### <a name="draw-call-exclusion"></a>Исключение вызова рисования  
 Если все примитивы в вызове рисования исключаются, т. е. не влияют на целевой объект отрисовки, потому что не проходят тест, то вызов рисования нельзя развернуть, и рядом с ним отображается значок, соответствующий причине исключения. Причины исключений вызовов рисования аналогичны причинам исключения примитивов, и их значки также аналогичны.  
  
### <a name="viewing-and-debugging-shader-code"></a>Просмотр и отладка кода шейдера  
 Можно проверить и отладить код для шейдеров вершин, поверхностей, доменов, геометрии и пикселей с помощью элементов управления под примитивом, связанным с шейдером.  
  
##### <a name="to-view-a-shaders-source-code"></a>Просмотр исходного кода шейдера  
  
1.  В **журнал пикселей графики** окна, найдите вызов рисования, соответствующий тому шейдеру необходимо изучить и развернуть его.  
  
2.  Под вызовом рисования, который вы только что развернули, выберите примитив, который демонстрирует интересующую вас проблему, и разверните его.  
  
3.  Под примитивом, вас интересует, перейдите по ссылке заголовка шейдера — например, перейдите по ссылке **Vertex Shader obj: 30** Чтобы просмотреть исходный код шейдера вершин.  
  
    > [!TIP]
    >  Номер объекта **obj: 30**, идентифицирует этот шейдер во всем интерфейсе анализатора графики такого объекта таблицы или окно этапов конвейера.  
  
##### <a name="to-debug-a-shader"></a>Отладка шейдера  
  
1.  В **журнал пикселей графики** окна, найдите вызов рисования, соответствующий тому шейдеру необходимо изучить и развернуть его.  
  
2.  Затем под вызовом рисования, который вы только что развернули, выберите примитив, который демонстрирует интересующую вас проблему, и разверните его.  
  
3.  Под примитивом, вас интересует, выберите **начать отладку**. Эта точка входа в отладчик HLSL по умолчанию устанавливается как первый вызов шейдера для соответствующего примитива, то есть первый пиксель или вершина, обрабатываемая шейдером. Существует только один пиксель, связанный с примитивом, но может быть несколько вызовов шейдера вершин для линий и треугольников.  
  
     Чтобы отладить вызов шейдера вершин для конкретной вершины, разверните ссылку заголовка VertexShader и найдите вершин, которые вас интересуют, затем выберите **начать отладку** рядом с ним.  
  
### <a name="links-to-graphics-objects"></a>Ссылки на графические объекты  
 Чтобы понять события графики в истории пикселя, могут потребоваться сведения о состоянии устройства во время события или об объектах Direct3D, на которые ссылается событие. Для каждого события в журнале пикселей **журнал пикселей графики** ссылки на устройства затем текущего состояния и на связанные объекты.  
  
## <a name="see-also"></a>См. также  
 [Пошаговое руководство: Отсутствие объектов вследствие состояния устройства](../debugger/walkthrough-missing-objects-due-to-device-state.md)   
 [Пошаговое руководство. Отладка ошибок отрисовки, возникающих из-за заливки](../debugger/walkthrough-debugging-rendering-errors-due-to-shading.md)



