---
title: "Visual C++ Classes in Class Designer | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-ide-general"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vs.classdesigner.inheritancelinelabel"
helpviewer_keywords: 
  - "Class Designer [Visual Studio], classes"
ms.assetid: 75e56f8c-11ef-42a3-b7ec-3d2cf25c581b
caps.latest.revision: 19
caps.handback.revision: 19
author: "kempb"
ms.author: "kempb"
manager: "ghogen"
---
# Visual C++ Classes in Class Designer
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

Конструктор классов поддерживает классы C\+\+ и отображает собственные классы C\+\+ так же, как фигуры классов Visual Basic и Visual C\#, за исключением того что классы C\+\+ могут обладать отношениями множественного наследования.  Для отображения полей и методов в классе можно развернуть фигуру класса или свернуть ее для экономии места.  
  
> [!NOTE]
>  Конструктор классов не поддерживает объединения \(специальный тип класса, в котором память выделяется только по мере необходимости для объединения больших данных\-членов\).  
  
## Простое наследование  
 При перетаскивании в схему классов более одного класса классы, имеющие отношения наследования, будут соединены стрелкой.  Стрелка указывает в направлении базового класса.  Например, если отобразить в схеме следующие классы, то они будут соединены стрелкой, указывающей от B к A:  
  
```  
class A {};  
class B : A {};  
```  
  
 Можно перетащить в схему классов только один класс B и просмотреть его базовые классы, щелкнув правой кнопкой мыши фигуру класса B и затем выбрав команду **Показать базовые классы**.  Будет показан его базовый класс: A.  
  
## Множественное наследование  
 Конструктор классов поддерживает наглядное представление отношений множественного наследования классов.  *Множественное наследование* используется, если у производного класса есть атрибуты более чем одного базового класса.  Пример множественного наследования:  
  
```  
class Bird {};  
class Swimmer {};  
class Penguin : public Bird, public Swimmer {};  
```  
  
 При перетаскивании в схему классов более одного класса появится стрелка, соединяющая классы, которые обладают отношениями множественного наследования.  Стрелка указывает в направлении базовых классов.  
  
 Чтобы отобразить базовые классы выбранного класса, щелкните правой кнопкой мыши фигуру класса и затем выберите команду **Показать базовые классы**.  
  
> [!NOTE]
>  Команда **Показать производные классы** не поддерживается для кода C\+\+.  Чтобы отобразить производные классы, необходимо перейти в "Окно классов", развернуть узел типа, затем развернуть вложенную папку **Производные типы** и перетащить требуемые классы в схему классов.  
  
 Дополнительные сведения о множественном наследовании классов см. в разделах [Множественное наследование](http://msdn.microsoft.com/ru-ru/3b74185e-2beb-4e29-8684-441e51d2a2ca) и [Несколько базовых классов](/visual-cpp/cpp/multiple-base-classes).  
  
## Абстрактные классы  
 Конструктор классов поддерживает абстрактные классы \(также называемые "абстрактные базовые классы"\).  Из данных классов никогда не создаются экземпляры, но из них можно создать другие производные классы.  Используя пример, приведенный в данном документе в разделе "Множественное наследование", можно создать экземпляр класса `Bird` как отдельный объект:  
  
```  
int main()  
{  
   Bird sparrow;  
   Bird crow;  
   Bird eagle;  
}  
```  
  
 Однако нельзя создать экземпляр класса `Swimmer` как отдельный объект.  Из него можно создать производные классы других типов классов животных, например `Penguin`, `Whale` и `Fish`.  В данном случае класс `Swimmer` будет объявлен как абстрактный базовый класс.  
  
 Чтобы объявить абстрактный класс, необходимо использовать ключевое слово `abstract`.  Члены, помеченные как абстрактные или включенные в абстрактный класс, являются виртуальными и должны быть реализованы с помощью классов, производных от абстрактного класса.  
  
```  
class Swimmer abstract  
{  
   virtual void swim();  
   void dive();  
};  
```  
  
 Также можно объявить класс как абстрактный, включив по крайней мере одну чисто виртуальную функцию:  
  
```  
class Swimmer  
{  
   virtual void swim() = 0;  
   void dive();  
};  
```  
  
 При отображении данных объявлений в схеме классов имя класса `Swimmer` и его чисто виртуальная функция `swim` отображаются курсивом в фигуре абстрактного класса вместе с обозначением **Абстрактный класс**.  Обратите внимание, что представление фигуры типа абстрактного класса такое же, как обычного класса, за исключением того что граница класса обозначена пунктирной линией.  
  
 Класс, являющийся производным от абстрактного базового класса, должен переопределять каждую чисто виртуальную функцию в базовом классе, иначе невозможно будет создать экземпляр из производного класса.  Например, если класс `Fish` является производным от класса `Swimmer`, класс `Fish` должен переопределять метод `swim`:  
  
```  
class Fish : public Swimmer  
{  
   void swim(int speed);  
};  
  
int main()  
{  
   Fish guppy;  
}  
```  
  
 При отображении данного кода в схеме классов конструктор классов нарисует линию наследования от `Fish` к `Swimmer`.  
  
## Анонимные классы  
 Конструктор классов поддерживает анонимные классы.  *Классы анонимных типов* — это классы, объявленные без идентификатора.  У анонимных классов не может быть конструктора или деструктора, они не могут быть переданы в качестве аргументов и не могут быть возвращены так же, как возвращаются значения из функций.  Анонимный класс можно использовать для замены имени класса именем typedef, как показано в следующем примере:  
  
```  
typedef struct  
{  
    unsigned x;  
    unsigned y;  
} POINT;  
```  
  
 Структуры также могут быть анонимными.  Конструктор классов отображает анонимные классы и структуры таким же образом, как отображает соответствующие типы.  Несмотря на то что можно объявить и отобразить анонимные классы и структуры, конструктор классов не будет использовать указанное пользователем имя тега.  Он будет использовать имя, которое создаст "Окно классов".  Класс или структура отображаются в "Окне классов" и "Конструкторе классов" как элементы с именем **\_\_unnamed**.  
  
 Дополнительные сведения об анонимных классах см. в разделе [Типы анонимных классов](/visual-cpp/cpp/anonymous-class-types).  
  
## Классы\-шаблоны  
 Конструктор классов поддерживает визуализацию классов\-шаблонов.  Вложенные объявления поддерживаются.  В следующей таблице представлены некоторые объявления:  
  
|Элемент кода|Представление конструктора классов|  
|------------------|----------------------------------------|  
|`template <class T>`<br /><br /> `class A {};`|`A<T>`<br /><br /> Класс\-шаблон|  
|`template <class T, class U>`<br /><br /> `class A {};`|`A<T, U>`<br /><br /> Класс\-шаблон|  
|`template <class T, int i>`<br /><br /> `class A {};`|`A<T, i>`<br /><br /> Класс\-шаблон|  
|`template <class T, template <class K> class U>`<br /><br /> `class A {};`|`A<T, U>`<br /><br /> Класс\-шаблон|  
  
 В следующей таблице представлено несколько примеров частичной специализации:  
  
|Элемент кода|Представление конструктора классов|  
|------------------|----------------------------------------|  
|`template<class T, class U>`<br /><br /> `class A {};`|`A<T, U>`<br /><br /> Класс\-шаблон|  
|`template<class T>`<br /><br /> `class A<T, T> {};`|`A<T, T>`<br /><br /> Класс\-шаблон|  
|`template <class T>`<br /><br /> `class A<T, int> {};`|`A<T, int>`<br /><br /> Класс\-шаблон|  
|`template <class T1, class T2>`<br /><br /> `class A<T1*, T2*> {};`|`A<T1*, T2*>`<br /><br /> Класс\-шаблон|  
  
 В следующей таблице представлено несколько примеров наследования в частичной специализации:  
  
|Элемент кода|Представление конструктора классов|  
|------------------|----------------------------------------|  
|`template <class T, class U>`<br /><br /> `class A {};`<br /><br /> `template <class TC>`<br /><br /> `class A<T, int> {};`<br /><br /> `class B : A<int, float>`<br /><br /> `{};`<br /><br /> `class C : A<int, int>`<br /><br /> `{};`|`A<T, U>`<br /><br /> Класс\-шаблон<br /><br /> `B`<br /><br /> Класс<br /><br /> \(указывает на класс A\)<br /><br /> `C`<br /><br /> Класс<br /><br /> \(указывает на класс A\)|  
  
 В следующей таблице представлено несколько примеров частичной специализации функций\-шаблонов:  
  
|Элемент кода|Представление конструктора классов|  
|------------------|----------------------------------------|  
|`class A`<br /><br /> `{`<br /><br /> `template <class T, class U>`<br /><br /> `void func(T a, U b);`<br /><br /> `template <class T>`<br /><br /> `void func(T a, int b);`<br /><br /> `};`|`A`<br /><br /> func\<T, U\> \(\+ 1 перегрузка\)|  
|`template <class T1>`<br /><br /> `class A {`<br /><br /> `template <class T2>`<br /><br /> `class B {};`<br /><br /> `};`<br /><br /> `template<> template<>`<br /><br /> `class A<type>::B<type> {};`|`A<T1>`<br /><br /> Класс\-шаблон<br /><br /> `B<T2>`<br /><br /> Класс\-шаблон<br /><br /> \(B содержится в классе A под узлом **Вложенные типы**\)|  
|`template <class T>`<br /><br /> `class C {};`<br /><br /> `class A : C<int> {};`|`A`<br /><br /> Класс<br /><br /> \-\> C\<int\><br /><br /> `C<T>`<br /><br /> Класс\-шаблон|  
  
 В следующей таблице представлено несколько примеров шаблонов наследования:  
  
|Элемент кода|Представление конструктора классов|  
|------------------|----------------------------------------|  
|`template <class T>`<br /><br /> `class C {};`<br /><br /> `template<>`<br /><br /> `class C<int> {`<br /><br /> `class B {};`<br /><br /> `}`<br /><br /> `class A : C<int>::B {};`|`A`<br /><br /> Класс<br /><br /> \-\>B<br /><br /> `C<int>`<br /><br /> Класс<br /><br /> \(B содержится в классе C под узлом **Вложенные типы**\)<br /><br /> `C<T>`<br /><br /> Класс\-шаблон|  
  
 В следующей таблице представлено несколько примеров канонических связей между специализированными классами:  
  
|Элемент кода|Представление конструктора классов|  
|------------------|----------------------------------------|  
|`template <class T>`<br /><br /> `class C {};`<br /><br /> `template<>`<br /><br /> `class C<int> {};`<br /><br /> `class A : C<int> {};`<br /><br /> `class D : C<float> {};`|`A`<br /><br /> Класс<br /><br /> \-\> C\<int\><br /><br /> `C<int>`<br /><br /> Класс<br /><br /> `C<T>`<br /><br /> Класс\-шаблон<br /><br /> `D`<br /><br /> Класс<br /><br /> \-\>C\<float\>|  
|`class B {`<br /><br /> `template <class T>`<br /><br /> `T min (const T &a, const T &b);`<br /><br /> `};`|`B`<br /><br /> min \<T\>|  
  
## См. также  
 [Working with Visual C\+\+ Code \(Class Designer\)](../ide/working-with-visual-cpp-code-class-designer.md)   
 [Классы и структуры](/visual-cpp/cpp/classes-and-structs-cpp)   
 [Типы анонимных классов](/visual-cpp/cpp/anonymous-class-types)   
 [Множественное наследование](http://msdn.microsoft.com/ru-ru/3b74185e-2beb-4e29-8684-441e51d2a2ca)   
 [Несколько базовых классов](/visual-cpp/cpp/multiple-base-classes)   
 [Шаблоны](/visual-cpp/cpp/templates-cpp)