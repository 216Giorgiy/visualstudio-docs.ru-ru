---
title: Основные сведения о языке SAL
ms.date: 11/04/2016
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
ms.assetid: a94d6907-55f2-4874-9571-51d52d6edcfd
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: 928ecfc2ebe652ae307d506d0747746d02c7c269
ms.sourcegitcommit: 42ea834b446ac65c679fa1043f853bea5f1c9c95
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/19/2018
---
# <a name="understanding-sal"></a>Основные сведения о языке SAL
Заметка язык исходного кода Майкрософт (SAL) предоставляет набор заметок, которые можно использовать для описания того, как функция использует свои параметры, допущений, о ее и гарантирует, что делает его при завершении. Примечания определены в файле заголовка `<sal.h>`. Для изменения их анализа функции анализа кода Visual Studio для C++ использует заметки SAL. Дополнительные сведения о SAL 2.0 для разработки драйверов для Windows см. в разделе [заметки SAL 2.0 для Windows драйверы](http://go.microsoft.com/fwlink/?LinkId=250979).

 По умолчанию C и C++ могут использоваться только ограниченный разработчикам постоянно express назначение и неизменность. С помощью заметки SAL, можно описать функций более подробно, чтобы разработчикам, использующим их можно лучше понять, как их использовать.

## <a name="what-is-sal-and-why-should-you-use-it"></a>Что такое SAL и зачем ее использовать?
 Проще говоря, SAL является недорогим способом, позволяя компилятору проверьте код для вас.

### <a name="sal-makes-code-more-valuable"></a>SAL делает код более ценным
 SAL может помочь сделать проект код более понятным для человека и средств анализа кода. Рассмотрим следующий пример, показывающий функции времени выполнения C `memcpy`:

```cpp

void * memcpy(
   void *dest,
   const void *src,
   size_t count
);

```

 Узнать, что делает эту функцию? При реализации или вызывается функция, некоторые свойства должны поддерживаться для обеспечения правильного программы. Просто просмотрев объявление, подобное показанному в примере, не знаете, что они собой представляют. Без заметки SAL потребовалось бы полагаются на документации или комментарии к коду. Вот документации MSDN для `memcpy` говорит:

> «Копии счетчик байтов src в указанное место. Если источника и назначения перекрываются, поведение memcpy не определено. Используйте memmove для обработки перекрывающихся областей.
> **Примечание по безопасности:** убедитесь, что, буфер назначения совпадает с размером или больше, чем исходный буфер. Дополнительные сведения см. в разделе как избежать переполнения буфера.»

 Документация содержит несколько битов сведения, указывающие, что код должен поддерживать определенные свойства, чтобы убедиться в правильности программы:

-   `memcpy` Копирует `count` байтов из исходного буфера для буфера назначения.

-   Буфер назначения должен быть не меньше исходного буфера.

 Однако компилятор не удается прочитать документацию или неофициальные комментарии. Он не знает, что имеется отношение между двумя буферами и `count`, и его также невозможно подобрать эффективно о связи. SAL может большей наглядностью о свойствах и реализации функции, как показано ниже:

```cpp

void * memcpy(
   _Out_writes_bytes_all_(count) void *dest,
   _In_reads_bytes_(count) const void *src,
   size_t count
);
```

 Обратите внимание, эти заметки напоминают сведения в документации MSDN, но они являются более четкими и они соответствуют шаблону семантики. Когда вы читаете этот код, можно быстро понять свойств этой функции и как избежать проблем с безопасностью переполнение буфера. Более того семантических шаблонов, которые предоставляет SAL может повысить эффективность средств анализа кода автоматических в раннего обнаружения потенциальных ошибок. Предположим, что кто-то пишет дефектный реализация `wmemcpy`:

```cpp

wchar_t * wmemcpy(
   _Out_writes_all_(count) wchar_t *dest,
   _In_reads_(count) const wchar_t *src,
   size_t count)
{
   size_t i;
   for (i = 0; i <= count; i++) { // BUG: off-by-one error
      dest[i] = src[i];
   }
   return dest;
}

```

 Эта реализация содержит off по одной из распространенных ошибок. К счастью, автор кода включает SAL-аннотации размер буфера — средство анализа кода может перехватывать ошибки путем анализа только этой функции.

### <a name="sal-basics"></a>Основы SAL
 SAL определяет четыре основных типа параметров, которые распределены на категории по шаблонов использования.

|Категория|Аннотация параметра|Описание|
|--------------|--------------------------|-----------------|
|**Входные данные для вызываемая функция**|`_In_`|Данные вызываемой функции передается и обрабатывается только для чтения.|
|**Входные данные для вызывается функция и вывода в вызывающий объект**|`_Inout_`|Полезные данные потенциально изменяется и передается в функцию.|
|**Выходные данные в вызывающий объект**|`_Out_`|Вызывающий объект предоставляет только место для вызываемой функции для записи. Вызываемая функция записывает данные в этой области.|
|**Выходные данные из указателя в вызывающий объект**|`_Outptr_`|Как **вывода вызывающему объекту**. Значение, которое возвращается вызываемой функцией является указателем.|

 Эти четыре основных заметки можно сделать более явно различными способами. По умолчанию параметры-указатели заметками считаются необходимые — они должны иметь значение NULL для успешного выполнения функции. Наиболее часто используемых вариантов основные заметок указывает, что параметр-указатель необязательно, если оно равно NULL, функция может завершиться успешно при этом свою работу.

 В этой таблице показано, как различать обязательные и необязательные параметры:

||Параметры являются обязательными|Параметры являются необязательными|
|-|-----------------------------|-----------------------------|
|**Входные данные для вызываемая функция**|`_In_`|`_In_opt_`|
|**Входные данные для вызывается функция и вывода в вызывающий объект**|`_Inout_`|`_Inout_opt_`|
|**Выходные данные в вызывающий объект**|`_Out_`|`_Out_opt_`|
|**Выходные данные из указателя в вызывающий объект**|`_Outptr_`|`_Outptr_opt_`|

 Эти заметки для выявления возможных значений неинициализированным и использует недопустимый указатель null в виде формальной и актуальности. Передача NULL для обязательного параметра может привести к сбою или может вызвать с кодом ошибки «сбой», должны быть возвращены. В любом случае функция не может успешно выполнять свою работу.

## <a name="sal-examples"></a>Примеры SAL
 В этом разделе показаны примеры кода для основных заметки SAL.

### <a name="using-the-visual-studio-code-analysis-tool-to-find-defects"></a>С помощью средства анализа кода Visual Studio для поиска дефектов
 В примерах средство анализа кода Visual Studio используется вместе с примечания SAL для поиска дефектов кода. Вот как это сделать.

##### <a name="to-use-visual-studio-code-analysis-tools-and-sal"></a>Чтобы использовать средства анализа кода Visual Studio и SAL

1.  В Visual Studio откройте проект C++, который содержит примечания SAL.

2.  В строке меню выберите **построения**, **выполнить анализ кода в решении**.

     Рассмотрим _In\_ пример в этом разделе. Это предупреждение отображается, если анализ кода для его:

    > **Недопустимое значение параметра C6387** «выберите команду» может быть "0": это не соответствует спецификации функции «InCallee».

### <a name="example-the-in-annotation"></a>Пример: _In\_ заметки
 `_In_` Заметка указывает, что:

-   Параметр должен быть допустимым и не будет изменен.

-   Функция будет выполнять только чтение из буфера одним элементом.

-   Вызывающий объект должен предоставить буфер и инициализировать его.

-   `_In_` Указывает, «только для чтения». Распространенная ошибка заключается в том, чтобы применить `_In_` к параметру, который должен иметь `_Inout_` заметки вместо него.

-   `_In_` допускается, а не учитывается в анализаторе на скаляры, не являющейся указателем.

```cpp
void InCallee(_In_ int *pInt)
{
   int i = *pInt;
}

void GoodInCaller()
{
   int *pInt = new int;
   *pInt = 5;

   InCallee(pInt);
   delete pInt;
}

void BadInCaller()
{
   int *pInt = NULL;
   InCallee(pInt); // pInt should not be NULL
}

```

 При использовании анализа кода Visual Studio в этом примере проверяет, что вызывающие объекты передать указатель ненулевой инициализированный буфер для `pInt`. В этом случае `pInt` указатель не может иметь значение NULL.

### <a name="example-the-inopt-annotation"></a>Пример: _In_opt\_ заметки
 `_In_opt_` совпадает со значением `_In_`, за исключением того, что входной параметр может иметь значение NULL, и, таким образом, функция следует проверить это.

```cpp

void GoodInOptCallee(_In_opt_ int *pInt)
{
   if(pInt != NULL) {
      int i = *pInt;
   }
}

void BadInOptCallee(_In_opt_ int *pInt)
{
   int i = *pInt; // Dereferencing NULL pointer 'pInt'
}

void InOptCaller()
{
   int *pInt = NULL;
   GoodInOptCallee(pInt);
   BadInOptCallee(pInt);
}

```

 Анализа кода Visual Studio проверяет, функция проверяет значение NULL перед обращением к буфера.

### <a name="example-the-out-annotation"></a>Пример: _Out\_ заметки
 `_Out_` поддерживает распространенным сценарием, в котором НЕНУЛЕВОЙ указатель на буфер элемент передается в, а функция инициализирует элемент. Вызывающий объект не имеет для инициализации буфера до вызова метода; Эта функция дает возможность инициализировать его, прежде чем вернуть.

```cpp

void GoodOutCallee(_Out_ int *pInt)
{
   *pInt = 5;
}

void BadOutCallee(_Out_ int *pInt)
{
   // Did not initialize pInt buffer before returning!
}

void OutCaller()
{
   int *pInt = new int;
   GoodOutCallee(pInt);
   BadOutCallee(pInt);
   delete pInt;
}

```

 Средство анализа кода Visual Studio проверяет, что вызывающий объект передает НЕНУЛЕВОЙ указатель на буфер для `pInt` и что буфера инициализируется с помощью функции перед возвратом.

### <a name="example-the-outopt-annotation"></a>Пример: _Out_opt\_ заметки
 `_Out_opt_` совпадает со значением `_Out_`, за исключением того, что параметр может иметь значение NULL, и, таким образом, функция следует проверить это.

```cpp

void GoodOutOptCallee(_Out_opt_ int *pInt)
{
   if (pInt != NULL) {
      *pInt = 5;
   }
}

void BadOutOptCallee(_Out_opt_ int *pInt)
{
   *pInt = 5; // Dereferencing NULL pointer 'pInt'
}

void OutOptCaller()
{
   int *pInt = NULL;
   GoodOutOptCallee(pInt);
   BadOutOptCallee(pInt);
}

```

 Анализа кода Visual Studio проверяет, что эта функция проверяет значение NULL перед `pInt` разыменовано и если `pInt` не равно NULL, буфер инициализируется с помощью функции перед возвратом.

### <a name="example-the-inout-annotation"></a>Пример: _Inout\_ заметки
 `_Inout_` используется для аннотирования параметра указатель, который может быть изменен с помощью функции. Указатель должен указывать на допустимый инициализированные данные до вызова метода, и даже в случае его изменения, по-прежнему должен иметь допустимое значение при возвращении. Заметка указывает, что функция может свободно чтение и запись в буфер одного элемента. Вызывающий объект должен предоставить буфер и инициализировать его.

> [!NOTE]
>  Как `_Out_`, `_Inout_` необходимо применить к изменяемое значение.

```cpp

void InOutCallee(_Inout_ int *pInt)
{
   int i = *pInt;
   *pInt = 6;
}

void InOutCaller()
{
   int *pInt = new int;
   *pInt = 5;
   InOutCallee(pInt);
   delete pInt;
}

void BadInOutCaller()
{
   int *pInt = NULL;
   InOutCallee(pInt); // 'pInt' should not be NULL
}

```

 Анализа кода Visual Studio проверяет, что вызывающие объекты передать указатель НЕНУЛЕВОЙ инициализированный буфер для `pInt`и, прежде чем возвращении `pInt` по-прежнему не пустое и инициализации буфера.

### <a name="example-the-inoutopt-annotation"></a>Пример: _Inout_opt\_ заметки
 `_Inout_opt_` совпадает со значением `_Inout_`, за исключением того, что входной параметр может иметь значение NULL, и, таким образом, функция следует проверить это.

```cpp

void GoodInOutOptCallee(_Inout_opt_ int *pInt)
{
   if(pInt != NULL) {
      int i = *pInt;
      *pInt = 6;
   }
}

void BadInOutOptCallee(_Inout_opt_ int *pInt)
{
   int i = *pInt; // Dereferencing NULL pointer 'pInt'
   *pInt = 6;
}

void InOutOptCaller()
{
   int *pInt = NULL;
   GoodInOutOptCallee(pInt);
   BadInOutOptCallee(pInt);
}

```

 Анализа кода Visual Studio проверяет, эта функция проверяет значение NULL перед обращением к буфера и если `pInt` не равно NULL, буфер инициализируется с помощью функции перед возвратом.

### <a name="example-the-outptr-annotation"></a>Пример: _Outptr\_ заметки
 `_Outptr_` используется для аннотирования параметра, который предназначен для возврата указателя.  Сам параметр не должен иметь значение NULL и вызываемая функция возвращает указатель отличное от NULL и что указатель указывает на инициализированных данных.

```cpp

void GoodOutPtrCallee(_Outptr_ int **pInt)
{
   int *pInt2 = new int;
   *pInt2 = 5;

   *pInt = pInt2;
}

void BadOutPtrCallee(_Outptr_ int **pInt)
{
   int *pInt2 = new int;
   // Did not initialize pInt buffer before returning!
   *pInt = pInt2;
}

void OutPtrCaller()
{
   int *pInt = NULL;
   GoodOutPtrCallee(&pInt);
   BadOutPtrCallee(&pInt);
}

```

 Анализа кода Visual Studio проверяет, что вызывающий объект передает НЕНУЛЕВОЙ указатель `*pInt`, и что буфера инициализируется с помощью функции перед возвратом.

### <a name="example-the-outptropt-annotation"></a>Пример: _Outptr_opt\_ заметки
 `_Outptr_opt_` совпадает со значением `_Outptr_`, за исключением того, что параметр является необязательным, вызывающий объект можно передать указатель NULL для параметра.

```cpp

void GoodOutPtrOptCallee(_Outptr_opt_ int **pInt)
{
   int *pInt2 = new int;
   *pInt2 = 6;

   if(pInt != NULL) {
      *pInt = pInt2;
   }
}

void BadOutPtrOptCallee(_Outptr_opt_ int **pInt)
{
   int *pInt2 = new int;
   *pInt2 = 6;
   *pInt = pInt2; // Dereferencing NULL pointer 'pInt'
}

void OutPtrOptCaller()
{
   int **ppInt = NULL;
   GoodOutPtrOptCallee(ppInt);
   BadOutPtrOptCallee(ppInt);
}

```

 Анализа кода Visual Studio проверяет, что эта функция проверяет значение NULL перед `*pInt` разыменовано, и что буфера инициализируется с помощью функции перед возвратом.

### <a name="example-the-success-annotation-in-combination-with-out"></a>Пример: _Success\_ заметки в сочетании с _Out\_
 Заметки могут применяться для большинства объектов.  В частности можно снабдить функции в целом.  Одной из характеристик очевидное функции — что ее выполнение или сбой. Но как связь между буфер и его размер, C/C++ не выражают функция успешное выполнение или сбой. С помощью `_Success_` заметки, можно сказать, какие успеха для функции выглядит следующим образом.  Параметр, чтобы `_Success_` заметки представляет собой обычное выражение, если установлено значение true указывает на успешное функции. Выражение может быть все, что средство синтаксического анализа заметки можно обработать. Эффекты заметок после возвращения функции применяются только в случае, если функция выполнена успешно. В этом примере показано, как `_Success_` взаимодействует с `_Out_` на правильное. Можно использовать ключевое слово `return` для представления возвращаемого значения.

```cpp

_Success_(return != false) // Can also be stated as _Success_(return)
bool GetValue(_Out_ int *pInt, bool flag)
{
   if(flag) {
      *pInt = 5;
      return true;
   } else {
      return false;
   }
}

```

 `_Out_` Заметки вызывает анализа кода Visual Studio для проверки, что вызывающий объект передает НЕНУЛЕВОЙ указатель на буфер для `pInt`, и что буфера инициализируется с помощью функции перед возвратом.

## <a name="sal-best-practice"></a>Рекомендуется SAL

### <a name="adding-annotations-to-existing-code"></a>Добавление заметок для существующего кода
 SAL — это мощная технология, которая поможет повысить безопасность и надежность кода. После того как вы узнаете SAL, можно применить новый навык в ежедневной работе. В новом коде можно использовать на основе SAL спецификации, во всех; в старом коде можно постепенно добавлять заметки и тем самым повысить преимущества при каждом обновлении.

 Уже были снабжены общих заголовках корпорации Майкрософт. Поэтому мы рекомендуем, что в проектах сначала аннотировании конечный узел функций и функций, которые вызывают API-интерфейсов Win32 для эффективной работы.

### <a name="when-do-i-annotate"></a>Если пометить?
 Ниже приведены некоторые рекомендации.

-   Добавление заметок всех параметров-указателей.

-   Добавление заметок заметки диапазон значений, чтобы анализ кода можно обеспечить безопасность буфера и указатель.

-   Добавление заметок правила блокировки и побочных эффектов. Дополнительные сведения см. в разделе [Аннотация поведения блокировки](../code-quality/annotating-locking-behavior.md).

-   Добавление заметок свойства драйвера и других свойств конкретного домена.

 Или можно снабдить все параметры для создания вашего намерения clear на протяжении и позволяют легко проверить, были ли выполнены заметки.

## <a name="related-resources"></a>Связанные ресурсы
 [Блог команды разработчиков анализа кода](http://go.microsoft.com/fwlink/p/?LinkId=251197)

## <a name="see-also"></a>См. также
 [Использовании аннотаций SAL для сокращения дефектов в коде C/C++](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md) [Аннотация параметров функции и возвращаемых значений](../code-quality/annotating-function-parameters-and-return-values.md) [Аннотация поведения функций](../code-quality/annotating-function-behavior.md) [Аннотация структур и Классы](../code-quality/annotating-structs-and-classes.md) [Аннотация поведения блокировки](../code-quality/annotating-locking-behavior.md) [Указание времени и места применения примечания](../code-quality/specifying-when-and-where-an-annotation-applies.md) [рекомендации и примеры](../code-quality/best-practices-and-examples-sal.md)