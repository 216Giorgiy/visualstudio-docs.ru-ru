---
title: C26115
ms.date: 11/04/2016
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C26115
helpviewer_keywords:
- C26115
ms.assetid: 3977a2bb-d1fe-4510-89dd-07fdc69e911c
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: e1bb5b7920482f6b9ac766b291ff7d816d2fa914
ms.sourcegitcommit: 42ea834b446ac65c679fa1043f853bea5f1c9c95
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/19/2018
---
# <a name="c26115"></a>C26115
Предупреждение C26115: удается освободить блокировку \<блокировки > в функции \<func >.

 Принудительного применения блокировок с синтаксически областью *получить* и блокировки *выпуска* пар в программ C/C++ в данном языке не выполняется. Функция может вызвать блокировки побочный эффект, делая наблюдаемый изменения состояния параллелизма. Например функции-оболочки блокировки увеличивает число приобретения блокировки или число блокировок, для данной блокировки.

 Можно снабдить функции, имеющей побочный эффект от блокировки получить или заблокировать выпуска с помощью `_Acquires_lock_` или `_Releases_lock_`соответственно. Без такого заметок функции ожидается не изменить любое число блокировок, после возврата. Если получает и выпуски не сбалансированы, они считаются *потерянные*. C26115 предупреждение выдается в том случае, когда функция вводит потерянная блокировка.

## <a name="example"></a>Пример
 Следующий пример приводит к возникновению предупреждения C26115 из-за потерянная блокировка в функцию, которая не помечается с помощью `_Acquires_lock_`.

```

typedef struct _DATA
{
    CRITICAL_SECTION cs;
} DATA;

void FailToReleaseLock(int flag, DATA* p)
{
    EnterCriticalSection(&p->cs);

    if (flag)
        return; // Warning C26115

    LeaveCriticalSection(&p->cs);
}

```