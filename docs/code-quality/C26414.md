---
title: C26414 | Документы Microsoft
ms.custom: ''
ms.date: 11/15/2017
ms.reviewer: ''
ms.suite: ''
ms.technology:
- vs-ide-code-analysis
ms.tgt_pltfrm: ''
ms.topic: article
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- multiple
ms.openlocfilehash: 6c90ca8d41d2b7c861ad8c1229fd747f21308805
ms.sourcegitcommit: 32f1a690fc445f9586d53698fc82c7debd784eeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="c26414-resetlocalsmartptr"></a>C26414 RESET_LOCAL_SMART_PTR
«Перемещения, копирования, переназначить или сбросить локального интеллектуального указателя.»

**Правила C++ Core**:   
R.5: Предпочитают объектов с областью, не кучи выделите без необходимости

Интеллектуальные указатели удобны для управления динамический ресурс, но они не всегда нужны. Например, создание локальной динамической буфера может быть легко (иногда завершить более эффективно) под управлением стандартные контейнеры. Для одного объекта может оказаться ненужные делать динамическое выделение вообще (например, если такие объекты никогда не пережить их функцию создателя) и могут быть заменены локальных переменных. Интеллектуальные указатели становятся удобно, если сценарий требует изменения владения, т. е. переназначение динамического ресурса несколько раз или несколько путей. Сюда также включаются в случаях, когда ресурсы получаются из внешнего кода и интеллектуальные указатели используются для увеличения времени жизни ресурса.

## <a name="remarks"></a>Примечания    
 -  Помимо стандартных std::unique_pointer и std::shared_pointer шаблоны эта проверка распознает определяемые пользователем типы, которые скорее всего предназначены для интеллектуальных указателей. Предполагается, что такие типы определяются следующие операции:
-  перегруженные разыменования или операторы доступа к членам, открытым и не отмечен как как удаленные;
-  открытого деструктора, которой не удален и не используемые по умолчанию. Сюда входят деструкторов, которые явно определены пустым.
-  Тип Microsoft::wrl:: comptr ведет себя как общий указатель, но часто используется в довольно определенных сценариев, которые зависят от управление временем существования COM. Чтобы избежать чрезмерные шумы этого типа, отфильтровываются.
-  Эта проверка выявляет явные локальные выделения, назначенные интеллектуальные указатели, чтобы выявить области действия переменных может word в качестве альтернативы. Помимо прямые вызовы оператора new специальных функций, таких как std::make_unique и std::make_shared также интерпретируется как прямые выделения.
- 
## <a name="example"></a>Пример 
динамические буфера

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```
## <a name="example"></a>Пример 
динамические буфера — заменяется контейнера

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
