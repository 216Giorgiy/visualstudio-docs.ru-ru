---
title: C26414
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 41c77b2f22f8410fab681aa0a7930a383cf9e677
ms.sourcegitcommit: 2193323efc608118e0ce6f6b2ff532f158245d56
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/25/2019
ms.locfileid: "55042586"
---
# <a name="c26414-resetlocalsmartptr"></a>C26414 RESET_LOCAL_SMART_PTR
«Перемещения, копирования, переназначьте или сбросьте локальный смарт-указатель.»

**C++ Core Guidelines**: R.5: Предпочитать объектам, не кучи выделить излишне

Интеллектуальные указатели удобны для управления динамический ресурс, но они не всегда нужны. Например, создание локальных динамических буфера может быть легко (завершить иногда более эффективно) управляет стандартных контейнеров. Для отдельных объектов может быть не нужно выполнять динамическое выделение вообще (например, если такие объекты, никогда не пережить функцию их создателя) и которые могут быть заменены с локальными переменными. Интеллектуальные указатели стать удобно, если сценарий требует изменения владения, т. е. переназначение динамического ресурса несколько раз или несколько путей. Сюда также входит в случаях, когда ресурсы получаются из внешнего кода и интеллектуальные указатели используются для увеличения времени существования ресурса.

## <a name="remarks"></a>Примечания
- Помимо стандартных std::unique_pointer и шаблоны std::shared_pointer эта проверка распознает определяемые пользователем типы, которые скорее всего предназначены для интеллектуальных указателей. Такие типы должны определить следующие операции:
  - перегруженные разыменования или операторы доступа к членам, входящие открытые и не помеченные как удаленные;
  - открытого деструктора, который не удален и не установленные по умолчанию. Сюда входят деструкторы, которые явным образом определяются пустые.
  - Тип Microsoft::wrl:: comptr ведет себя как общий указатель, но часто используется в довольно конкретных сценариев, которые зависят от управления жизненным циклом COM. Чтобы избежать чрезмерные шумы этого типа, фильтруются.
  - <a name="this-check-looks-for-explicit-local-allocations-assigned-to-smart-pointers-to-identify-if-scoped-variables-could-word-as-an-alternative-in-addition-to-direct-calls-to-operator-new-special-functions-like-stdmakeunique-and-stdmakeshared-are-also-interpreted-as-direct-allocations"></a>Эта проверка выполняет поиск локального явные выделения, назначенные интеллектуальные указатели, чтобы выявить области переменных может word в качестве альтернативы. Помимо прямого вызова оператора new специальных функций, таких как std::make_unique и std::make_shared также интерпретируется как прямое выделение.
    -
    ## <a name="example"></a>Пример
    динамические буфера

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```
## <a name="example"></a>Пример
динамические буфера — заменены контейнера

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
