---
title: C26414
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 6f4578ff7691b905a12ec24f96ee404e85e3d48a
ms.sourcegitcommit: e13e61ddea6032a8282abe16131d9e136a927984
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/26/2018
ms.locfileid: "31887613"
---
# <a name="c26414-resetlocalsmartptr"></a>C26414 RESET_LOCAL_SMART_PTR
«Перемещения, копирования, переназначить или сбросить локального интеллектуального указателя.»

**Основные правила C++**: R.5: предпочитают объектов с областью, не кучи выделите без необходимости

Интеллектуальные указатели удобны для управления динамический ресурс, но они не всегда нужны. Например, создание локальной динамической буфера может быть легко (иногда завершить более эффективно) под управлением стандартные контейнеры. Для одного объекта может оказаться ненужные делать динамическое выделение вообще (например, если такие объекты никогда не пережить их функцию создателя) и могут быть заменены локальных переменных. Интеллектуальные указатели становятся удобно, если сценарий требует изменения владения, т. е. переназначение динамического ресурса несколько раз или несколько путей. Сюда также включаются в случаях, когда ресурсы получаются из внешнего кода и интеллектуальные указатели используются для увеличения времени жизни ресурса.

## <a name="remarks"></a>Примечания
 -  Помимо стандартных std::unique_pointer и std::shared_pointer шаблоны эта проверка распознает определяемые пользователем типы, которые скорее всего предназначены для интеллектуальных указателей. Предполагается, что такие типы определяются следующие операции:
-  перегруженные разыменования или операторы доступа к членам, открытым и не отмечен как как удаленные;
-  открытого деструктора, которой не удален и не используемые по умолчанию. Сюда входят деструкторов, которые явно определены пустым.
-  Тип Microsoft::wrl:: comptr ведет себя как общий указатель, но часто используется в довольно определенных сценариев, которые зависят от управление временем существования COM. Чтобы избежать чрезмерные шумы этого типа, отфильтровываются.
-  Эта проверка выявляет явные локальные выделения, назначенные интеллектуальные указатели, чтобы выявить области действия переменных может word в качестве альтернативы. Помимо прямые вызовы оператора new специальных функций, таких как std::make_unique и std::make_shared также интерпретируется как прямые выделения.
-
## <a name="example"></a>Пример
динамические буфера

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```
## <a name="example"></a>Пример
динамические буфера — заменяется контейнера

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
