---
title: "Пошаговое руководство: Проверка на наличие дефектов кода C/C++ | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-code-analysis
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- C/C++, code analysis
- code analysis, walkthroughs
- code, analyzing C/C++
- code analysis tool, walkthroughs
ms.assetid: eaee55b8-85fe-47c7-a489-9be0c46ae8af
caps.latest.revision: "35"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: f3c3be4f5a2cebda5b7fd0f705eefc0077b36f29
ms.sourcegitcommit: fb751e41929f031d1a9247bc7c8727312539ad35
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/15/2017
---
# <a name="walkthrough-analyzing-cc-code-for-defects"></a>Пошаговое руководство. Проверка кода C/C++ на наличие дефектов
В этом пошаговом руководстве показано, как для анализа кода C/C++ для возможных дефектов в коде с помощью средства анализа кода для кода C/C++.  
  
 В этом пошаговом руководстве пошагово процесс с помощью функций анализа кода для анализа кода C/C++ для возможных дефектов в коде.  
  
 Выполняются следующие действия.  
  
-   Выполнить анализ кода в машинный код.  
  
-   Анализ предупреждений о дефектах кода.  
  
-   Обрабатывать предупреждения как ошибки.  
  
-   Включите исходный код для улучшения анализа дефект кода.  
  
## <a name="prerequisites"></a>Предварительные требования  
  
-   [!INCLUDE[vsPreLong](../code-quality/includes/vsprelong_md.md)] или [!INCLUDE[vsUltLong](../code-quality/includes/vsultlong_md.md)].  
  
-   Копия [демонстрационный пример](../code-quality/demo-sample.md).  
  
-   Базовое представление о C/C++.  
  
### <a name="to-run-code-defect-analysis-on-native-code"></a>Для выполнения анализа дефект кода в машинный код  
  
1.  Откройте решение Demo в [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)].  
  
     Решение Demo теперь появилось **обозревателе решений**.  
  
2.  На **построения** меню, нажмите кнопку **Перестроить решение**.  
  
     Сборка решения выполняется без ошибок и предупреждений.  
  
3.  В **обозревателе решений**, выберите проект CodeDefects.  
  
4.  В меню **Проект** выберите пункт **Свойства**.  
  
     **Страницы свойств CodeDefects** диалоговое окно.  
  
5.  Нажмите кнопку **анализ кода**.  
  
6.  Нажмите кнопку **включить анализ кода для C/C++ при сборке** флажок.  
  
7.  Перестройте проект CodeDefects.  
  
     Предупреждения анализа кода отображаются в **список ошибок**.  
  
### <a name="to-analyze-code-defect-warnings"></a>Анализ предупреждений о дефектах кода  
  
1.  На **представление** меню, нажмите кнопку **список ошибок**.  
  
     В зависимости от профиля разработчика, выбранного в [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)], возможно, чтобы она указывала на **другие окна** на **представление** меню, а затем нажмите **список ошибок**.  
  
2.  В **список ошибок**, дважды щелкните следующее предупреждение:  
  
     Предупреждение C6230: неявное приведение типов с разной семантикой: использование HRESULT в логическом контексте.  
  
     В редакторе кода отображается строка, вызвавшая предупреждение в функции `bool``ProcessDomain()`. Это предупреждение означает, что значение HRESULT используется в операторе «if» в там, где ожидается логическое значение.  
  
3.  Устраните это предупреждение с помощью макроса SUCCEEDED. Код должен выглядеть следующим образом:  
  
    ```  
    if (SUCCEEDED (ReadUserAccount()) )  
    ```  
  
4.  В **список ошибок**, дважды щелкните следующее предупреждение:  
  
     Предупреждение C6282: неверный оператор: присвоение константы в контекст теста. Был == предназначен?  
  
5.  Для решения этого предупреждения проверки на равенство. Код должен выглядеть примерно следующим кодом:  
  
    ```  
    if ((len == ACCOUNT_DOMAIN_LEN) || (g_userAccount[len] != '\\'))  
    ```  
  
### <a name="to-treat-warning-as-an-error"></a>Обрабатывать предупреждения как ошибки  
  
1.  В файле Bug.cpp добавьте следующие `#pragma` инструкции в начало файла, чтобы предупреждение C6001 как ошибка:  
  
    ```  
    #pragma warning (error: 6001)  
    ```  
  
2.  Перестройте проект CodeDefects.  
  
     В **список ошибок**, C6001 теперь отображается в виде ошибки.  
  
3.  Исправьте оставшиеся ошибки два C6001 в **список ошибок** путем инициализации `i` и `j` значение 0.  
  
4.  Перестройте проект CodeDefects.  
  
     Сборка проекта выполняется без предупреждения или ошибки.  
  
### <a name="to-correct-the-source-code-annotation-warnings-in-annotationc"></a>Исправление предупреждений заметки исходного кода в файле annotation.c  
  
1.  В обозревателе решений выберите проект заметок.  
  
2.  В меню **Проект** выберите пункт **Свойства**.  
  
     **Страницы свойств заметок** диалоговое окно.  
  
3.  Нажмите кнопку **анализ кода**.  
  
4.  Выберите **включить анализ кода для C/C++ при сборке** флажок.  
  
5.  Перестройте проект заметок.  
  
6.  В **список ошибок**, дважды щелкните следующее предупреждение:  
  
     Предупреждение C6011: разыменование указателя NULL «узел newNode».  
  
     Это предупреждение означает невозможность вызывающий объект проверять возвращаемое значение. В этом случае вызов **AllocateNode** может возвращать значение NULL (см. в файле заголовка annotations.h для AllocateNode в объявлении функции).  
  
7.  Откройте файл annotations.cpp.  
  
8.  Чтобы устранить это предупреждение, используйте оператор «if» для проверки возвращаемого значения. Код должен выглядеть следующим образом:  
  
     `if (NULL != newNode)`  
  
     `{`  
  
     `newNode->data = value;`  
  
     `newNode->next = 0;`  
  
     `node->next = newNode;`  
  
     `}`  
  
9. Перестройте проект заметок.  
  
     Сборка проекта выполняется без предупреждения или ошибки.  
  
### <a name="to-use-source-code-annotation"></a>Чтобы использовать примечания исходного кода  
  
1.  Добавление заметок формальные параметры и возвращаемое значение функции `AddTail` с помощью условия Pre и Post, как показано в следующем примере:  
  
     `[returnvalue:SA_Post (Null=SA_Maybe)] LinkedList* AddTail`  
  
     `(`  
  
     `[SA_Pre(Null=SA_Maybe)] LinkedList* node,`  
  
     `int value`  
  
     `)`  
  
2.  Перестройте проект заметок.  
  
3.  В **список ошибок**, дважды щелкните следующее предупреждение:  
  
     Предупреждение C6011: разыменование указателя NULL «узел».  
  
     Это предупреждение указывает, что переданный в функцию узел может иметь значение null и указывает номер строки, где было создано предупреждение.  
  
4.  Чтобы устранить это предупреждение, используйте оператор «if» для проверки возвращаемого значения. Код должен выглядеть следующим образом:  
  
    ```  
    . . .  
    LinkedList *newNode = NULL;   
    if (NULL == node)  
    {  
         return NULL;  
        . . .  
    }  
    ```  
  
5.  Перестройте проект заметок.  
  
     Сборка проекта выполняется без предупреждения или ошибки.  
  
## <a name="see-also"></a>См. также  
 [Пошаговое руководство. Проверка управляемого кода на наличие дефектов](../code-quality/walkthrough-analyzing-managed-code-for-code-defects.md)