---
title: C6384 | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C6384
helpviewer_keywords:
- C6384
ms.assetid: 9c605b61-1485-49a8-847b-41170193dbf4
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 3dfa6a81a3e58213228dbb3d39c3a116aa3e812e
ms.sourcegitcommit: 6a9d5bd75e50947659fd6c837111a6a547884e2a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="c6384"></a>C6384
Предупреждение C6384: деление sizeof указателя на другое значение  
  
 Это предупреждение означает, что вычисление размера могут быть неправильными. Чтобы вычислить количество элементов в массиве, иногда делится на единицу размер массива на размер первого элемента. Тем не менее если массив фактически является указателем, результат обычно отличается от ожидаемого.  
  
 Если размер буфера не был передан указатель является параметром функции, не поддерживается вычисляется максимальный буфер доступен. Когда указателя выделяется локально, следует использовать размер, используемый в выделении.  
  
## <a name="example"></a>Пример  
 Это предупреждение возникает в следующем коде:  
  
```  
#include <windows.h>  
#include <TCHAR.h>  
  
#define SIZE 15  
  
void f( )  
{  
  LPTSTR dest = new TCHAR[SIZE];  
  char src [SIZE] = "Hello, World!!";  
  if (dest)  
  {  
    _tcsncpy(dest, src, sizeof dest  / sizeof dest[0]);   
  }  
}  
```  
  
 Чтобы устранить это предупреждение, передайте размер буфера, как показано в следующем коде:  
  
```  
#include <windows.h>  
#include <TCHAR.h>  
  
#define SIZE 15  
  
void f( )  
{  
  LPTSTR dest = new TCHAR[SIZE];  
  char src [SIZE] = "Hello, World!!";  
  if (dest)  
  {  
    _tcsncpy(dest, src, SIZE);  
  }  
}  
```  
  
 Чтобы устранить это предупреждение, используя безопасной строковой функции _tcsncpy_s, используйте следующий код:  
  
```  
void f( )  
{  
  LPTSTR dest = new TCHAR[SIZE];  
  char src [SIZE] = "Hello, World!!";  
  if (dest)  
  {  
   _tcsncpy_s(dest, SIZE, src, SIZE);  
  }  
}   
```  
  
 Обратите внимание, что использование новых и delete имеют множество ловушек с точки зрения утечек памяти и исключения. Чтобы избежать такого рода утечки и исключение проблемы, используйте механизмов, которые содержатся в C++ стандартной библиотеки шаблонов (STL). К ним относятся [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class), и [вектор](/cpp/standard-library/vector). Дополнительные сведения см. в разделе [интеллектуальные указатели](/cpp/cpp/smart-pointers-modern-cpp) и [стандартной библиотеки C++](/cpp/standard-library/cpp-standard-library-reference).  
  
## <a name="see-also"></a>См. также  
 [_mbsnbcpy_s, _mbsnbcpy_s_l](/cpp/c-runtime-library/reference/mbsnbcpy-s-mbsnbcpy-s-l)   
 [Оператор sizeof](/cpp/cpp/sizeof-operator)