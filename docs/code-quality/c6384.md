---
title: C6384
ms.date: 11/04/2016
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C6384
helpviewer_keywords:
- C6384
ms.assetid: 9c605b61-1485-49a8-847b-41170193dbf4
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: 9725b5e648a14b1a7771768a8732469d66f35266
ms.sourcegitcommit: 42ea834b446ac65c679fa1043f853bea5f1c9c95
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/19/2018
---
# <a name="c6384"></a>C6384
Предупреждение C6384: деление sizeof указателя на другое значение

 Это предупреждение означает, что вычисление размера могут быть неправильными. Чтобы вычислить количество элементов в массиве, иногда делится на единицу размер массива на размер первого элемента. Тем не менее если массив фактически является указателем, результат обычно отличается от ожидаемого.

 Если размер буфера не был передан указатель является параметром функции, не поддерживается вычисляется максимальный буфер доступен. Когда указателя выделяется локально, следует использовать размер, используемый в выделении.

## <a name="example"></a>Пример
 Это предупреждение возникает в следующем коде:

```
#include <windows.h>
#include <TCHAR.h>

#define SIZE 15

void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
    _tcsncpy(dest, src, sizeof dest  / sizeof dest[0]);
  }
}
```

 Чтобы устранить это предупреждение, передайте размер буфера, как показано в следующем коде:

```
#include <windows.h>
#include <TCHAR.h>

#define SIZE 15

void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
    _tcsncpy(dest, src, SIZE);
  }
}
```

 Чтобы устранить это предупреждение, используя безопасной строковой функции _tcsncpy_s, используйте следующий код:

```
void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
   _tcsncpy_s(dest, SIZE, src, SIZE);
  }
}
```

 Обратите внимание, что использование новых и delete имеют множество ловушек с точки зрения утечек памяти и исключения. Чтобы избежать такого рода утечки и исключение проблемы, используйте механизмов, которые содержатся в C++ стандартной библиотеки шаблонов (STL). К ним относятся [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class), и [вектор](/cpp/standard-library/vector). Дополнительные сведения см. в разделе [интеллектуальные указатели](/cpp/cpp/smart-pointers-modern-cpp) и [стандартной библиотеки C++](/cpp/standard-library/cpp-standard-library-reference).

## <a name="see-also"></a>См. также
 [_mbsnbcpy_s, _mbsnbcpy_s_l](/cpp/c-runtime-library/reference/mbsnbcpy-s-mbsnbcpy-s-l) [оператор sizeof](/cpp/cpp/sizeof-operator)