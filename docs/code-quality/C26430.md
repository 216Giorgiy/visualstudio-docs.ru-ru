---
title: "C26430 | Документы Microsoft"
ms.custom: 
ms.date: 11/15/2017
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-code-analysis
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: C26430
helpviewer_keywords: C26430
ms.assetid: 3dca2626-8102-4eed-8ff3-73eb3d5c328c
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: 04b20698c65c7942e1d0153d046352efedcd067b
ms.sourcegitcommit: f36eb7f989efbdbed0d0a087afea8ffe27d8ca15
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/14/2017
---
# <a name="c26430-testonallpaths"></a>C26430 TEST_ON_ALL_PATHS
«Символ не тестировался на nullness во всех путях.»

**Правила C++ Core**:   
F.23: Используйте not_null<T> для указания, что «null» не является допустимым значением

Если код никогда не проверяет nullness указатель переменных следует постоянно этого и проверить указатели на всех путях. Иногда overaggressive проверка nullness еще лучше, чем вероятность жестких аварийного завершения работы в одной из ветвей сложной. В идеале такой код следует провести оптимизацию кода должны быть менее сложными (путем разделения на несколько функций) и полагаться на маркеры как gsl::not_null (см. рекомендации библиотека поддержки) для изоляции частей алгоритма, который может делать безопасном предположения о значениях допустимый указатель. Правило, TEST_ON_ALL_PATHS помогает найти места, где nullness проверяет, являются либо несогласованные (поэтому предположения может потребоваться проверка) или проверьте где потенциальных значение null может обойти nullness фактических ошибок в некоторых ветвей кода.

## <a name="remarks"></a>Примечания    
 -  Это правило ожидает, что код разыменовывает переменной указателя, чтобы бы ширине проверки nullness (или применение ненулевое значение). Если нет разыменования, правило будет приостановлена.
-  Текущая реализация обрабатывает только обычные указатели (или их псевдонимов) и не обнаруживает интеллектуальные указатели, даже если nullness проверок применимы к также интеллектуальные указатели.
-  Переменная помечается как проверяется на nullness, когда он используется в следующих контекстах:
-  как символ выражение в условие ветви например «если (p) {...}»;
-  Побитовые логические операции;
-  операции сравнения, где один операнд имеет константного выражения, которое будет равно нулю.
-  Правило не содержит полные данные отслеживания потока и может выдавать неверные результаты в случаях, где используются косвенных проверки (например при промежуточной переменной содержит значение null, а позже используется для сравнения).
-  Проверяет неявные nullness, как предполагается, когда значение указателя назначается из:
-  Распределение выполняется с помощью оператора создает исключение, новый;
-  указатель, полученный от тип, отмеченный атрибутом gsl::not_null.
## <a name="example"></a>Пример 
несогласованные тестирование показывает логическая ошибка

```cpp
void merge_states(const state *left, const state *right) // C26430
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (!left && !right)                            // Logic error!
            discard(left, right);
    }
}
```

## <a name="example"></a>Пример 
несогласованные тестирование показывает логическая ошибка - исправлено

```cpp
void merge_states(gsl::not_null<const state *> left, gsl::not_null<const state *> right)
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (*left && *right)
            discard(left, right);
    }
}
```
