---
title: "C26415 | Документы Microsoft"
ms.custom: 
ms.date: 11/15/2017
ms.reviewer: 
ms.suite: 
ms.technology:
- vs-ide-code-analysis
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- C26415
helpviewer_keywords:
- C26415
ms.assetid: 4165f70a-78ae-4a03-b256-c4bd74b02d09
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- multiple
ms.openlocfilehash: 1459353475ff56aa37c3e77827416c6900a12ad5
ms.sourcegitcommit: 32f1a690fc445f9586d53698fc82c7debd784eeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="c26415-smartptrnotneeded"></a>C26415 SMART_PTR_NOT_NEEDED
«Смарт-указатель параметр используется только для доступа содержится указатель. Используйте T * или T & вместо.»

**Правила C++ Core**:   
R.30: Принимающими интеллектуальные указатели в качестве параметров только на семантику явно express время существования

С помощью типа интеллектуального указателя для передачи данных в функции указывает, что целевой функции для управления временем жизни объекта в контейнере. Тем не менее если эта функция использует только интеллектуальных указателей для доступа к вложенным объектом и фактически не вызывает любой код, что может привести к его освобождения (никогда не влияет на время существования) обычно нет необходимости усложнить интерфейс с интеллектуальными указателями. Обычный указатель или ссылка на содержащийся объект должен быть предпочтительным.

## <a name="remarks"></a>Примечания    
 -  Эта проверка не охватывает большинство сценариев, также вызывает C26410, C26415, C26417 и C26418. Оно лучше очистки SMART_PTR_NOT_NEEDED сначала и перейдите в крайних случаев для общих или уникальных указателей. Для более с фокусом ввода очистки это предупреждение можно отключить.
-  Помимо стандартных std::unqiue_pointer и std::shared_pointer шаблоны эта проверка распознает определяемые пользователем типы, которые скорее всего предназначены для интеллектуальных указателей. Предполагается, что такие типы определяются следующие операции:
-  перегруженные разыменования или операторы доступа к членам, открытым и не отмечен как как удаленные;
-  открытого деструктора, которой не удален и не используемые по умолчанию. Сюда входят деструкторов, которые явно определены пустым.
-  Интерпретация операций, которые могут повлиять на время существования объектов, содержащихся достаточно широкий и включает в себя:
-  Любая функция, которая принимает параметр указатель или ссылка на неконстантный смарт-указатель;
-  копирование и перемещение конструкторы и операторы присваивания;
-  Константа-методы.
## <a name="example"></a>Пример 
Управление временем существования громоздким

```cpp
bool set_initial_message(
            const std::unique_ptr<message> &m) // C26415, also C26410 NO_REF_TO_CONST_UNIQUE_PTR
{
    if (!m || initial_message_)
        return false;

    initial_message_.reset(m.get());
    return true;
}

void pass_message(const message_info &info)
{
    auto m = std::make_unique<message>(info);
    const auto release = set_initial_message(m);
    // ...
    if (release)
        m.release();
}
```

## <a name="example"></a>Пример 
сложно существования - переделать

```cpp
void set_initial_message(std::shared_ptr<message> m) noexcept
{
    if (m && !initial_message_)
        initial_message_ = std::move(m);
}

void pass_message(const message_info &info)
{
    auto m = std::make_shared<message>(info);
    set_initial_message(m);
    // ...
}
```
