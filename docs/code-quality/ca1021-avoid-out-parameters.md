---
title: "CA1021: не используйте параметры out | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-devops-test"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "CA1021"
  - "AvoidOutParameters"
helpviewer_keywords: 
  - "AvoidOutParameters"
  - "CA1021"
ms.assetid: 970f2304-842c-4fb7-9734-f3871da8d479
caps.latest.revision: 19
caps.handback.revision: 19
author: "stevehoag"
ms.author: "shoag"
manager: "wpickett"
---
# CA1021: не используйте параметры out
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

|||  
|-|-|  
|TypeName|AvoidOutParameters|  
|CheckId|CA1021|  
|Категория|Microsoft.Design|  
|Критическое изменение|Критическое изменение|  
  
## Причина  
 Открытый или защищенный метод открытого типа имеет выходной \(`out`\) параметр.  
  
## Описание правила  
 Чтобы реализовать передачу типов по ссылке \(с помощью ключевого слова `out` или `ref`\), от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение управлять методами с несколькими возвращаемыми значениями.  Кроме того, далеко не каждый понимает разницу между параметрами `out` и `ref`.  
  
 Если ссылочный тип передается "по ссылке", метод предполагает использовать параметр для возвращения другого экземпляра объекта.  Передачу ссылочного типа по ссылке также называют использованием двойного указателя, указателя на указатель или двойного косвенного обращения.  В соответствии с соглашением о вызовах, в котором по умолчанию используется передача "по значению", параметр, принимающий ссылочный тип, уже получает указатель на объект.  Указатель \(а не объект, на который он указывает\) передается по значению.  Передача по значению означает, что метод не может изменить указатель таким образом, чтобы он указывал на новый экземпляр ссылочного типа.  Однако метод может изменить содержимое объекта, на который указывает указатель.  Для большинства приложений этого достаточно и обеспечивает желаемое поведение.  
  
 Если метод должен возвращать другой экземпляр, следует использовать возвращаемое значение метода.  Для получения сведений о методах, которые обрабатывают строки и возвращают новый экземпляр строки, см. в описании класса <xref:System.String?displayProperty=fullName>.  При использовании данной модели вызывающему объекту необходимо решить, следует ли сохранять исходный объект.  
  
 Конечно, возвращаемые значения всем знакомы и повсеместно используются, однако для правильного применения параметров `out` и `ref` требуется средний уровень навыков проектирования и кодирования.  Архитекторам, разрабатывающим библиотеки для широкого использования, не следует ожидать, что пользователи являются профессионалами в использовании параметров `out` и `ref`.  
  
## Устранение нарушений  
 Для устранения нарушения данного правила, вызванного типом значения, необходимо, чтобы метод возвращал объект в качестве своего возвращаемого значения.  Если метод должен возвращать несколько значений, измените его таким образом, чтобы он возвращал единственный экземпляр объекта, содержащего значения.  
  
 Для устранения нарушения данного правила, вызванного ссылочным типом, следует убедиться, что действительно требуется возвращать новый экземпляр ссылки.  Если такое поведения является необходимым, то для этого следует использовать возвращаемое значение метода.  
  
## Отключение предупреждений  
 Отключение предупреждений о нарушении этого правила является безопасным.  Однако подобная структура кода может приводить к проблемам удобства использования.  
  
## Пример  
 В следующей библиотеке показаны две реализации класса, который создает отклики на ввод пользователя.  Первая реализация \(`BadRefAndOut`\) вынуждает пользователя библиотеки управлять тремя возвращаемыми значениями.  Во второй реализации \(`RedesignedRefAndOut`\) работа пользователя упрощается за счет возвращения класса\-контейнера \(`ReplyData`\), который управляет данными как единым блоком.  
  
 [!code-cs[FxCop.Design.NoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_1.cs)]  
  
## Пример  
 В следующем приложении демонстрируется работа пользователя.  Вызов переработанной библиотеки \(метода `UseTheSimplifiedClass`\) более понятен, и сведениями, возвращаемыми данным методом, легче управлять.  Выходные данные, возвращаемые обоими методами, идентичны.  
  
 [!code-cs[FxCop.Design.TestNoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_2.cs)]  
  
## Пример  
 В следующем примере библиотеки демонстрируется использование параметров `ref` для ссылочных типов. Здесь также показан оптимальный способ реализации данной функциональной возможности.  
  
 [!code-cs[FxCop.Design.RefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_3.cs)]  
  
## Пример  
 В следующем приложении для демонстрации поведения библиотеки вызывается каждый ее метод.  
  
 [!code-cs[FxCop.Design.TestRefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_4.cs)]  
  
 В результате выполнения примера получается следующий результат:  
  
  **Изменение указателя \- передается по значению:**  
**12345**  
**12345**  
**Изменение указателя \- передается по ссылке:**  
**12345**  
**12345 ABCDE**  
**Передача возвратом значения:**  
**12345 ABCDE**   
## Методы, использующие шаблон Try  
  
### Описание  
 Использование методов, которые реализуют шаблон **Try\<Something\>**, например <xref:System.Int32.TryParse%2A?displayProperty=fullName>, не приводит к нарушению данного правила.  В следующем примере показана структура \(тип значения\), которая реализует метод <xref:System.Int32.TryParse%2A?displayProperty=fullName>.  
  
### Код  
 [!CODE [FxCop.Design.TryPattern#1](../CodeSnippet/VS_Snippets_CodeAnalysis/FxCop.Design.TryPattern#1)]  
  
## Связанные правила  
 [CA1045: не передавайте типы по ссылке](../code-quality/ca1045-do-not-pass-types-by-reference.md)