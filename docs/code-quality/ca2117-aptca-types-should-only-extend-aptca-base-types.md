---
title: "CA2117: APTCA-типы должны расширять только базовые APTCA-типы | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-code-analysis
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- CA2117
- AptcaTypesShouldOnlyExtendAptcaBaseTypes
helpviewer_keywords:
- AptcaTypesShouldOnlyExtendAptcaBaseTypes
- CA2117
ms.assetid: c505b586-2f1e-47cb-98ee-a5afcbeda70f
caps.latest.revision: "16"
author: gewarren
ms.author: gewarren
manager: ghogen
ms.workload: multiple
ms.openlocfilehash: be208c156e8710b6aa6b2821a5a85131f3c2e4b2
ms.sourcegitcommit: 32f1a690fc445f9586d53698fc82c7debd784eeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="ca2117-aptca-types-should-only-extend-aptca-base-types"></a>CA2117: APTCA-типы должны расширять только базовые APTCA-типы
|||  
|-|-|  
|TypeName|AptcaTypesShouldOnlyExtendAptcaBaseTypes|  
|CheckId|CA2117|  
|Категория|Microsoft.Security|  
|Критическое изменение|Критическое|  
  
## <a name="cause"></a>Причина  
 Открытый или защищенный тип в сборке с <xref:System.Security.AllowPartiallyTrustedCallersAttribute?displayProperty=fullName> атрибут наследует от типа, объявленного в сборку, которая не имеет атрибута.  
  
## <a name="rule-description"></a>Описание правила  
 По умолчанию открытые или защищенные типы в сборках со строгими именами неявно защищены <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> с полным доверием. Сборки со строгими именами, имеющие <xref:System.Security.AllowPartiallyTrustedCallersAttribute> такая защита не имеют атрибута (APTCA). Атрибут отменяет требование наследования. Это позволяет предоставлять типы, объявленные в сборке, наследуемые типами, которые не имеют полного доверия.  
  
 Если в полностью доверенной сборке присутствует атрибут APTCA и тип в сборке наследует от типа, который не разрешены частично доверенные вызовы, возможные уязвимости безопасности. Если два типа `T1` и `T2` удовлетворять следующим условиям, злоумышленники могут использовать тип `T1` для обхода неявного полное требование наследования доверия, защищающий `T2`:  
  
-   `T1`открытый тип, объявленный в полностью доверенной сборке, помеченной атрибутом APTCA.  
  
-   `T1`наследуется от типа `T2` за пределами его сборки.  
  
-   `T2`его сборка не имеет атрибута APTCA и, таким образом, не должно быть наследуемым типов в частично доверенных сборок.  
  
 Частично доверенный тип `X` может наследовать от `T1`, который предоставляет доступ к унаследованных членов, объявленных в `T2`. Поскольку `T2` не имеет атрибута APTCA, его немедленно производного типа (`T1`) должны удовлетворять требования наследования для полного доверия; `T1` имеет полное доверие и проходит эту проверку. Угроза безопасности возникает из-за `X` не участвует в проверке требования наследования, которая защищает `T2` из ненадежных создания подкласса. По этой причине типы с атрибутом APTCA не должны расширять типы, у которых нет атрибута.  
  
 Другая проблема безопасности и может быть более распространенными один это производного типа (`T1`) можно до появления ошибки предоставить защищенные члены типа, требующего полного доверия (`T2`). В этом случае ненадежных вызывающих объектов обеспечивает доступ к сведениям, который должен быть доступен только для типов с полным доверием.  
  
## <a name="how-to-fix-violations"></a>Устранение нарушений  
 Если тип, о которых сообщили нарушение находится в сборке, которая не требует атрибутом APTCA, удалите его.  
  
 Если требуется атрибут APTCA, добавьте к типу требование наследования с полным доверием. Это обеспечит защиту от наследования типов без доверия.  
  
 Это возможно устранить нарушение, добавив атрибут APTCA сборки базовых типов, о которых сообщили нарушение. Не делайте этого подобные тщательного изучения безопасности всего кода в сборках и весь код, который зависит от сборки.  
  
## <a name="when-to-suppress-warnings"></a>Отключение предупреждений  
 Чтобы отключить предупреждение из этого правила без последствий, необходимо убедиться, что защищенные члены, предоставляемые типом прямо или косвенно запретить ненадежных вызывающих объектов на доступ к конфиденциальной информации, операции или ресурсы, которые могут использоваться в злонамеренных целях.  
  
## <a name="example"></a>Пример  
 В следующем примере две сборки и тестовое приложение для демонстрации уязвимости, обнаруживаемый этим правилом. Первая сборка не имеет атрибута APTCA и не должен быть наследуемым частично доверенные типы (представленного `T2` в описании выше).  
  
 [!code-csharp[FxCop.Security.NoAptcaInherit#1](../code-quality/codesnippet/CSharp/ca2117-aptca-types-should-only-extend-aptca-base-types_1.cs)]  
  
## <a name="example"></a>Пример  
 Вторая сборка, представленная `T1` в описании выше является полностью доверенной и позволяет частично доверенным вызывающим объектам.  
  
 [!code-csharp[FxCop.Security.YesAptcaInherit#1](../code-quality/codesnippet/CSharp/ca2117-aptca-types-should-only-extend-aptca-base-types_2.cs)]  
  
## <a name="example"></a>Пример  
 Тип теста, представленного `X` в описании выше находится в сборке с частичным доверием.  
  
 [!code-csharp[FxCop.Security.TestAptcaInherit#1](../code-quality/codesnippet/CSharp/ca2117-aptca-types-should-only-extend-aptca-base-types_3.cs)]  
  
 В этом примере формируются следующие данные:  
  
 **Соответствует на нехорошее glen 2/22/2003 12:00:00 AM!**  
**Солнечный Луг из теста:**  
**Соответствует на солнечный Луг 2/22/2003 12:00:00 AM!**   
## <a name="related-rules"></a>Связанные правила  
 [CA2116: методы APTCA должны вызывать только методы APTCA](../code-quality/ca2116-aptca-methods-should-only-call-aptca-methods.md)  
  
## <a name="see-also"></a>См. также  
 [Правила написания безопасного кода](/dotnet/standard/security/secure-coding-guidelines)   
 [Использование библиотек из не вполне надежного кода](/dotnet/framework/misc/using-libraries-from-partially-trusted-code)   
