---
title: "CA1045: не передавайте типы по ссылке | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-devops-test"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "CA1045"
  - "DoNotPassTypesByReference"
helpviewer_keywords: 
  - "CA1045"
  - "DoNotPassTypesByReference"
ms.assetid: bcc3900a-e092-4bb8-896f-cb83f6289968
caps.latest.revision: 18
caps.handback.revision: 18
author: "stevehoag"
ms.author: "shoag"
manager: "wpickett"
---
# CA1045: не передавайте типы по ссылке
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

|||  
|-|-|  
|TypeName|DoNotPassTypesByReference|  
|CheckId|CA1045|  
|Категория|Microsoft.Design|  
|Критическое изменение|Критическое изменение|  
  
## Причина  
 Открытый или защищенный метод открытого типа имеет параметр `ref`, принимающий тип\-примитив, ссылочный тип или тип значения, который не является встроенным типом.  
  
## Описание правила  
 Для реализации передачи типов по ссылке \(с помощью ключевого слова `out` или `ref`\) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями.  Кроме того, далеко не каждый понимает разницу между параметрами `out` и `ref`.  
  
 Если ссылочный тип передается "по ссылке", метод предполагает использовать параметр для возвращения другого экземпляра объекта. \(Передачу ссылочного типа по ссылке также называют использованием двойного указателя, указателя на указатель или двойного косвенного обращения.\) В соответствии с соглашением о вызовах, в котором по умолчанию используется передача "по значению", параметр, принимающий ссылочный тип, уже получает указатель на объект.  Указатель \(а не объект, на который он указывает\) передается по значению.  Передача по значению означает, что метод не может изменить указатель таким образом, чтобы он указывал на новый экземпляр ссылочного типа, но может изменить содержимое объекта, на который указывает указатель.  Для большинства приложений этого достаточно и обеспечивает желаемое поведение.  
  
 Если метод должен возвращать другой экземпляр, следует использовать возвращаемое значение метода.  Для получения сведений о методах, которые обрабатывают строки и возвращают новый экземпляр строки, см. в описании класса <xref:System.String?displayProperty=fullName>.  При использовании данной модели решение о том, следует ли сохранять исходный объект, принимает вызывающий объект.  
  
 Конечно, возвращаемые значения всем знакомы и повсеместно используются, однако для правильного применения параметров `out` и `ref` требуется средний уровень навыков проектирования и кодирования.  Архитекторам, разрабатывающим библиотеки для широкого использования, не следует ожидать, что пользователи являются профессионалами в использовании параметров `out` и `ref`.  
  
> [!NOTE]
>  При работе с параметрами, являющимися большими структурами, дополнительные ресурсы, необходимые для копирования этих структур, могут повлиять на производительность при передаче по значению.  В таких случаях следует рассмотреть возможность использования параметров `ref` или `out`.  
  
## Устранение нарушений  
 Для устранения нарушения данного правила, вызванного типом значения, необходимо, чтобы метод возвращал объект в качестве своего возвращаемого значения.  Если метод должен возвращать несколько значений, измените его таким образом, чтобы он возвращал единственный экземпляр объекта, содержащего значения.  
  
 Для устранения нарушения данного правила, вызванного ссылочным типом, следует убедиться, что действительно необходимо возвращать новый экземпляр ссылки.  Если такое поведения является необходимым, то для этого следует использовать возвращаемое значение метода.  
  
## Отключение предупреждений  
 Отключение предупреждений о нарушении этого правила является безопасным, однако подобная структура кода может приводить к проблемам удобства использования.  
  
## Пример  
 В следующей библиотеке показаны две реализации класса, который создает отклики на ввод пользователя.  Первая реализация \(`BadRefAndOut`\) вынуждает пользователя библиотеки управлять тремя возвращаемыми значениями.  Во второй реализации \(`RedesignedRefAndOut`\) работа пользователя упрощается за счет возвращения класса\-контейнера \(`ReplyData`\), который управляет данными как единым блоком.  
  
 [!code-cs[FxCop.Design.NoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_1.cs)]  
  
## Пример  
 В следующем приложении демонстрируется работа пользователя.  Вызов переработанной библиотеки \(метода `UseTheSimplifiedClass`\) более понятен, и сведениями, возвращаемыми данным методом, легче управлять.  Выходные данные, возвращаемые обоими методами, идентичны.  
  
 [!code-cs[FxCop.Design.TestNoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_2.cs)]  
  
## Пример  
 В следующем примере библиотеки демонстрируется использование параметров `ref` для ссылочных типов. Здесь также показан оптимальный способ реализации данной функциональной возможности.  
  
 [!code-cs[FxCop.Design.RefByRefNo#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_3.cs)]  
  
## Пример  
 В следующем приложении для демонстрации поведения библиотеки вызывается каждый ее метод.  
  
 [!code-cs[FxCop.Design.TestRefByRefNo#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_4.cs)]  
  
 В результате выполнения примера получается следующий результат:  
  
  **Изменение указателя \- передается по значению:**  
**12345**  
**12345**  
**Изменение указателя \- передается по ссылке:**  
**12345**  
**12345 ABCDE**  
**Передача возвратом значения:**  
**12345 ABCDE**   
## Связанные правила  
 [CA1021: не используйте параметры out](../code-quality/ca1021-avoid-out-parameters.md)