---
title: 'CA1045: Не передавайте типы по ссылке | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- CA1045
- DoNotPassTypesByReference
helpviewer_keywords:
- CA1045
- DoNotPassTypesByReference
ms.assetid: bcc3900a-e092-4bb8-896f-cb83f6289968
author: gewarren
ms.author: gewarren
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 6640942827834ff1eafeecc84e1256ce3589443b
ms.sourcegitcommit: 6a9d5bd75e50947659fd6c837111a6a547884e2a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="ca1045-do-not-pass-types-by-reference"></a>CA1045: не передавайте типы по ссылке
|||  
|-|-|  
|TypeName|DoNotPassTypesByReference|  
|CheckId|CA1045|  
|Категория|Microsoft.Design|  
|Критическое изменение|Критическое|  
  
## <a name="cause"></a>Причина  
 Открытый или защищенный метод в открытом типе имеет `ref` параметр, принимающий тип-примитив, ссылочный тип или тип значения не является одним из встроенных типов.  
  
## <a name="rule-description"></a>Описание правила  
 Для реализации передачи типов по ссылке (с помощью `out` или `ref`) требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Кроме того, разница между `out` и `ref` параметры далеко не все понимают.  
  
 Если ссылочный тип передается «по ссылке», метод предполагает использовать параметр для возвращения другого экземпляра объекта. (Передача ссылочного типа по ссылке также известен как с помощью двойного указателя, указателя на указатель или двойного косвенного обращения.) По умолчанию, соглашение о вызовах, который используется передача «по значению», параметр, принимающий ссылочный тип, уже получает указатель на объект. Указатель, а не объект, на который он указывает, передается по значению. Передача по значению, означает, что метод не может изменить указатель, чтобы он указывал на новый экземпляр ссылки на тип, но можно изменить содержимое объекта, на который он указывает. Для большинства приложений достаточно и обеспечивает желаемое поведение.  
  
 Если метод должен возвращать другой экземпляр, используйте возвращаемое значение метода для выполнения этой задачи. В разделе <xref:System.String?displayProperty=fullName> класс для различных методов, которые обрабатывают строки и возвращают новый экземпляр строки. С помощью этой модели, она останется вызывающей стороне, чтобы решить, сохраняются ли исходный объект.  
  
 Несмотря на то, что возвращаемые значения всем знакомы и повсеместно используются устойчивого приложения `out` и `ref` параметры требуются промежуточные проектирование и кодирование навыки. Архитекторам библиотеки для широкого использования, не следует ожидать пользователям разрабатывающим `out` или `ref` параметров.  
  
> [!NOTE]
>  При работе с параметрами, которые являются больших структур, дополнительные ресурсы, необходимые для копирования этих структур может привести к влияние на производительность при передаче по значению. В этих случаях можно использовать `ref` или `out` параметров.  
  
## <a name="how-to-fix-violations"></a>Устранение нарушений  
 Чтобы устранить нарушение данного правила, связанную с типом значения, имеют метод возвращал объект в качестве возвращаемого значения. Если метод должен возвращать несколько значений, измените его возвращает один экземпляр объекта, содержащего значения.  
  
 Чтобы устранить нарушение данного правила, причиной является ссылочным типом, убедитесь, что желаемое поведение должно возвращать новый экземпляр ссылки. Если это так, метод следует использовать ее возвращаемое значение для этого.  
  
## <a name="when-to-suppress-warnings"></a>Отключение предупреждений  
 Можно безопасно подавить предупреждение из этого правила; Однако такой подход может привести к проблемах.  
  
## <a name="example"></a>Пример  
 В следующей библиотеке показаны две реализации класса, который приводит к возникновению ошибки ответов на отзыв пользователя. Первая реализация (`BadRefAndOut`) вынуждает пользователя библиотеки управлять тремя возвращаемыми значениями. Во второй реализации (`RedesignedRefAndOut`) упрощает взаимодействие с пользователем, возвращают экземпляр класса контейнера (`ReplyData`), управляющий данных как единое целое.  
  
 [!code-csharp[FxCop.Design.NoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_1.cs)]  
  
## <a name="example"></a>Пример  
 В следующем приложении демонстрируется работы пользователя. Вызов модернизированный библиотеки (`UseTheSimplifiedClass` метод) имеет более простой и данные, возвращенные методом легко управлять. Выходные данные из двух методов аналогична.  
  
 [!code-csharp[FxCop.Design.TestNoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_2.cs)]  
  
## <a name="example"></a>Пример  
 В следующем примере библиотеки показано, как `ref` используются параметры для ссылочных типов и показывает более эффективный способ реализации этой функции.  
  
 [!code-csharp[FxCop.Design.RefByRefNo#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_3.cs)]  
  
## <a name="example"></a>Пример  
 Следующее приложение вызывает каждый метод в библиотеке с целью демонстрации поведения.  
  
 [!code-csharp[FxCop.Design.TestRefByRefNo#1](../code-quality/codesnippet/CSharp/ca1045-do-not-pass-types-by-reference_4.cs)]  
  
 В этом примере формируются следующие данные:  
  
 **Изменение указателя — по значению:**  
**12345**  
**12345**  
**Изменение указателя - передается по ссылке:**  
**12345**  
**12345 ABCDE**  
**Передача по возвращаемое значение:**  
**12345 ABCDE**   
## <a name="related-rules"></a>Связанные правила  
 [CA1021: не используйте параметры out](../code-quality/ca1021-avoid-out-parameters.md)