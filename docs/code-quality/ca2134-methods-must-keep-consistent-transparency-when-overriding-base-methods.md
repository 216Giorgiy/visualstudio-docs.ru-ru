---
title: "CA2134: методы должны сохранять согласованную прозрачность при переопределении базовых методов | Microsoft Docs"
ms.custom: ""
ms.date: "12/14/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-devops-test"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "CA2134"
ms.assetid: 3b17e487-0326-442e-90e1-dc0ba9cdd3f2
caps.latest.revision: 9
caps.handback.revision: 9
author: "stevehoag"
ms.author: "shoag"
manager: "wpickett"
---
# CA2134: методы должны сохранять согласованную прозрачность при переопределении базовых методов
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

|||  
|-|-|  
|TypeName|MethodsMustOverrideWithConsistentTransparency|  
|CheckId|CA2134|  
|Категория|Microsoft.Security|  
|Критическое изменение|Критическое изменение|  
  
## Причина  
 Это правило срабатывает, если метод, отмеченный атрибутом <xref:System.Security.SecurityCriticalAttribute>, переопределяет метод, который является прозрачным или отмечен атрибутом <xref:System.Security.SecuritySafeCriticalAttribute>.  Это правило также срабатывает, если прозрачный метод или метод, отмеченный атрибутом <xref:System.Security.SecuritySafeCriticalAttribute>, переопределяет метод, отмеченный атрибутом <xref:System.Security.SecurityCriticalAttribute>.  
  
 Это правило применяется при переопределении виртуального метода или реализации интерфейса.  
  
## Описание правила  
 Это правило срабатывает при попытках изменить уровень доступности метода вверх по цепочке наследования.  Например, если виртуальный метод в базовом классе является прозрачным или критичным в плане безопасности, то производный класс должен переопределять его с помощью прозрачного или критичного в плане безопасности метода.  И наоборот, если виртуальный метод является критически важным для безопасности, производный класс должен переопределить его методом критически важным для безопасности.  Это же правило применяется для реализации методов интерфейса.  
  
 Правила прозрачности применяются, если код получен в результате JIT\-компиляции, а не во время выполнения, поэтому в расчете прозрачности нет сведений о динамических типах.  Таким образом, должна быть возможность определить результат расчета прозрачности исключительно из статических типов, JIT\-компиляция которых выполняется, независимо от динамического типа.  
  
## Устранение нарушений  
 Чтобы устранить нарушение данного правила, измените прозрачность метода, который переопределяет виртуальный метод или реализует интерфейс в соответствии с прозрачностью виртуального метода или метода интерфейса.  
  
## Отключение предупреждений  
 Не следует отключать вывод предупреждений для этого правила.  Нарушения этого правила приведут к исключению <xref:System.TypeLoadException> среды выполнения для сборок, использующих прозрачность уровня 2.  
  
## Примеры  
  
### Код  
 [!CODE [FxCop.Security.CA2134.MethodsMustOverrideWithConsistentTransparency#1](../CodeSnippet/VS_Snippets_CodeAnalysis/fxcop.security.ca2134.methodsmustoverridewithconsistenttransparency#1)]  
  
## См. также  
 [Security\-Transparent Code, Level 2](../Topic/Security-Transparent%20Code,%20Level%202.md)