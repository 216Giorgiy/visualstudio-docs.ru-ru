---
title: "Предупреждения производительности | Microsoft Docs"
ms.custom: ""
ms.date: "12/15/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-devops-test"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vs.codeanalysis.performancerules"
helpviewer_keywords: 
  - "предупреждения, производительность"
  - "предупреждения производительности"
  - "производительность, предупреждения"
  - "предупреждения при анализе управляемого кода, предупреждения производительности"
ms.assetid: e014ac3a-02e6-46d9-942c-3491dd63782f
caps.latest.revision: 22
caps.handback.revision: 22
author: "stevehoag"
ms.author: "shoag"
manager: "wpickett"
---
# Предупреждения производительности
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

Предупреждения производительности поддерживают библиотеки и приложения, в которых требуется обеспечить высокую производительность.  
  
## В этом подразделе  
  
|Правило|Описание|  
|-------------|--------------|  
|[CA1800: не выполняйте лишних приведений](../code-quality/ca1800-do-not-cast-unnecessarily.md)|Повторяющиеся приведения снижают производительность, особенно если приведения выполняются в компактных операторах итераций.|  
|[CA1801: проверьте неиспользуемые параметры](../Topic/CA1801:%20Review%20unused%20parameters.md)|Сигнатура метода включает параметр, не использующийся в основной части метода.|  
|[CA1802. Используйте литералы там, где возможно](../code-quality/ca1802-use-literals-where-appropriate.md)|Поле объявляется статичным и доступным только для чтения \(Shared и ReadOnly в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]\) и инициализируется со значением, вычисляемым во время компиляции.  Поскольку значение, присвоенное конечному полю, вычисляется во время компиляции, замените объявление полем const \(Const в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]\), чтобы значение вычислялось не во время выполнения, а во время компиляции.|  
|[CA1804: удалите неиспользуемые локальные переменные](../code-quality/ca1804-remove-unused-locals.md)|Неиспользуемые локальные переменные и ненужные присвоения увеличивают размер сборки и снижают производительность.|  
|[CA1806: не игнорируйте результаты метода](../code-quality/ca1806-do-not-ignore-method-results.md)|Создается, но никогда не используется новый объект, либо вызывается метод, который создает и возвращает новую строку, и такая новая строка никогда не используется, либо метод COM или P\/Invoke возвращает HRESULT или код ошибки, который никогда не используется.|  
|[CA1809: избегайте чрезмерного использования локальных переменных](../code-quality/ca1809-avoid-excessive-locals.md)|Обычно для оптимизации производительности рекомендуется хранить значение не в памяти, а в регистре процессора. Это называется регистрацией значения.  Чтобы повысить вероятность регистрации всех локальных переменных, следует ограничить их количество 64.|  
|[CA1810: инициализируйте статические поля ссылочного типа встроенными средствами](../code-quality/ca1810-initialize-reference-type-static-fields-inline.md)|Если в типе объявляется явный статический конструктор, компилятор JIT добавляет проверку в каждый статический метод и конструктор экземпляров этого типа, чтобы убедиться, что статический конструктор уже вызывался ранее.  Проверки статических конструкторов могут привести к снижению производительности.|  
|[CA1811: не используйте невызываемый закрытый код](../code-quality/ca1811-avoid-uncalled-private-code.md)|Закрытый или внутренний член \(член уровня сборки\) не вызывается ни объектами сборки, ни средой CLR, ни делегатом.|  
|[CA1812: не создавайте внутренние классы без экземпляров](../Topic/CA1812:%20Avoid%20uninstantiated%20internal%20classes.md)|Экземпляр типа уровня сборки не создается кодом в сборке.|  
|[CA1813: не допускайте использования распечатанных атрибутов](../code-quality/ca1813-avoid-unsealed-attributes.md)|В библиотеке классов [!INCLUDE[dnprdnshort](../code-quality/includes/dnprdnshort_md.md)] предоставляются методы для извлечения пользовательских атрибутов.  По умолчанию эти методы осуществляют поиск иерархии наследования атрибутов.  Если запечатать атрибут, поиск в иерархии наследования выполняться не будет, в результате чего может повыситься производительность.|  
|[CA1814: используйте ступенчатые массивы вместо многомерных](../code-quality/ca1814-prefer-jagged-arrays-over-multidimensional.md)|Массив массивов — это массив, элементы которого сами являются массивами.  Массивы, которые составляют элементы, могут иметь различные размеры, что позволяет экономить пространство для некоторых наборов данных.|  
|[CA1815: следует переопределять равенства и равенства операторов в типах значений](../Topic/CA1815:%20Override%20equals%20and%20operator%20equals%20on%20value%20types.md)|В унаследованной реализации Equals для типов значений используется библиотека отражения и сравнивается содержимое всех полей.  Отражение является процессом, требующим с точки зрения вычислений больших затрат, и сравнение каждого поля на равенство может быть лишним.  Если предполагается, что пользователи будут сравнивать, сортировать экземпляры или использовать их в качестве ключей хэш\-таблиц, тип значения должен реализовывать Equals.|  
|[CA1816: вызов GC.SuppressFinalize должен осуществляться правильно](../code-quality/ca1816-call-gc-suppressfinalize-correctly.md)|Метод, являющийся реализацией Dispose, не вызывает GC.SuppressFinalize, либо метод, не являющийся реализацией Dispose, вызывает GC.SuppressFinalize, либо метод вызывает GC.SuppressFinalize и передает что\-либо другое \(Me в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]\).|  
|[CA1819: свойства не должны возвращать массивы](../code-quality/ca1819-properties-should-not-return-arrays.md)|Массивы, возвращаемые свойствами, не защищены от записи, даже если свойство доступно только для чтения.  Чтобы защитить массив от изменений, свойство должно возвращать копию массива.  Как правило, пользователи не понимают требований к производительности при вызове такого свойства.|  
|[CA1820: проверьте наличие пустых строк путем проверки длины строки](../code-quality/ca1820-test-for-empty-strings-using-string-length.md)|Сравнивать строки с использованием свойства String.Length или метода String.IsNullOrEmpty значительно быстрее, чем с помощью Equals.|  
|[CA1821: удаляйте пустые методы завершения](../code-quality/ca1821-remove-empty-finalizers.md)|Если возможно, старайтесь не использовать финализаторы, поскольку из\-за отслеживания жизненного срока объектов снижается производительность программы.  Пустой метод завершения создает дополнительную нагрузку на систему, не обеспечивая никаких преимуществ.|  
|[CA1822: помечайте члены как статические](../Topic/CA1822:%20Mark%20members%20as%20static.md)|Члены, не обращающиеся к данным экземпляра и не вызывающие методы экземпляра, можно пометить как статические \(Shared в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]\).  Если пометить методы как статические, компилятор предоставит этим членам невиртуальные места вызова.  Это обеспечивает значительное повышение производительности при работе с кодом, для которого важна высокая производительность системы.|  
|[CA1823: избегайте наличия неиспользованных закрытых полей](../code-quality/ca1823-avoid-unused-private-fields.md)|Обнаружены закрытые поля, доступ к которым, судя по всему, не предоставляется в сборке.|  
|[CA1824: следует помечать сборки атрибутом NeutralResourcesLanguageAttribute](../Topic/CA1824:%20Mark%20assemblies%20with%20NeutralResourcesLanguageAttribute.md)|Атрибут NeutralResourcesLanguage сообщает ResourceManager о языке, используемом для отображения независящих от языка и региональных параметров ресурсов для сборки.  При этом повышается эффективность поиска первого загружаемого ресурса и может сократиться рабочее множество.|