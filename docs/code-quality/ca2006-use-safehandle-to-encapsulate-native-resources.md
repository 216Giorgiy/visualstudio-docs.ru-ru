---
title: "CA2006: Используйте SafeHandle для инкапсуляции машинных ресурсов | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-code-analysis
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- CA2006
- UseSafeHandleToEncapsulateNativeResources
helpviewer_keywords:
- UseSafeHandleToEncapsulateNativeResources
- CA2006
ms.assetid: a71950bd-bcc1-463d-b1f2-5233bc451456
caps.latest.revision: "16"
author: gewarren
ms.author: gewarren
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: d70c453e502dd0a7f4eda2e9247dbc3ec3229ebe
ms.sourcegitcommit: 32f1a690fc445f9586d53698fc82c7debd784eeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="ca2006-use-safehandle-to-encapsulate-native-resources"></a>CA2006: используйте SafeHandle для инкапсуляции машинных ресурсов
|||  
|-|-|  
|TypeName|UseSafeHandleToEncapsulateNativeResources|  
|CheckId|CA2006|  
|Категория|Microsoft.Reliability|  
|Критическое изменение|Не критическое|  
  
## <a name="cause"></a>Причина  
 Управляемый код использует <xref:System.IntPtr> для доступа к неуправляемым ресурсам.  
  
## <a name="rule-description"></a>Описание правила  
 Использование `IntPtr` в управляемом коде может указывать на потенциальную проблему безопасности и надежности. Все случаи использования `IntPtr` необходимо изучить, чтобы определить, является ли использование <xref:System.Runtime.InteropServices.SafeHandle> , или другую подобную технологию его место. Проблемы возникают, если `IntPtr` представляет некоторый неуправляемый ресурс, например памяти, дескриптор файла или сокета, управляемый код будет считаться собственные. Если управляемый код, которому принадлежит ресурс, он должен также освободить неуправляемые ресурсы, связанные с ним, потому, что Невыполнение этого требования может вызвать утечку ресурсов.  
  
 В таких случаях проблем безопасности и надежности также будет существовать, если разрешено многопоточного доступа `IntPtr` и способ освобождения ресурса, представленного `IntPtr` предоставляется. Эти проблемы связаны уничтожение `IntPtr` значение освобождения ресурса, пока одновременное использование ресурса выполняется в другом потоке. Это может привести к конкуренции, где один поток может считывать или записывать данные, связанные с ресурсом неправильный. Например, если в типе хранится дескриптор операционной системы как `IntPtr` и дает пользователям возможность вызова как **закрыть** и любой другой метод, который использует этот дескриптор одновременно и без какой-либо синхронизации, ваш код содержит повторного использования дескриптора проблема.  
  
 Это проблема повторного использования дескриптора может привести к повреждению данных и, зачастую, уязвимость системы безопасности. `SafeHandle`и его одноуровневый класс <xref:System.Runtime.InteropServices.CriticalHandle> предоставляют механизм для инкапсуляции собственный дескриптор для ресурса, чтобы избежать подобных проблем многопоточного. Кроме того, можно использовать `SafeHandle` и его одноуровневый класс `CriticalHandle` для других проблем многопоточности, например, для тщательно управления временем жизни управляемых объектов, которые содержат копию собственный дескриптор через вызовы методов в машинном коде. В этом случае зачастую можно избежать вызовов `GC.KeepAlive`. Издержек на тайском языке производительности при этом при использовании `SafeHandle` и в меньшей степени `CriticalHandle`, часто можно уменьшить путем точной разработки.  
  
## <a name="how-to-fix-violations"></a>Устранение нарушений  
 Преобразовать `IntPtr` использование `SafeHandle` для безопасного управления неуправляемыми ресурсами. В разделе <xref:System.Runtime.InteropServices.SafeHandle> справочном разделе примеры.  
  
## <a name="when-to-suppress-warnings"></a>Отключение предупреждений  
 Не следует подавлять это предупреждение.  
  
## <a name="see-also"></a>См. также  
 <xref:System.IDisposable>