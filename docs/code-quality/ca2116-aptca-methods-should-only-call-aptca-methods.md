---
title: 'CA2116: методы APTCA должны вызывать только методы APTCA'
ms.date: 11/04/2016
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- AptcaMethodsShouldOnlyCallAptcaMethods
- CA2116
helpviewer_keywords:
- AptcaMethodsShouldOnlyCallAptcaMethods
- CA2116
ms.assetid: 8b91637e-891f-4dde-857b-bf8012270ec4
author: gewarren
ms.author: gewarren
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 70affcf0b71e9d0ae7440141f45f5ae0f2c04bf6
ms.sourcegitcommit: e13e61ddea6032a8282abe16131d9e136a927984
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/26/2018
---
# <a name="ca2116-aptca-methods-should-only-call-aptca-methods"></a>CA2116: методы APTCA должны вызывать только методы APTCA
|||
|-|-|
|TypeName|AptcaMethodsShouldOnlyCallAptcaMethods|
|CheckId|CA2116|
|Категория|Microsoft.Security|
|Критическое изменение|Критическое|

## <a name="cause"></a>Причина
 Метод в сборке с <xref:System.Security.AllowPartiallyTrustedCallersAttribute?displayProperty=fullName> атрибута вызывает метод в сборке, которая не имеет атрибута.

## <a name="rule-description"></a>Описание правила
 По умолчанию открытые или защищенные методы в сборках со строгими именами неявно защищены [требования связывания](/dotnet/framework/misc/link-demands) с полным доверием; только полностью доверенные, вызывающих объектов можно получить доступ к сборки со строгим именем. Сборки со строгими именами, имеющие <xref:System.Security.AllowPartiallyTrustedCallersAttribute> такая защита не имеют атрибута (APTCA). Данный атрибут отменяет требование связывания, делая сборки доступными вызывающим объектам, которые не имеют полного доверия, например код, выполняемый из интрасети или Интернета.

 Если в полностью доверенной сборке присутствует атрибут APTCA, и она выполняет код в другой сборке, для которой не разрешены частично доверенные вызовы, возможные уязвимости безопасности. Если два метода `M1` и `M2` удовлетворять следующим условиям, злоумышленники могут использовать метод `M1` Чтобы обойти запрос ссылок неявное полного доверия, который защищает `M2`:

-   `M1` объявляется открытый метод в сборке с полным доверием, помеченной атрибутом APTCA.

-   `M1` вызывает метод `M2` за пределами `M1`в сборке.

-   `M2`его сборка не имеет атрибута APTCA и, таким образом, не должна выполняться пользователем или от имени частично доверенным вызывающим.

 Частично доверенный вызывающий `X` можно вызвать метод `M1`, что вызвало `M1` для вызова `M2`. Поскольку `M2` не имеет атрибута APTCA, его непосредственный вызывающий объект (`M1`) должны удовлетворять запросу компоновки с полным доверием; `M1` имеет полное доверие и проходит эту проверку. Угроза безопасности возникает из-за `X` не участвует в выполнении требования ссылки, который защищает `M2` от ненадежных вызывающих объектов. Таким образом методы с атрибутом APTCA не должны вызывать методы, которые не имеют атрибута.

## <a name="how-to-fix-violations"></a>Устранение нарушений
 Если требуется атрибут APCTA, используйте требование для защиты метода, вызывающего сборку с полным доверием. Точные разрешения, вы запросу будет зависеть от функциональности, предоставляемой методом. Если это возможно, следует защитить метод требование полного доверия, чтобы убедиться, что базовая функциональность не предоставляются частично доверенным вызывающим объектам. Если это невозможно, выберите набор разрешений, защищающий функциональные возможности.

## <a name="when-to-suppress-warnings"></a>Отключение предупреждений
 Чтобы отключить предупреждение из этого правила без последствий, необходимо убедиться, что функциональные возможности, предоставляемой методом прямо или косвенно позволяет вызывающим объектам доступ к конфиденциальной информации, операции или ресурсы, которые могут использоваться в злонамеренных целях.

## <a name="example"></a>Пример
 В следующем примере две сборки и тестовое приложение для демонстрации уязвимости, обнаруживаемый этим правилом. Первая сборка не имеет атрибута APTCA и не должны быть доступны для частично доверенных вызывающих объектов (представленных `M2` в описании выше).

 [!code-csharp[FxCop.Security.NoAptca#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_1.cs)]

## <a name="example"></a>Пример
 Вторая сборка является полностью доверенной и позволяет частично доверенным вызывающим объектам (представленного `M1` в описании выше).

 [!code-csharp[FxCop.Security.YesAptca#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_2.cs)]

## <a name="example"></a>Пример
 Тестовое приложение (представленного `X` в описании выше), имеет частичное доверие.

 [!code-csharp[FxCop.Security.TestAptcaMethods#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_3.cs)]

 В этом примере формируются следующие данные:

 **Не удалось выполнить требование полного доверия: запрос. ** 
 **ClassRequiringFullTrust.DoWork был вызван.**
## <a name="related-rules"></a>Связанные правила
 [CA2117: APTCA-типы должны расширять только базовые APTCA-типы](../code-quality/ca2117-aptca-types-should-only-extend-aptca-base-types.md)

## <a name="see-also"></a>См. также
 [Правила написания безопасного кода](/dotnet/standard/security/secure-coding-guidelines) [использование библиотек из частично доверенного кода](/dotnet/framework/misc/using-libraries-from-partially-trusted-code) [требования связывания](/dotnet/framework/misc/link-demands) [данных и моделирование](/dotnet/framework/data/index)