---
title: C26418 | Документация Майкрософт
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26418
helpviewer_keywords:
- C26418
ms.assetid: d2c84a40-8a5d-4018-92c2-6498cdd9b541
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 915342397bda4684077c6b353fc37252be21019e
ms.sourcegitcommit: 1fc6ee928733e61a1f42782f832ead9f7946d00c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2019
ms.locfileid: "60072596"
---
# <a name="c26418-novalueorconstrefsharedptr"></a>C26418 NO_VALUE_OR_CONST_REF_SHARED_PTR
«Параметр общего указателя не копируется или перемещается. Используйте T * или T &.»

**C++ Core Guidelines**: R.36: Воспользоваться const shared_ptr\<мини-приложения > & параметр для выражения, что он может сохранить счетчик ссылок на объект

Если параметр общего указателя передается по значению или ссылке в постоянный объект, предполагается, что функция будет иметь контроль над временем существования его целевой объект без влияния на вызывающей стороны. Код следует скопировать или переместить параметр общего указателя с другим объектом общим указателем или передать его дальше другой код путем вызова функции, которые принимают общих указателей. Если это не так, то обычный указатель или ссылка может быть нецелесообразно.

## <a name="remarks"></a>Примечания
- Эта проверка распознает std::shared_pointer и определяемые пользователем типы, которые, скорее всего, ведут себя как общих указателей. Для определяемых пользователем общих указателей ожидаются следующие признаки:
- перегруженные разыменования или доступа к членам, операторы, (открытого и удаления);
- конструктор копии или оператор присваивания копии (открытый и удаления);
- открытого деструктора, который не удален и не установленные по умолчанию. Пустые деструкторы, по-прежнему рассматриваются как определяемые пользователем.

## <a name="example"></a>Пример
усложнение ненужные интерфейса

```cpp
template<class T>
std::string to_string(const std::shared_ptr<T> &e) // C26418, also C26415 SMART_PTR_NOT_NEEDED
{
    return !e ? null_string : e->to_string();
}
```

## <a name="example"></a>Пример
усложнение ненужные интерфейс — упрощенное

```cpp
template<class T>
std::string to_string(const T *e)
{
    return !e ? null_string : e->to_string();
}
```
