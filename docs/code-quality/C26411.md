---
title: C26411
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C26411
helpviewer_keywords:
- C26411
ms.assetid: 5134e51e-8b92-4ee7-94c3-022e318a0e24
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: f306dbae03e96db277d3f6057d5ef767b200af5e
ms.sourcegitcommit: e13e61ddea6032a8282abe16131d9e136a927984
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/26/2018
---
# <a name="c26411--noreftouniqueptr"></a>C26411 NO_REF_TO_UNIQUE_PTR
Передача по ссылке уникальный указатель подразумевается, что его ресурсов может быть выпущена или передать внутри целевой функции. Если функция использует его параметр только для доступа к ресурсу, можно безопасно передавать необработанный указатель или ссылка.

## <a name="remarks"></a>Примечания
- Ограничения на сообщение C26410 применимы здесь также.
- Эвристики для обнаружения «выпуск» или «сброс» доступ к уникальный указатель является довольно упрощенного: только мы определим вызовы операторы присваивания и методов с именем «Сброс» (без учета регистра). Очевидно, что это не покрывает всех возможных вариантов интеллектуального указателя изменений (например std::swap или любой специальный метод неконстантной в пользовательских интеллектуального указателя). Ожидается, что это предупреждение будет создавать много ложных срабатываний пользовательских типов, а также в некоторых сценариях, посвященные Стандартная уникальных указателей. Эвристика будут улучшены, как мы реализовали нескольких проверок, основное внимание уделено интеллектуальные указатели.
- Интеллектуальные указатели часто являются шаблонами. Это дает вам интересно ограничения, связанные с тем, что компилятор не должен обрабатывать код шаблона в шаблонах, если он не используется. В некоторых базах минимального объема кода, имеющие очень ограниченное использование интерфейсов интеллектуальных указателей, средство проверки может дать непредвиденные результаты из-за неспособности обеспечить правильно определить семантику типа шаблона (так как некоторые важные методы никогда не могут быть использованы). Для стандартных `unique_pointer` это ограничение, если снизить, распознавая имя типа. Это может быть расширен в будущем для поддержки более известного интеллектуальные указатели.
- Лямбда-выражения с неявное записи по ссылке может привести к неожиданным предупреждения о ссылки на указатели уникальным. В настоящее время все отслеживаемые ссылочным параметрам в лямбда-выражения выводятся независимо от ли они будут заменены или нет. Эвристика здесь необходимо расширить сопоставляются поля лямбда-выражение с параметрами лямбда-выражения. Она будет устранена в следующих версиях (после Visual Studio 2017 г. версия 15,3)

## <a name="example-1-unnecessary-reference"></a>Пример 1: Ненужные ссылки
```cpp
void TraceValid(std::unique_ptr<Slot> &slot)    // C26411
{
    if (!IsDamaged(slot.get()))
        std::cout << *slot.get();
}

void ReleaseValid(std::unique_ptr<Slot> &slot)  // OK
{
    if (!IsDamaged(slot.get()))
        slot.reset(nullptr);
}
```