---
title: C26411
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C26411
helpviewer_keywords:
- C26411
ms.assetid: 5134e51e-8b92-4ee7-94c3-022e318a0e24
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: adae1dfddc8f919b1921c45eb2ae42103e60331e
ms.sourcegitcommit: 6944ceb7193d410a2a913ecee6f40c6e87e8a54b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2018
ms.locfileid: "35674319"
---
# <a name="c26411--noreftouniqueptr"></a>C26411 NO_REF_TO_UNIQUE_PTR
Передача по ссылке уникальный указатель предполагается, что ее ресурсов может быть выпущен или передаваемых внутри целевой функции. Если функция использует ее параметр только для доступа к ресурсу, его можно безопасно передавать необработанный указатель или ссылка.

## <a name="remarks"></a>Примечания
- Ограничения от предупреждений C26410 применимы здесь также.
- Эвристический алгоритм для определения доступа «выпуск» или «сброс» на уникальный указатель является довольно наивный: мы обнаруживает только вызовы операторы присваивания и функции с именем «Сброс» (без учета регистра). Очевидно, что это не охватывает все возможные случаи изменений смарт-указатель (std::swap или любые специальные неконстантной функции в пользовательских смарт-указатель). Предполагается, что это предупреждение будет создавать много ложных срабатываний для пользовательских типов, а также в некоторых сценариях, посвященные стандартный уникальных указателей. Будет улучшена эвристика, как мы реализуем больше проверок, посвященные интеллектуальные указатели.
- Интеллектуальные указатели часто являются шаблонами. Это дает интересные ограничения, связанные с тот факт, что компилятор не требуется обрабатывать код шаблона в шаблонах, если он не используется. В некоторых базах минимальный код, которые имеют очень ограниченное использование интерфейсов смарт-указатель, средство проверки могут давать непредвиденные результаты из-за неспособности правильно определить семантику типа шаблона (так как некоторые важные функции никогда не может использоваться). Для стандартной `unique_pointer` это ограничение, если устранен, распознавая имя типа. Они могут быть добавлены в будущем для охвата более известны интеллектуальные указатели.
- Лямбда-выражения с помощью неявного записи по ссылке может привести к неожиданным предупреждения о ссылки на уникальный указатели. В настоящее время все параметры записанный эталонный в лямбда-выражений выводятся независимо от того ли они будут сброшены, или нет. Эвристика здесь необходимо расширить до сопоставлять поля лямбда-выражения с параметрами лямбда-выражения. Это будет исправлено в следующих выпусках (после Visual Studio 2017 версии 15.3)

## <a name="example-1-unnecessary-reference"></a>Пример 1: Ненужные ссылки
```cpp
void TraceValid(std::unique_ptr<Slot> &slot)    // C26411
{
    if (!IsDamaged(slot.get()))
        std::cout << *slot.get();
}

void ReleaseValid(std::unique_ptr<Slot> &slot)  // OK
{
    if (!IsDamaged(slot.get()))
        slot.reset(nullptr);
}
```