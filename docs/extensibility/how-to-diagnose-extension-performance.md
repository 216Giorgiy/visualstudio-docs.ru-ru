---
title: "Как: диагностики производительности расширение | Документы Microsoft"
ms.custom: 
ms.date: 11/08/2016
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-sdk
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 46b0a1e3-7e69-47c9-9d8d-a1815d6c3896
caps.latest.revision: "1"
author: BertanAygun
ms.author: bertaygu
manager: ghogen
ms.workload: bertaygu
ms.openlocfilehash: 1d1034cce8b2fced5af48a0a4bfa8620b56994e4
ms.sourcegitcommit: 32f1a690fc445f9586d53698fc82c7debd784eeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="measuring-extension-impact-in-startup"></a>Оценка влияния расширения при запуске

## <a name="focus-on-extension-performance-in-visual-studio-2017"></a>Акцент на производительность расширения в Visual Studio 2017 г.

На основе отзывов, одна из областей фокуса для выпуска Visual Studio 2017 г. был нагрузки производительность при запуске и решения. Пока команде платформы Visual Studio, мы работаем над повышением производительности нагрузки запуска и решения, в общем, нашей телеметрии предлагает установленных расширений также может иметь существенное влияние на этих сценариев.

Чтобы помочь пользователям понять влияние этой конфигурации, добавлена новая функция в Visual Studio для уведомления пользователей о медленно расширения. Когда Visual Studio обнаруживает новое расширение, замедляя загрузки решения или запуска, пользователи будут видеть уведомления в Интегрированной среде разработки указать им новое диалоговое окно «Управление производительности Visual Studio». Это диалоговое окно также всегда может быть доступно в меню "Справка" для просмотра ранее обнаруженных расширения.

![Управление производительности Visual Studio](media/manage-performance.png)

Этот документ предназначен для помощи разработчикам расширения, описывая вычисление влияние расширения и как их можно проанализировать локально для проверки, если расширение может отображаться как расширения, влияющие на производительность.

## <a name="how-extensions-can-impact-startup"></a>Влияние запуска расширений

Одним из наиболее распространенных способов для расширения влиять на производительность при запуске —, выбрав для автоматической загрузки на одном из контекстах известных запуска пользовательского интерфейса, например NoSolutionExists или ShellInitialized. Эти контексты пользовательского интерфейса получить активируется во время запуска и будут загружаться и инициализировать в этот момент все пакеты, имеющие атрибут «ProvideAutoLoad» в своих определениях с их контекстов.

Когда мы измеряем его воздействие на расширение, мы в первую очередь сосредоточиться на время, затраченное модулями, которые выбраны для автоматической загрузки в контекстах выше. Измеряется время будет включить, но не ограничиваться:

* Загрузка сборки расширений для синхронного пакетов
* Время, затраченное в конструкторе класса пакета для синхронного пакетов
* Время, затраченное на метод инициализации (или SetSite) пакета для синхронного пакетов
* Для асинхронных пакетов выше операций запуска в фоновом потоке и таким образом, исключаются из наблюдения
* Время, затраченное на асинхронной работы, запланированной во время инициализации пакета для запуска на основной поток
* Время, затраченное на обработчики событий, специально оболочки инициализировать контекст активации или изменения состояния зомби оболочки
* Начиная с Visual Studio 2017 г. обновление 3, мы также позволяет запускать наблюдения за время, затраченное на простоя вызовов до инициализации оболочки. Длительных операций в состояние бездействия обработчики также вызвать отвечать на запросы интегрированной среды разработки входят и воспринимаемое время запуска пользователем.

Мы добавили несколько компонентов, начиная с Visual Studio 2015, чтобы помочь с исключает необходимость пакетов для автоматической загрузки, отложить их нагрузка с более конкретными вариантами, где пользователям было бы более определенные с помощью расширения или уменьшить влияние расширения при загрузке автоматически.

Дополнительные сведения об этих функциях можно найти в следующих документах:

[Контексты пользовательского интерфейса, основанного на правилах](how-to-use-rule-based-ui-context-for-visual-studio-extensions.md): более подробная engine основывается на правилах, построенная на основе контексты пользовательского интерфейса позволяют создавать настраиваемые контексты на основе типов проектов, конфигурациях и возможности. Эти настраиваемые контексты может использоваться для загрузки пакета во время более конкретных сценариев, таких как наличие проект с конкретной функции вместо запуска; или разрешить [команда видимости должны быть привязаны к пользовательский контекст](visibilityconstraints-element.md) на основе возможности проекта или другие доступные условия, тем самым устраняя необходимость загрузки пакета, чтобы зарегистрировать обработчик запроса состояния команды.

[Поддержка асинхронного пакета](how-to-use-asyncpackage-to-load-vspackages-in-the-background.md): новый базовый класс AsyncPackage в Visual Studio 2015 обеспечивает быть загружена в фоновом режиме асинхронно, если был запрошен загрузку пакета с помощью атрибута нагрузки auto или запроса на асинхронную службу пакетов Visual Studio . Это фоновую загрузку позволяет IDE быстро реагировать во время инициализации расширения в фоновом режиме и критических сценариев, таких как решение и запуска нагрузки не влияет.

[Асинхронные служб](how-to-provide-an-asynchronous-visual-studio-service.md): С поддержкой асинхронных пакета, мы добавили поддержку асинхронных запросов службы и возможность регистрировать асинхронной службы. Более того, мы работаем над преобразование основные службы Visual Studio для поддержки асинхронного запроса, что большая часть работы в запросе async происходит в фоновых потоках. Модели SComponentModel (Visual Studio MEF host) является одним из основных служб, которые теперь поддерживает асинхронный запрос, чтобы разрешить расширения для поддержки асинхронной загрузке полностью.

## <a name="reducing-impact-of-auto-loaded-extensions"></a>Уменьшение влияния автоматически загрузить расширения

Если пакет по-прежнему должен быть автоматически при загрузке системы, важно свести к минимуму работу во время инициализации пакет для уменьшения вероятности запуска, влияющие на расширения.

Ниже приведены некоторые примеры, которые могут привести к инициализации пакета должно быть дорогостоящим.

### <a name="use-of-synchronous-package-load-instead-of-asynchronous-package-load"></a>Использование загрузку пакета синхронной вместо загрузку асинхронного пакета

Так как синхронный пакетов загружаются на основной поток по умолчанию, мы рекомендуем владельцы расширение автоматически загрузить пакеты используйте асинхронные пакета базовый класс как было сказано выше. Изменение автоматического загруженный пакет для обеспечения асинхронной загрузки будет также упростить устранение других проблем ниже.

### <a name="synchronous-filenetwork-io-requests"></a>Запросы ввода-ВЫВОДА для синхронного файла или сеть

В идеале любой синхронный запрос ввода-ВЫВОДА файла или сети следует избегать в основном потоке, а их влияние зависит от состояния компьютера можно заблокировать на длительное время, в некоторых случаях.

С помощью пакета асинхронной загрузки и асинхронные API ввода-ВЫВОДА следует убедитесь, что пакет инициализации не блокирует основной поток в таких случаях и пользователи получают возможность взаимодействовать с Visual Studio, а запросы ввода-вывода будет выполняться в фоновом режиме.

### <a name="early-initialization-of-services-components"></a>Раннее инициализации службы, компоненты

Один из распространенных шаблонов во время инициализации пакета — для инициализации службы используются или предоставляемые этого пакета в методе конструктора или инициализировать пакет. Хотя это гарантирует, что службы готовы для использования, также можно добавить ненужные затраты на пакет загрузки, если эти службы не применяются немедленно. Вместо этого такие службы должен быть инициализирован по запросу, чтобы свести к минимуму работу во время инициализации пакета.

Для глобальной службы, предоставляемые пакета можно использовать AddService методы, которые принимает функцию отложенной инициализации службы только в том случае, когда он запрашивается с помощью компонента. Для служб, используемых в пакете, могут использовать Lazy<T> или AsyncLazy<T> для обеспечения служб инициализировать/запрошены при первом использовании.

## <a name="measuring-impact-of-auto-loaded-extensions-using-activity-log"></a>Оценка влияния автоматически загрузить расширения с использованием журнал действий

Начиная с Visual Studio 2017 г. обновление 3, журнал действий Visual Studio теперь будет содержать записи для пакетов воздействие на производительность во время загрузки, запуска и решения. Для просмотра этих измерений, необходимо запустить Visual Studio с ключом/log и откройте файл ActivityLog.xml.

В журнале активности будет находиться в разделе «Управление производительности Visual Studio» источника операции и будет выглядеть следующим образом:

```Component: 3cd7f5bf-6662-4ff0-ade8-97b5ff12f39c, Inclusive Cost: 2008.9381, Exclusive Cost: 2008.9381, Top Level Inclusive Cost: 2008.9381```

Это значит, этот пакет с GUID «3cd7f5bf-6662-4ff0-ade8-97b5ff12f39c» затраченное 2008 ms при запуске Visual Studio. Обратите внимание, что Visual Studio считает верхнего уровня затрат по основному номеру при вычислении влияние пакета, как это было бы savigs пользователя см. Отключение расширение для этого пакета.

## <a name="measuring-impact-of-auto-loaded-extensions-using-perfview"></a>Оценка влияния автоматически загрузить расширения с использованием PerfView

Во время анализа кода могут помочь вам определить пути кода, которые может замедлить выполнение пакета инициализации, могут также использовать трассировку с помощью приложений, таких как PerfView, чтобы понять влияние загрузку пакета при запуске Visual Studio.

PerfView — это средство широкий трассировки системы, которая поможет вам понять горячего пути в приложении, либо из-за использования ЦП или блокирующих вызовов системы. Ниже приведен краткий пример на анализ образца модуля, с помощью PerfView найти по адресу [центра загрузки Майкрософт](https://www.microsoft.com/en-us/download/details.aspx?id=28567).

**Пример кода:**

Этот пример основан на образце приведенный ниже код, предназначенный для отображения случае некоторые из распространенных причин задержки:

```csharp
protected override void Initialize()
{
    // Initialize a class from another assembly as an example
    MakeVsSlowServiceImpl service = new MakeVsSlowServiceImpl();

    // Costly work in main thread involving file IO
    string systemPath = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
    foreach (string file in Directory.GetFiles(systemPath))
    {
        DateTime creationDate = File.GetCreationTime(file);
    }

    // Costly work after shell is initialized. This callback executes on main thread
    KnownUIContexts.ShellInitializedContext.WhenActivated(() =>
    {
        DoMoreWork();
    });

    // Start async work on background thread
    DoAsyncWork().Forget();
}

private async Task DoAsyncWork()
{
    // Switch to background thread to do expensive work
    await TaskScheduler.Default;
    System.Threading.Thread.Sleep(500);
}

private void DoMoreWork()
{
    // Costly work
    System.Threading.Thread.Sleep(500);
    // Blocking call to an asynchronous work.
    ThreadHelper.JoinableTaskFactory.Run(async () => { await DoAsyncWork(); });
}
```

**Запись трассировки с PerfView:**

После установки среды Visual Studio с расширением установлен, открыв PerfView и открыть сбора диалоговое окно «Получение» меню можно записать трассировку запуска.

![perfview сбор меню](media/perfview-collect-menu.png)

Параметры по умолчанию будет предоставить стеки вызовов для потребление ресурсов ЦП, но так как мы будем рады получить также времени блокировки, также следует включить стеки «Потока времени». Когда будете готовы параметры можно щелкните «Начать сбор» и запустите Visual Studio после начала записи.

Перед остановкой коллекции требуется убедитесь, что Visual Studio полностью инициализирован, главного окна отображается полностью, а также если расширение любой части пользовательского интерфейса, которые автоматически отображать, они доступны. После полной загрузки Visual Studio и расширение инициализируется можно остановить запись анализ трассировки.

**Анализ трассировки с помощью PerfView.**

После завершения записи PerfView автоматически откройте трассировку и разверните параметры.

В целях этого примера мы заинтересованы главным образом в представлении «Время стеки потоков», которое можно найти в группе «расширенный». В этом представлении отображается общее время, затраченное в потоке с помощью метода, включая время ЦП и время блокировки, например операции ввода-ВЫВОДА диска или Ожидание дескрипторов.

 ![стеки потоков времени](media/perfview-thread-time-stacks.png)

 При открытии представления «Время стеки потоков», необходимо выбрать «devenv» процесс запуска анализа.

PerfView содержатся подробные указания по решению для чтения поток время стеки в свой собственный меню "Справка" для более подробного анализа. Для целей этого примера необходимо включить фильтрацию дальнейшей только в том числе стеков с нашего пакеты модуль имя и при запуске потока.

1. Значение «GroupPats» пустой текст для удаления любого группирования, добавляется по умолчанию.
2. Набор «IncPats», включает имя сборки и запуска потока помимо существующий фильтр процесса. В этом случае он должен быть «devenv; При запуске потока; MakeVsSlowExtension».

Теперь представления будут отображаться только издержки, связанные со сборками, касающиеся расширения. В этом представлении любое время, перечисленные в столбце «Inc» (стоимость включительно) при запуске потока связана с фильтрацией расширения и будут влиять на при запуске.

В примере выше некоторые интересные вызов стеков будет следующим:

1. Операции ввода-ВЫВОДА с помощью класса System.IO: хотя включительно затраты на эти кадры могут быть очень дорого в трассировке, они могут потенциальную причину возникновения проблемы, так как файл скорость операций ввода-ВЫВОДА будет зависеть от компьютера.

  ![кадры системы ввода-вывода](media/perfview-system-io-frames.png)

2. Блокирует ожидание других асинхронной работы вызывает: В этом случае инклюзивное время представит времени, основной поток блокируется при завершении асинхронной операции.

  ![блокирующие кадров вызова](media/perfview-blocking-call-frames.png)

Одним из других представлений в трассировку, которая окажется полезной определить влияние будет «Образ загрузки стеки». Можно применять те же фильтры применительно к представлению «Стеки потоков время» и выяснить все сборки, загруженные из-за код, выполняемый автоматически загрузить пакет.

Важно свести к минимуму число загруженных сборок внутри процедуры инициализации пакета как каждую дополнительную сборку для этого потребуется дополнительное дискового ввода-вывода, который может замедлить запуск значительно медленнее машинах.

## <a name="summary"></a>Сводка

Для запуска Visual Studio был области, которые мы постоянно обеспечения обратной связи. Наша цель как уже говорилось выше, — все пользователи могли получить согласованные запуска возникнуть независимо от того, компоненты и расширения, которые они установлены и мы бы хотели работать с владельцами расширения, чтобы помочь нам достижения этой цели. Вышеприведенное руководство могут помочь в понимании влияние расширения во время запуска и либо устраняя необходимость автоматического нагрузки и загружать данные асинхронно, чтобы свести к минимуму влияние на производительность работы пользователей.
