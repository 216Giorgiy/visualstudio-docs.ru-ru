---
title: "Практическое руководство: Диагностика производительности расширение | Документы Microsoft"
ms.custom: 
ms.date: 11/08/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- vs-ide-sdk
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 46b0a1e3-7e69-47c9-9d8d-a1815d6c3896
caps.latest.revision: 1
author: BertanAygun
ms.author: bertaygu
manager: ghogen
translation.priority.mt:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: 5db97d19b1b823388a465bba15d057b30ff0b3ce
ms.openlocfilehash: f1226c9bd42476acc9fb57be0a6df8058174fd4d
ms.lasthandoff: 02/22/2017

---
# <a name="measuring-extension-impact-in-startup"></a>Оценка влияния расширения при запуске

## <a name="focus-on-extension-performance-in-visual-studio-2017"></a>Направлены на повышение производительности расширений в Visual Studio 2017 г.

На основе отзывов, один из области действия для выпуска Visual Studio 2017 г. была производительность нагрузки запуска и решений. Хотя команде платформы Visual Studio, мы усердно работали над повышением производительности нагрузки запуска и решения в целом, наш телеметрии предлагает установленных расширений также может иметь значительное влияние на этих сценариев.

Чтобы помочь пользователям понять влияние этой конфигурации, добавлена новая функция в Visual Studio для уведомления пользователей о медленно расширения. Когда Visual Studio обнаруживает новое расширение, снижения нагрузки решения или запуска, пользователи будут видеть уведомления в Интегрированной среде разработки пункты новое диалоговое окно «Управление производительность Visual Studio». Это диалоговое окно также всегда может быть доступно в меню "Справка" для просмотра ранее обнаруженный расширения.

![Управление производительности Visual Studio](~/extensibility/media/manage-performance.png)

Этот документ призван помочь разработчикам расширений, описывая способ расчета влияние расширения и как их можно проанализировать локально для тестирования, если расширение может отображаться как расширения, влияющие на производительность.

## <a name="how-extensions-can-impact-startup"></a>Влияние загрузки расширения

Одним из наиболее распространенных способов для расширения влияние на производительность при запуске — Выбор автоматически нагрузки на одном из контекстах известных запуска пользовательского интерфейса, например NoSolutionExists или ShellInitialized. Эти контексты пользовательского интерфейса получить активируется во время загрузки и все пакеты, которые включают атрибут «ProvideAutoLoad» в свое определение с тем контекстам, которые будут загружаться и инициализирован в данный момент.

Когда измерять влияние расширение в основном внимание на время, затраченное модулями, которые выбраны для автоматической загрузки в контекстах выше. Измеряется время бы включать, но не ограничиваться:

* Загрузка сборки расширений для синхронной пакетов
* Время, затраченное в конструкторе класса пакета для синхронной пакетов
* Время, затраченное на метод Initialize (или SetSite) пакета для синхронной пакетов
* Для асинхронных пакетов выше операции выполнения в фоновом потоке и таким образом, исключаются из наблюдения
* Время, затраченное на любой асинхронной работы, запланировано во время инициализации пакета для основного потока
* Время, затраченное на обработчики событий, специально оболочки инициализировать контекст активации или изменения состояния зомби оболочки

Мы добавили несколько компонентов, начиная с Visual Studio 2015 для облегчения устранения необходимости пакетов для автоматической загрузки, отложить их загрузки более конкретные случаи, когда пользователи будут более определенные расширения или уменьшить влияние расширения при загрузке автоматически.

Дополнительные сведения об этих функциях можно найти в следующих документах:

[Контексты пользовательского интерфейса, основанного на правилах](how-to-use-rule-based-ui-context-for-visual-studio-extensions.md): широкие правила на основе ядра, построенная на основе контексты пользовательского интерфейса позволяют создавать пользовательские контекстов, на основе типов проектов, версии и возможности. Эти пользовательские контекстов может использоваться для загрузки пакета во время конкретных сценариев, таких как наличие проекта с конкретной функции вместо запуска; или разрешить [команды видимости должны быть привязаны к пользовательского контекста](https://msdn.microsoft.com/en-us/library/bb166512.aspx) на основе возможности проекта или других доступных терминов, таким образом, чтобы загрузить пакет, для регистрации обработчика команды запроса состояния.

[Поддержка асинхронного пакетов](how-to-use-asyncpackage-to-load-vspackages-in-the-background.md): новый базовый класс AsyncPackage в Visual Studio 2015 позволяет пакетов Visual Studio необходимо загрузить в фоновом режиме асинхронно по запросу загрузку пакета был атрибут автоматической загрузки или запроса на асинхронную службу. Загрузки в фоновом режиме позволяет IDE быстро реагировать во время инициализации расширения в фоновом режиме и важных сценариев, как решение и запуска нагрузки не влияет.

[Асинхронные службы](how-to-provide-an-asynchronous-visual-studio-service.md): поддержка асинхронной пакета, мы добавили поддержку асинхронных запросов службы и возможность зарегистрировать асинхронные службы. Еще важнее, мы работаем над преобразование базовых служб Visual Studio для поддержки асинхронного запроса, что большая часть работы асинхронного запроса происходит в фоновых потоках. Модели SComponentModel (Visual Studio MEF host) является одним из основных служб, которые теперь поддерживает асинхронный запрос для обеспечения расширений для поддержки асинхронной загрузки полностью.

## <a name="reducing-impact-of-auto-loaded-extensions"></a>Снижения воздействия автоматической загрузки расширения

Если пакет по-прежнему должен быть автоматически при загрузке системы, важно свести к минимуму работу во время инициализации пакета, чтобы снизить вероятность расширения, влияющие на запуск.

Ниже приведены некоторые примеры, которые могут привести к инициализации пакета должно быть дорогостоящим.

### <a name="use-of-synchronous-package-load-instead-of-asynchronous-package-load"></a>Использования синхронный пакета нагрузки вместо загрузку асинхронного пакета

Так как синхронный пакетов по умолчанию загружаются в основном потоке, мы рекомендуем владельцев расширения, которые автоматически загрузить пакеты используйте асинхронные пакета базовый класс как уже упоминалось ранее. Изменение автоматического загруженного пакета для обеспечения асинхронной загрузки также облегчит для решения других проблем ниже.

### <a name="synchronous-filenetwork-io-requests"></a>Синхронные файла или сетевые запросы ввода-ВЫВОДА

В идеале любой синхронный запрос ввода-ВЫВОДА файла или сетевой следует избегать в основном потоке, поскольку их влияние зависит от состояния компьютера и может заблокировать длительное время, в некоторых случаях.

С помощью пакета асинхронную загрузку и асинхронные API ввода-ВЫВОДА убедитесь, что инициализации пакета не блокирует основной поток в таких случаях и пользователи получают возможность взаимодействовать с Visual Studio, а запросы ввода-вывода будет выполняться в фоновом режиме.

### <a name="early-initialization-of-services-components"></a>Проводится предварительная инициализация службы, компоненты

Один из распространенных шаблонов во время инициализации пакета состоит в инициализации службы используется или предоставляемые этого пакета в методе конструктора или инициализировать пакет. Хотя это гарантирует, что готовы к использованию службы, также можно добавить излишних затрат в пакет загрузки, если эти службы не используются немедленно. Вместо этого такие службы должен быть инициализирован по запросу, чтобы свести к минимуму работу во время инициализации пакета.

Для глобальной службы, предоставляемые пакета можно использовать способы AddService принимает функцию отложенную инициализацию службы только в том случае, если она запрошена с помощью компонента. Для служб, используемых в пакете, могут использовать Lazy<T> или AsyncLazy<T> для обеспечения служб инициализации и запрашивать при первом использовании.

## <a name="measuring-impact-of-auto-loaded-extensions-using-perfview"></a>Измерение воздействия автоматически загрузить расширения с помощью PerfView

Во время анализа кода можно идентифицировать пути кода, которые могут замедлить инициализации пакета, вы также можете использовать трассировку с помощью приложений, таких как PerfView понять влияние загрузку пакета при запуске Visual Studio.

PerfView — это средство трассировки расширенных системы, которая поможет вам понять критических путей в приложении, либо из-за использования ЦП или блокирующих вызовов системы. Ниже приведен краткий пример на анализ пример расширения с помощью найти по адресу PerfView [центра загрузки Майкрософт](https://www.microsoft.com/en-us/download/details.aspx?id=28567).

**Пример кода:**

Этот пример основан на примере ниже код, который предназначен для отображения случае некоторые распространенные причины задержки:

```c#
protected override void Initialize()
{
    // Initialize a class from another assembly as an example
    MakeVsSlowServiceImpl service = new MakeVsSlowServiceImpl();

    // Costly work in main thread involving file IO
    string systemPath = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
    foreach (string file in Directory.GetFiles(systemPath))
    {
        DateTime creationDate = File.GetCreationTime(file);
    }

    // Costly work after shell is initialized. This callback executes on main thread
    KnownUIContexts.ShellInitializedContext.WhenActivated(() =>
    {
        DoMoreWork();
    });

    // Start async work on background thread
    DoAsyncWork().Forget();
}

private async Task DoAsyncWork()
{
    // Switch to background thread to do expensive work
    await TaskScheduler.Default;
    System.Threading.Thread.Sleep(500);
}

private void DoMoreWork()
{
    // Costly work
    System.Threading.Thread.Sleep(500);
    // Blocking call to an asynchronous work.
    ThreadHelper.JoinableTaskFactory.Run(async () => { await DoAsyncWork(); });
}
```

**Запись трассировки с PerfView:**

После установки среды Visual Studio с расширением установлены, можно записать трассировку запуска, открыв сбор диалоговое окно «Сбор» меню PerfView.

![Сбор меню perfview](~/extensibility/media/perfview-collect-menu.png)

Параметры по умолчанию обеспечит стеки вызовов для использования ЦП, но так как мы заинтересованы в тоже время блокировки, также следует включить стеки «Потоков времени». После настройки все готово можно щелкнуть «Начать сбор» и запустите Visual Studio после запуска записи.

Прежде чем остановить сбор данных, требуется убедитесь, что Visual Studio полной инициализации, главное окно приложения является полностью видимым и если расширение любой части пользовательского интерфейса, которые автоматически отображать, они доступны. После полной загрузки Visual Studio и расширение инициализируется, можно остановить запись для анализа трассировки.

**Анализ трассировки с PerfView.**

После завершения записи PerfView автоматически откройте трассировку и разверните параметры.

Для целей этого примера мы заинтересованы главным образом в представлении «Время стеков потоков», которое можно найти в группе «Дополнительно». В этом представлении отображается общее время, затраченное в потоке с помощью метода, включая время ЦП и время блокировки, например операций ввода-ВЫВОДА или Ожидание дескрипторов.

 ![стеки потоков времени](~/extensibility/media/perfview-thread-time-stacks.png)

 При открытии представления «Время стеков потоков», следует выбрать процесс «devenv», чтобы начать анализ.

PerfView подробные инструкции о том, как для чтения поток времени стеки в собственное меню справки для более подробного анализа. Для целей этого примера нужно включить фильтрацию дальнейшей только в том числе стеков с нашего пакеты модуля имя и запуска потока.

1. Значение «GroupPats» для удаления любого группирования, по умолчанию добавляется пустой текст.
2. Набор «IncPats», введите часть имени сборки и запуска потоков помимо существующий фильтр процесса. В этом случае следует «devenv; Поток загрузки; MakeVsSlowExtension».

Теперь будут показаны сведения только затраты, связанные со сборками, связанные с расширением. В этом представлении любое время, перечисленные в столбце «Inc» (стоимость включительно) запуска потока связана с фильтрацией расширения и будет воздействие запуска.

В примере выше некоторые интересные вызов будет стеков:

1. Операций ввода-ВЫВОДА с помощью класса System.IO: хотя включительно стоимость эти кадры могут быть очень затратным в трассировку, они являются потенциальной причиной возникновения проблемы, поскольку скорость ввода-ВЫВОДА файла зависит от компьютера.

  ![кадры системы ввода-вывода](~/extensibility/media/perfview-system-io-frames.png)

2. Блокирующих вызовов, ожидающих другие асинхронной работы: В этом случае инклюзивного времени соответствуют времени, основной поток блокируется по завершении асинхронной работы.

  ![блокирующие кадров вызовов](~/extensibility/media/perfview-blocking-call-frames.png)

Одно из представлений трассировки, которые могут быть полезны для определения влияния будет «Стеки загрузки изображений». Можно применить те же фильтры применительно к представлению «Стеков потоков времени» и узнайте всех сборок, загруженных из-за выполнения пакетом автоматической загрузки кода.

Важно свести к минимуму число сборок, загруженных в процедуре инициализации пакета как каждую дополнительную сборку будет включать в себя дополнительного дискового ввода-вывода, который может замедлить запуск значительно на медленных компьютерах.

## <a name="summary"></a>Сводка

При запуске Visual Studio была одна из областей, которые мы постоянно получать отзывы о. Наша цель, как утверждалось ранее предназначен для всем пользователям согласованные запуска возникнуть независимо от того, компоненты и расширения, которые они установили и мы бы хотели работать с владельцами расширения, помогающие нам достичь этой цели. Вышеприведенное руководство могут помочь в понимании влияние расширения во время запуска и либо обойтись без автоматического нагрузки и загружать данные асинхронно, чтобы свести к минимуму влияние на производительность работы пользователей.
