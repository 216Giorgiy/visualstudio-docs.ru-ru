---
title: "Анализаторы Roslyn и поддержкой кода библиотеки для ImmutableArrays | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-ide-sdk"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 0b0afa22-3fca-4d59-908e-352464c1d903
caps.latest.revision: 5
caps.handback.revision: 5
ms.author: "gregvanl"
manager: "ghogen"
---
# Анализаторы Roslyn и поддержкой кода библиотеки для ImmutableArrays
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

[Платформы компилятора .NET](https://github.com/dotnet/roslyn) \(«Roslyn»\) помогает в создании поддерживающих кода библиотеки.  Учитывать код библиотеки предоставляет функциональные возможности, которые можно использовать и инструментарий \(анализаторы Roslyn\) поможет вам использовать библиотеку, лучшим способом или во избежание ошибок.  В этом разделе показано, как создавать реальные анализатор Roslyn для выявления распространенных ошибок при использовании [Неизменяемые коллекции](../Topic/NIB:%20Immutable%20Collections.md) NuGet\-пакет.  В примере также показано для предоставления исправления кода для кода, неполадки с помощью анализатора.  Исправления кода в Visual Studio лампочка пользовательского интерфейса и пользователи могут исправить код автоматически.  
  
## Содержание раздела  
 В этом разделе содержатся следующие разделы:  
  
-   Начало работы  
  
-   В чем заключается проблема?  
  
-   Поиск типа модели соответствующий код для активации вашей анализатора  
  
-   Создание проекта анализатора  
  
-   Инициализация анализатор  
  
-   Задание свойств для пользователей вашего анализатора  
  
-   Анализ выражения для создания объектов  
  
-   Запуска Visual Studio с вашей анализатора в первый раз  
  
-   Использование анализатора изменить и продолжить  
  
-   Добавление «Исправления кода» для кода ошибки  
  
-   Попытка исправления вашего кода  
  
-   Говорить видео и готовый код проекта  
  
## Начало работы  
 Следующие сборки этого примера необходимы:  
  
-   Visual Studio 2015 \(не экспресс\-выпуск\) или более поздней версии.  Можно использовать бесплатную [Visual Studio Community Edition](https://www.visualstudio.com/products/visual-studio-community-vs)  
  
-   [SDK для Visual Studio](../extensibility/visual-studio-sdk.md).  Можно также, при установке Visual Studio проверить расширяемость средств Visual Studio в разделе Общие средства Установка пакета SDK в то же время.  Если вы уже установили Visual Studio, можно установить этот пакет SDK, перейдя к главному меню **файл &#124; Новые &#124; Проект...**, выбрав C\# на панели навигации слева и затем выбрав расширяемости.  При выборе «**установить средства расширения Visual Studio**» шаблона проекта навигации, будет предложено загрузить и установить пакет SDK.  
  
-   [Платформы компилятора .NET \(«Roslyn»\) пакета SDK](http://aka.ms/roslynsdktemplates).  Можно также установить этот пакет SDK, выбрав в главном меню **файл &#124; Новые &#124; Проект...**, выберите **C\#** в левой области навигации, а затем выбрав **расширения**.  При выборе «**Загрузка пакета SDK платформы компилятора .NET**» шаблона проекта навигации, будет предложено загрузить и установить пакет SDK.  Этот пакет SDK включает [визуализаторе синтаксиса Roslyn](https://github.com/dotnet/roslyn/wiki/Syntax%20Visualizer).  Это очень полезное средство помогает понять, какие типы модели кода следует искать в вашей анализатора.  Анализатор инфраструктуры вызовы в код для конкретного кода типов моделей, поэтому код выполняется при необходимости и сосредоточиться только на анализ соответствующий код.  
  
## В чем заключается проблема?  
 Представьте себе обеспечить библиотеку с ImmutableArray \(например, <xref:System.Collections.Immutable.ImmutableArray%601?displayProperty=fullName>\) поддерживают.  C\# разработчики получили большой опыт работы с массивами .NET.  Однако из\-за природы ImmutableArrays и оптимизации приемы, используемые в реализации, intuitions разработчиков C\# вызвать библиотеки пользователям записывать неработающие кода, описанные ниже.  Кроме того пользователи не видят ошибок до времени выполнения, который не является качество работы, в которых они используются в Visual Studio с .NET.  
  
 Пользователи знакомы с написания кода следующим образом:  
  
<CodeContentPlaceHolder>0</CodeContentPlaceHolder>  
 Создание пустой массивы, чтобы наполнить последующих строк кода и с использованием синтаксиса инициализатора коллекции знакомо разработчикам C\#.  Однако же написание кода для ImmutableArray в случае сбоя во время выполнения:  
  
<CodeContentPlaceHolder>1</CodeContentPlaceHolder>  
 Первая ошибка из\-за ImmutableArray реализации с помощью структуры для упаковки базового хранилища данных.  Структуры должны иметь конструкторы без параметров, чтобы `default(T)` выражения могут возвращать структуры со всеми 0 или null членов.  Если код обращается к `b1.Length`, есть время выполнения разыменования ошибка из\-за не базовый массив хранения данных в структуре ImmutableArray.  Правильный способ создания пустой ImmutableArray `ImmutableArray<int>.Empty`.  
  
 Ошибка инициализаторы происходит потому, что метод ImmutableArray.Add возвращает новые экземпляры при каждом ее вызове.  Поскольку ImmutableArrays никогда не изменяются, при добавлении нового элемента, можно получить объект ImmutableArray \(который может предоставлять хранилища для повышения производительности существующих ImmutableArray\).  Поскольку `b2` указывает на первый ImmutableArray перед вызовом метода `Add()` пять раз `b2` является значением по умолчанию ImmutableArray.  Вызов длины на нем также аварийные null разыменования ошибки.  Правильный способ инициализации ImmutableArray без вызова Add вручную является использование `ImmutableArray.CreateRange(new int[] {1, 2, 3, 4, 5})`.  
  
## Поиск типов узлов соответствующий синтаксис для запуска вашего анализатора  
 Чтобы начать создание анализатор понять, какой тип SyntaxNode, вам нужно искать.    Запуск визуализатора синтаксис меню **View &#124; Другие окна &#124; Визуализаторе синтаксиса Roslyn**.  
  
 Поместите курсор в редакторе в строке, которая объявляет `b1`.  Появится визуализатор синтаксис показан в `LocalDeclarationStatement` узел дерева синтаксиса.  Этот узел содержит `VariableDeclaration`, который в свою очередь имеет `VariableDeclarator`, в свою очередь имеет `EqualsValueClause`, и наконец — `ObjectCreationExpression`.  Вариант синтаксиса визуализатор дерева узлов, чтобы показывать код, представленный этого узла выделяет синтаксис в окне редактора.  Имена типов sub SyntaxNode совпадают с именами, используемыми в грамматике C\#.  
  
## Создание проекта анализатора  
 В главном меню выберите **файл &#124; Новые &#124; Проект...**.  В **Новый проект** диалогового окна в разделе **C\#** проекты на панели навигации слева выберите расширения и в области справа выберите **Analyzer с исправить код** шаблона проекта.  Введите имя и диалоговое окно подтверждения.  
  
 Шаблон откроется файл DiagnosticAnalyzer.cs.  Выберите вкладку буфера этого редактора.  Этот файл содержит класс analyzer \(сформированный из имени вы присвоили проекта\), производный от `DiagnosticAnalyzer` \(тип Roslyn API\).  Новый класс имеет `DiagnosticAnalyzerAttribute` объявление ваш анализатор действителен для языка C\#, чтобы компилятор обнаруживает и загружает ваш анализатор.  
  
<CodeContentPlaceHolder>2</CodeContentPlaceHolder>  
 Можно реализовать с помощью Visual Basic, предназначенное для кода C\#, анализатор и наоборот.  Более важно в DiagnosticAnalyzerAttribute выбрать ли ваш анализатор предназначен для одного языка или оба.  Более сложные анализаторы, требующих подробные моделирования языка можно назначить только один язык.  Если ваш анализатор, например, только проверка имен типов или имена открытых членов, возможно использование общей модели языка, предлагаемых Roslyn между Visual Basic и C\#.  Например, FxCop предупреждает, что класс реализует <xref:System.Runtime.Serialization.ISerializable>, но класс не имеет <xref:System.SerializableAttribute> атрибута не зависит от языка и работает в код Visual Basic и C\#.  
  
## Анализатор инициализации  
 Прокрутите немного `DiagnosticAnalyzer` класс `Initialize` метод.  Компилятор вызывает этот метод при активации анализатора.  Этот метод принимает `AnalysisContext` объект, который позволяет вашей анализатор для получения сведений о контексте и регистрировать обратные вызовы для событий для типов кода, требуется проанализировать.  
  
<CodeContentPlaceHolder>3</CodeContentPlaceHolder>  
 Откройте новую строку в этот метод и тип «контекст». для просмотра списка завершения Intellisense.  Можно увидеть в списке завершения существует много `Register…` методы для обработки различных типов событий.  Например, первый из них, `RegisterCodeBlockAction`, вызовы в коде блока, который обычно между фигурными скобками.  Регистрация для блока также обратный вызов к коду для инициализатора поля, значение, заданное на атрибут или значение необязательного параметра.  
  
 Например `RegisterCompilationStartAction`, вызовы кода в начале компиляции полезно, когда необходимо собирать данные о состоянии на разных расположениях.  Можно создать структуру данных, скажем, чтобы собрать все символы, которые используются, и каждый раз ваш анализатор обратного вызова для некоторых синтаксис или символ, можно сохранить сведения о каждом расположении в структуре данных.  Если вы являетесь обратный вызов из\-за завершения компиляции, можно анализировать все расположения, сохраненный, например, на какие символы в коде используется из каждого отчета `using` инструкции.  
  
 С помощью **визуализаторе синтаксиса**, вы узнали, что вы хотите вызывается в том случае, когда компилятор обрабатывает ObjectCreationExpression.  Настройка обратного вызова, используйте следующий код:  
  
<CodeContentPlaceHolder>4</CodeContentPlaceHolder>  
 Регистрация для узла синтаксис и отфильтровать только узлы синтаксис создания объекта.  По соглашению авторы анализатора использовать лямбда\-выражение при регистрации действий, которые позволяют анализаторы без сохранения состояния.  Можно использовать функцию Visual Studio **Создание в результате использования** для создания `AnalyzeObjectCreation` метод.  Это создает правильный тип параметр контекста для вас слишком.  
  
## Задание свойств для пользователей вашего анализатора  
 Чтобы ваш анализатор отображается в пользовательском Интерфейсе Visual Studio соответствующим образом, поиск и измените следующую строку кода для обозначения вашей анализатора:  
  
<CodeContentPlaceHolder>5</CodeContentPlaceHolder>  
 Изменение `"Naming"` для `"API Guidance"`.  
  
 Затем найдите и откройте файл Resources.resx в проект с помощью **обозревателе решений**.  Можно поместить в описание для анализатора, заголовок, и т. д.  Можно изменить значение для всех параметров значение `“Don’t use ImmutableArray<T> constructor”` сейчас.  Можно поместить аргументы в строке форматирования строк \({0}, \\{1\\} и т.д.\) и более поздних версий, при вызове `Diagnostic.Create()`, можно передать массив params аргументов для передачи.  
  
## Анализ выражения для создания объектов  
 `AnalyzeObjectCreation` Метод использует другой тип контекста, предоставленного платформой анализатора кода.  Метод Initialize `AnalysisContext` позволяет регистрировать обратные вызовы действия для настройки вашей анализатора.`SyntaxNodeAnalysisContext`, Например, `CancellationToken` можно обойти.  Если пользователь начинает ввод в редакторе, Roslyn приведет к отмене выполнения анализаторы сохранить работу и повысить производительность.  В качестве другого примера этот контекст имеет свойство узла, которое возвращает узел синтаксис создания объекта.  
  
 Получите узел, который предполагается тип, для которого отфильтрованные действия узла синтаксис:  
  
<CodeContentPlaceHolder>6</CodeContentPlaceHolder>  
### Запуска Visual Studio с вашей анализатора в первый раз  
 Запустите Visual Studio, построения и выполнения вашего analyzer \(нажмите клавишу **F5**\).  Так как начальный проект **обозревателе решений** проект VSIX, выполнение кода сборки, код и VSIX и затем запускает Visual Studio в VSIX, что установлен.  При запуске Visual Studio таким образом, он запускается с куст реестра distinct, чтобы основной работы Visual Studio не повлияет экземпляры тестирования при построении анализаторов.  Во время первой загрузки таким образом, Visual Studio выполняет несколько инициализаций аналогично при при первом запуске Visual Studio после его установки.  
  
 Создайте проект консольного, а затем введите код массив в метод Main консольного приложения:  
  
<CodeContentPlaceHolder>7</CodeContentPlaceHolder>  
 Следующие строки кода с `ImmutableArray` волнистые линии, поскольку необходимо получить неизменяемый NuGet\-пакет и добавить имеют `using` инструкции в коде.  Нажмите правой кнопкой мыши узел проекта в **обозревателе решений** и выберите **Управление пакетами NuGet...**.  В диспетчере NuGet, введите «Неизменяемые» в поле «Поиск» и выберите элемент «System.Collections.Immutable» \(не выбирайте «Microsoft.Bcl.Immutable»\) в левой панели и нажмите «установить» в правой области.  Установка пакета добавляет ссылку в ссылки проекта.  
  
 По\-прежнему видеть красные волнистые линии под `ImmutableArray`, поэтому поместите курсор в код и нажмите клавишу **CTRL \+.** \(точка\) для вызова меню предлагаемое решение и добавить соответствующий `using` инструкции.  
  
 **Сохранить все и закрыть** второй экземпляр Visual Studio теперь можно поместить в исходное состояние, чтобы продолжить.  
  
## Использование анализатора изменить и продолжить  
 В первом экземпляре Visual Studio, установите точку останова в начале вашего `AnalyzeObjectCreation` метод нажатием **F9** с помощью курсора в первой строке.  
  
 Запустите ваш анализатор повторно с **F5**, а во втором экземпляре Visual Studio, снова откройте созданный время последнего консольное приложение.  
  
 Возвращает первый экземпляр Visual Studio в точке останова, так как компилятор Roslyn видели выражения для создания объектов и вызывается в ваш анализатор.  
  
 **Получает узел создания объекта.** Шаг с обходом строку, которая задает `objectCreation` переменных, нажав клавишу **F10**, и в **окна интерпретации** вычислить выражение `“objectCreation.ToString()”`.  Можно увидеть, что переменная указывает на узел синтаксис код `"new ImmutableArray<int>()"`, просто то, что вы ищете.  
  
 **Получите объект типа ImmutableArray \< T \>.** Необходимо проверить, является ли тип создаваемой ImmutableArray.  Во\-первых можно получить объект, представляющий этот тип.  Проверка типов с помощью семантической модели, чтобы иметь ровно правильный тип и не сравнивать строки из метода ToString\(\).  Введите следующую строку кода в конце функции:  
  
<CodeContentPlaceHolder>8</CodeContentPlaceHolder>  
 Назначить универсальных типов в метаданные с backquotes \('\) и числом универсальных параметров.  Вот почему вы не видите... ImmutableArray \< T \> "в имя метаданных.  
  
 Семантическая модель содержит множество полезных вещей, позволяющие получить ответы на вопросы символы, поток данных, время существования переменной, и т. д.  Roslyn разделяет узлы синтаксис семантической модели по различным причинам engineering \(производительность, моделирование ошибочный код и т. д.\).  Требуется модель компиляции для поиска информации, содержащейся в ссылках на точное сравнение.  
  
 Можно перетащить указатель выполнения желтый левой части окна редактора.  Перетащите его вверх на ту строку, которая задает `objectCreation` переменной и шаг с обходом новую строку кода с помощью **F10**.  Если навести указатель мыши на переменную `immutableArrayOfType`, вы видите, было найдено точного типа в семантической модели.  
  
 **Получите тип выражения для создания объектов.** «Тип» используется несколькими способами, в этой статье, но это означает, что если у вас есть «новый Foo» выражение, необходимо получить модель Foo.  Вам необходимо получить тип выражения для создания объектов для просмотра, если это тип ImmutableArray \< T \>.  Снова используйте семантической модели для получения сведений о символах для типа символа \(ImmutableArray\) в выражение создания объекта.  Введите следующую строку кода в конце функции:  
  
<CodeContentPlaceHolder>9</CodeContentPlaceHolder>  
 Поскольку ваш анализатор должен обрабатывать неполных или неверных код в буферы редактора \(например, отсутствует `using` инструкции\), необходимо проверить наличие `symbolInfo``null`.  Вам необходимо получить именованных типов \(INamedTypeSymbol\) из объекта сведений символ завершения анализа.  
  
 **Сравнение типов.** Поскольку имеется открытый универсальный тип T, который мы ищем конкретный универсальный тип — тип в коде, запросить информацию о символах для типа состоит из \(открытый универсальный тип\) и сравнить результат с `immutableArrayOfTType`.  Введите следующую команду в конце метода:  
  
```c#  
if (symbolInfo != null && symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType)) {}  
```  
  
 **Отчет диагностики.** Диагностические отчеты — довольно просто.  Использовать правила, созданные в шаблоне проекта определяется перед вызовом метода Initialize.  Из\-за этой ситуации в коде ошибки, можно изменить строку, инициализированный правило для замены `DiagnosticSeverity.Warning` \(зеленой волнистой линией\) с `DiagnosticSeverity.Error` \(красной волнистой линией\).  Инициализирует остальные правила из ресурсов, измененные в начале этого пошагового руководства.  Вам также необходимо получить расположение волнистой линией, в которой находится спецификация типа выражение создания объекта.  Введите следующий код в `if` блок:  
  
```c#  
context.ReportDiagnostic(Diagnostic.Create(Rule, objectCreation.Type.GetLocation()));  
```  
  
 Функция должна выглядеть так \(возможно различное\):  
  
```c#  
private void AnalyzeObjectCreation(SyntaxNodeAnalysisContext context) { var objectCreation = (ObjectCreationExpressionSyntax)context.Node; var immutableArrayOfTType = context.SemanticModel .Compilation .GetTypeByMetadataName( "System.Collections.Immutable.ImmutableArray`1"); var symbolInfo = context.SemanticModel.GetSymbolInfo(objectCreation.Type) as INamedTypeSymbol; if (symbolInfo != null && symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType)) { context.ReportDiagnostic( Diagnostic.Create(Rule, objectCreation.Type.GetLocation())); } }  
  
```  
  
 Удалите точку останова, чтобы можно видеть вашей работе анализатора \(и прекращению передачи на первый экземпляр Visual Studio\).  Перетащите указатель выполнения в начало метода и нажмите клавишу **F5** продолжить выполнение.  При переключении второй экземпляр Visual Studio, компилятор будет запущен снова изучить код, и оно будет вызывать ваш анализатор.  Видите волнистую линию под `ImmutableType<int>`.  
  
## Добавление «Исправления кода» для кода ошибки  
 Прежде чем начать, закройте второй экземпляр Visual Studio и остановка отладки в первом экземпляре Visual Studio \(где вы разрабатываете анализатор\).  
  
 **Добавьте новый класс.** Используйте контекстное меню \(правой кнопкой мыши\) на узел проекта в обозревателе решений и выберите команду Добавить новый элемент.  Добавьте класс с именем `BuildCodeFixProvider`.  Этот класс должен наследовать `CodeFixProvider`, и необходимо будет использовать **CTRL \+.** \(точка\) для вызова исправления кода, который добавляет правильные `using` инструкции.  Этот класс также должен быть аннотированы `ExportCodeFixProvider` атрибутов и будет необходимо добавить `using` инструкции для устранения `LanguageNames` перечисления.  Должно появиться файл класса в его следующим кодом:  
  
```c#  
using Microsoft.CodeAnalysis; using Microsoft.CodeAnalysis.CodeFixes; namespace ImmutableArrayAnalyzer { [ExportCodeFixProvider(LanguageNames.CSharp)] class BuildCodeFixProvider : CodeFixProvider {}  
  
```  
  
 **Заглушки для унаследованных членов.** Теперь поместите курсор в редакторе в идентификаторах `CodeFixProvider` и нажмите клавишу **CTRL \+.** \(точка\) для заглушки для реализации этого абстрактного базового класса.  Создает для вас это свойство и метод.  
  
 **Реализуйте свойство.** Заполните `FixableDiagnosticIds` Свойства `get` текста с помощью следующего кода:  
  
```c#  
return ImmutableArray.Create(ImmutableArrayAnalyzerAnalyzer.DiagnosticId);  
```  
  
 Roslyn объединяет диагностики и исправления, сопоставляя эти идентификаторы, которые являются только строки.  Шаблон проекта создать код диагностики, можно изменить его.  Код в свойстве просто возвращает идентификатор класса анализатора.  
  
 **Метод RegisterCodeFixAsync принимает контекст.** Контекст важен, поскольку исправления кода можно применить к нескольким диагностики или в строке кода может быть более одной проблемы.  Если ввести «контекст». в теле метода списка завершения Intellisense покажу некоторые полезные члены.  Существует CancellationToken член, который можно проверить, если что\-то хочет отменить исправления.  Существует элемент документа, который имеет множество полезных элементов и позволяет получить для объектов модели проекта и решения.  Отсутствует элемент Span, начало и конец расположение кода указано, когда сообщил диагностики.  
  
 **Сделайте метод быть асинхронным.** Первое, что необходимо сделать — Устранение объявление созданный метод `async` метод.  Исправление кода для реализации абстрактного класса stubbing не включает в себя `async` Несмотря на то, что метод возвращает ключевое слово `Task`.  
  
 **Получите корень дерева синтаксиса.** Для изменения кода, необходимые для создания нового дерева синтаксиса изменения делает исправление кода.  Необходимо `Document` из контекста для вызова `GetSyntaxRootAsync`.  Это асинхронный метод из\-за неизвестного работы для получения дерева синтаксиса, возможно, включая получение файла с диска, его синтаксического анализа и построения модели кода Roslyn для него.  Пользовательский Интерфейс Visual Studio следует отвечает на запросы в течение этого времени, в которых использование `async` позволяет.  Замените строку кода в метод следующим кодом:  
  
```c#  
var root = await context.Document .GetSyntaxRootAsync(context.CancellationToken);  
```  
  
 **Найти узел с проблемой.** Вы передаете в контексте диапазон, но узел, найдите код, который необходимо изменить нельзя.  Обнаруженную диагностические предоставляется только диапазон для типа идентификатора \(где принадлежал волнистой линией\), но необходимо заменить выражения для создания объектов целиком, включая `new` keywoard в начале и в конце круглые скобки.  Добавьте следующий код в метод \(и использовать **CTRL \+.** добавление `using` инструкции для `ObjectCreationExpressionSyntax`\):  
  
```c#  
  
var objectCreation = root.FindNode(context.Span) .FirstAncestorOrSelf<ObjectCreationExpressionSyntax>();  
```  
  
 **Регистрация исправление кода для лампочка пользовательского интерфейса.** При регистрации кода исправление Roslyn автоматически подключается к Visual Studio лампочка пользовательского интерфейса.  Конечные пользователи увидят, они могут использовать **CTRL \+.** \(точка\), когда ваш анализатор волнистых линий неверный `ImmutableArray<T>` используйте конструктор.  Так как поставщик исправление кода выполняется только при наличии проблемы, можно предположить, что у вас есть выражение создания объекта, который вы искали.  Из параметра контекста можно зарегистрировать новое исправление кода, добавив следующий код в конец `RegisterCodeFixAsync` метод:  
  
```c#  
  
context.RegisterCodeFix( CodeAction.Create("Use ImmutableArray<T>.Empty", c => ChangeToImmutableArrayEmpty(objectCreation, context.Document, c)), context.Diagnostics[0]);  
```  
  
 Необходимо поместить курсор в редакторе в идентификаторе, `CodeAction`, затем с помощью **CTRL \+.** \(точка\), чтобы добавить соответствующий `using` инструкции для этого типа.  
  
 Поместите курсор в редакторе в `ChangeToImmutableArrayEmpty` идентификатор и использование **CTRL \+.** еще раз, чтобы создать заглушку этого метода.  
  
 Этот последний фрагмент кода, который вы добавили регистрирует исправления кода путем передачи `CodeAction` и код диагностики для вида обнаружена проблема.  В этом примере имеется только один код диагностики, этот код предоставляет исправлений, поэтому можно просто передать на первый элемент массива диагностики идентификаторы.  При создании `CodeAction`, передается в текст, который лампочка пользовательского интерфейса следует использовать как описание исправления кода.  Можно также передать в функцию, которая принимает CancellationToken и возвращает новый документ.  Новый документ будет содержать новое дерево синтаксиса, включающее Исправлен код, вызывающий `ImmutableArray.Empty`.  В этом фрагменте кода используется лямбда\-выражение таким образом, чтобы его можно закрыть узел objectCreation и контекстный документ.  
  
 **Создание нового дерева синтаксиса.** В `ChangeToImmutableArrayEmpty` метод которого заглушки, созданный ранее, введите строку кода: `ImmutableArray<int>.Empty;`.  При просмотре окна средства визуализаторе синтаксиса, видно, что этот синтаксис является узлом SimpleMemberAccessExpression.  Именно этот метод должен создавать и возвращать в новый документ.  
  
 Сначала необходимо изменить `ChangeToImmutableArrayEmpty` является добавление `async` перед `Task<Document>` поскольку генераторы кода нельзя предполагать, метод должен быть async.  
  
 Введите текст с помощью следующего кода, чтобы метод выглядел следующим образом:  
  
```c#  
  
private async Task<Document> ChangeToImmutableArrayEmpty( ObjectCreationExpressionSyntax objectCreation, Document document, CancellationToken c) { var generator = SyntaxGenerator.GetGenerator(document); var memberAccess = generator.MemberAccessExpression(objectCreation.Type, "Empty"); var oldRoot = await document.GetSyntaxRootAsync(c); var newRoot = oldRoot.ReplaceNode(objectCreation, memberAccess); return document.WithSyntaxRoot(newRoot); }  
```  
  
 Необходимо поместить курсор в редакторе в `SyntaxGenerator` идентификатор и использование **CTRL \+.** \(точка\), чтобы добавить соответствующий `using` инструкции для этого типа.  
  
 Этот код использует `SyntaxGenerator`, который является типом очень полезно для создания нового кода.  После получения генератор для документа, возникла проблема с кодом, `ChangeToImmutableArrayEmpty` вызовы `MemberAccessExpression`, передав тип, который содержит элемент, необходимо получить доступ к и имя члена как строка.  
  
 Затем метод извлекает корневой узел документа, и так как это может привести к произвольным работы в общем случае, код ждет этого вызова и передает этот токен отмены.  Модели кода Roslyn являются неизменяемыми, как и при работе со строкой .NET; При обновлении строки, вы получаете новый объект string в ответ.  При вызове метода `ReplaceNode`, вы получаете новый корневой узел.  Большая часть дерева синтаксиса является общим \(поскольку он станет неизменяемым\), но `objectCreation` заменяется узел `memberAccess` узла, а также все родительские узлы, вплоть до корня дерева синтаксиса.  
  
## Попытка исправления вашего кода  
 Теперь можно нажать клавишу **F5** для выполнения своей анализатора во втором экземпляре Visual Studio.  Откройте проект консоли, который использовался ранее.  Теперь вы увидите лампочки появляются, где для вашего нового выражения для создания объектов `ImmutableArray<int>`.  Если нажать кнопку **CTRL \+.** \(точка\) то вы увидите код исправления и просмотр автоматически созданный код различие в лампочка пользовательского интерфейса.  Roslyn создает это для вас.  
  
 PRO Совет: Если вы не видите лампочку с исправление кода запустите второй экземпляр Visual Studio, затем может необходимо очистить кэш компонента Visual Studio.  Очистка кэша вынуждает пересмотреть компонентов, чтобы Visual Studio затем следует получить последнюю компонента в Visual Studio.  Во\-первых закройте второй экземпляр Visual Studio.  Затем в проводнике Windows перейдите в каталог пользователя \(c:\\users\\ \< userid \>\) и найдите AppData\\Local\\Microsoft\\VisualStudio\\14.0Roslyn\\.  В этом каталоге удаление вложенный каталог ComponentModelCache.  Изменения версий с помощью Visual Studio «14».  
  
## Обсуждение видео и завершение кода проекта  
 Этот пример разработки и обсуждаются далее в [в этом докладе](http://channel9.msdn.com/events/Build/2015/3-725).  Беседа демонстрирует работу анализатора и поможет создать его.  
  
 Можно увидеть готовый код [здесь](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers).  Вложенные папки DoNotUseImmutableArrayCollectionInitializer и DoNotUseImmutableArrayCtor имеется файл C\# для поиска проблем и файл C\#, реализующий исправления кода в Visual Studio лампочка пользовательского интерфейса.  Обратите внимание, что готовый код имеет немного более абстракции во избежание снова и снова выборка объект типа ImmutableArray \< T \>.  Он использует вложенные действия зарегистрированных сохранить объект типа в контексте, который доступен всякий раз, когда вспомогательных действий \(анализ создания объекта и анализировать инициализации коллекции\) выполнения.  
  
## См. также  
 [Обсуждение \\\\Build 2015 г.](http://channel9.msdn.com/events/Build/2015/3-725)   
 [Полный код на github](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers)   
 [Несколько примеров на github, сгруппированы в три вида анализаторы](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Analyzer%20Samples.md)   
 [Другие документы на сайте github ОС](https://github.com/dotnet/roslyn/tree/master/docs/analyzers)   
 [Правила FxCop реализуется с помощью анализаторов Roslyn на github](https://github.com/dotnet/roslyn/tree/master/src/Diagnostics/FxCop)