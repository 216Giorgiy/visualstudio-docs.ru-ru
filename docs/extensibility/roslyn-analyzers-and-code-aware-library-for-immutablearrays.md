---
title: "Анализаторы Roslyn и учетом кода библиотеки для ImmutableArrays | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-sdk
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 0b0afa22-3fca-4d59-908e-352464c1d903
caps.latest.revision: "5"
author: gregvanl
ms.author: gregvanl
manager: ghogen
ms.openlocfilehash: 9b33516bd013f744813b2fdb357f224bcb0d9822
ms.sourcegitcommit: f40311056ea0b4677efcca74a285dbb0ce0e7974
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2017
---
# <a name="roslyn-analyzers-and-code-aware-library-for-immutablearrays"></a>Анализаторы Roslyn и учетом кода библиотеки для ImmutableArrays

[Платформой компилятора .NET](https://github.com/dotnet/roslyn) («Roslyn») служит для создания библиотек с учетом кода.  Учитывать код библиотеки предоставляет функциональные возможности, которые можно использовать и инструментарий (анализаторы Roslyn) по использованию библиотеки наилучшим образом или во избежание ошибок.  В этом разделе показано, как построить анализатора Roslyn реального мира, для перехвата распространенных ошибок при использовании [System.Collections.Immutable](https://www.nuget.org/packages/System.Collections.Immutable) пакет NuGet.  В примере также показано для предоставления исправления кода для кода проблемы, обнаруженные в анализаторе.  Исправления кода в Visual Studio лампочка пользовательского интерфейса и пользователи автоматически применяются исправления для кода.

## <a name="getting-started"></a>Начало работы

Необходимы следующие сборки этого примера:

* Visual Studio 2015 (не экспресс-выпуск) или более поздней версии.  Можно использовать бесплатную [Visual Studio Community Edition](https://www.visualstudio.com/products/visual-studio-community-vs)
* [Пакет SDK для Visual Studio](../extensibility/visual-studio-sdk.md).  Кроме того, при установке Visual Studio, проведите средств расширения Visual Studio в разделе общих средств для установки пакета SDK, в то же время.  Если вы уже установили Visual Studio, можно установить этот пакет SDK, перейдите в меню **файл &#124; Создать &#124; Проект...** , выбрав C# на панели навигации слева, а затем выберите расширяемости.  При выборе «**Установка средств расширения Visual Studio**"шаблона проекта навигатора, будет предложено загрузить и установить пакет SDK.
* [Платформой компилятора .NET («Roslyn») SDK](http://aka.ms/roslynsdktemplates).  Можно также установить этот пакет SDK, перейдите в меню **файл &#124; Создать &#124; Проект...** , выбрав команду **C#** в левой области навигации, а затем выбрав **расширяемости**.  При выборе «**загрузка пакета SDK платформы компилятора .NET**"шаблона проекта навигатора, будет предложено загрузить и установить пакет SDK.  Этот пакет SDK включает [Roslyn синтаксис визуализатор](https://github.com/dotnet/roslyn/wiki/Syntax%20Visualizer).  Этот очень полезное средство поможет понять, какие типы модели кода следует искать в вашей анализатора.  Вызовы анализатора инфраструктуры в код для конкретного кода типов моделей, поэтому код выполняется при необходимости и позволяет сосредоточиться только на анализ соответствующий код.

## <a name="whats-the-problem"></a>В чем проблема?

Представьте себе библиотеке предоставляется ImmutableArray (например, <xref:System.Collections.Immutable.ImmutableArray%601?displayProperty=fullName>) поддерживает.  Разработчикам C# есть много опыт работы с массивами .NET.  Тем не менее из-за особенностей ImmutableArrays и оптимизацию приемы, используемые в реализации, intuitions разработчиков C# вызвать пользователей библиотеки записи неработающий код, как описано ниже.  Кроме того не предоставляется пользователям их ошибки до времени выполнения, который не является качество работы, в котором они используются в Visual Studio и .NET.

Пользователям, знакомым с написания кода следующим образом:

```csharp
var a1 = new int[0];
Console.WriteLine("a1.Length = { 0}", a1.Length);
var a2 = new int[] { 1, 2, 3, 4, 5 };
Console.WriteLine("a2.Length = { 0}", a2.Length);
```

Создание пустых массивов, чтобы наполнить последующих строк кода и с использованием синтаксиса инициализатора коллекции очень знакомые разработчикам C#.  Однако же написание кода для ImmutableArray аварийно завершает работу во время выполнения:

```csharp
var b1 = new ImmutableArray<int>();
Console.WriteLine("b1.Length = { 0}", b1.Length);
var b2 = new ImmutableArray<int> { 1, 2, 3, 4, 5 };
Console.WriteLine("b2.Length = { 0}", b2.Length);
```

Первая ошибка происходит из-за ImmutableArray реализации с помощью структуры программы-оболочки для базового хранилища данных. Структуры должны иметь конструкторы без параметров, чтобы `default(T)` выражения могут возвращать структуры со всеми ноль или null членов.  Если код обращается к `b1.Length`, отсутствует время выполнения разыменования ошибка из-за не базовый массив хранения данных в структуре ImmutableArray.  Правильный способ создания пустой ImmutableArray — `ImmutableArray<int>.Empty`.

Ошибка с инициализаторы происходит потому, что метод ImmutableArray.Add возвращает новые экземпляры каждый раз при его вызове.  Поскольку ImmutableArrays никогда не изменяются, при добавлении нового элемента, можно получить объект ImmutableArray (который может предоставлять хранилища из соображений производительности существующих ImmutableArray).  Поскольку `b2` указывает на первый ImmutableArray перед вызовом `Add()` пять раз `b2` ImmutableArray по умолчанию.  Вызов длины на нем также аварийные завершения null разыменования ошибки.  Правильный способ инициализации ImmutableArray без вызова Add вручную заключается в использовании `ImmutableArray.CreateRange(new int[] {1, 2, 3, 4, 5})`.

## <a name="finding-relevant-syntax-node-types-to-trigger-your-analyzer"></a>Поиск типов узлов соответствующий синтаксис для запуска вашего анализатора

 Чтобы приступить к созданию анализатор, сначала понять, какой тип SyntaxNode, вам нужно искать. Запуск визуализатора синтаксис в меню **представление &#124; Другие окна &#124; Визуализатор синтаксис Roslyn**.

Поместите курсор редактора в строке, которая объявляет `b1`.  Появится визуализатор синтаксис показан в `LocalDeclarationStatement` узел синтаксического дерева.  Этот узел имеет `VariableDeclaration`, который в свою очередь имеет `VariableDeclarator`, который в свою очередь имеет `EqualsValueClause`и наконец — `ObjectCreationExpression`.  При щелчке синтаксис визуализатора дерева узлов синтаксис в окне редактора светлые тона к показан код, представленный в этом узле.  Имена типов sub SyntaxNode совпадают с именами, используемыми в грамматике C#.

## <a name="creating-the-analyzer-project"></a>Создание проекта анализатора

В главном меню выберите **файл &#124; Создать &#124; Проект...** .  В **новый проект** диалогового окна в разделе **C#** проектов на панели навигации слева выберите расширяемости и в области справа выберите **анализатора с исправить код** проекта шаблон.  Введите имя и диалоговое окно подтверждения.

Шаблон откроется файл DiagnosticAnalyzer.cs.  Выберите вкладку буфера для этого редактора.  Этот файл содержит класс analyzer (сформированный из имени Вы дали проекта), производный от `DiagnosticAnalyzer` (тип Roslyn API).  Содержит новый класс `DiagnosticAnalyzerAttribute` объявление вашей анализатора действителен для языка C#, чтобы компилятор находит и загружает вашей анализатора.

```csharp
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class ImmutableArrayAnalyzerAnalyzer : DiagnosticAnalyzer
{}
```

Можно реализовать с помощью Visual Basic, который предназначен для кода C#, анализатор и наоборот.  Более важно в DiagnosticAnalyzerAttribute для выбора, обращается ли ваш анализатора языка один или оба.  Более сложные анализаторы, требующих подробные моделирования языка могут обращаться только один язык.  Если вашей analyzer, например, проверяет только имена типов или имена общих элементов, может быть невозможно использовать общие языковая модель, Roslyn обеспечивает в Visual Basic и C#.  Например, FxCop предупреждает, что класс реализует <xref:System.Runtime.Serialization.ISerializable>, но класс не имеет <xref:System.SerializableAttribute> атрибута не зависит от языка и работает в код Visual Basic и C#.

## <a name="initalizing-the-analyzer"></a>Анализатор инициализации

 Прокрутите вниз немного `DiagnosticAnalyzer` класс, чтобы просмотреть `Initialize` метод.  Компилятор вызывает этот метод при активации анализатора.  Этот метод принимает `AnalysisContext` объектом, который позволяет вашей анализатор для получения сведений о контексте и регистрировать обратные вызовы для событий для типов кода, который требуется проанализировать.

```csharp
public override void Initialize(AnalysisContext context) {}

```

Открыть новую строку в этот метод и тип «контекст». для просмотра списка завершения IntelliSense.  Можно увидеть в списке завершения много `Register...` методы для обработки различных типов событий.  Например, первое, `RegisterCodeBlockAction`, вызовы кода для блока, который обычно между фигурными скобками.  Регистрация для блока также обратный вызов в код для инициализации поля, значение, заданное на атрибут или значение необязательного параметра.

Например `RegisterCompilationStartAction`, вызовы кода в начале компиляции полезно, если необходимо собирать состояния через разных расположениях.  Можно создать структуру данных, скажем, чтобы собрать все символы, используемые, и каждый раз, когда ваш анализатор обратного вызова для некоторых синтаксиса или символ, можно сохранить информацию о каждом местоположении в структуре данных.  Если вы являетесь обратного вызова из-за завершения компиляции, можно анализировать все расположения, сохраненный, например, на какие символы в коде используется из каждого отчета `using` инструкции.

С помощью **визуализатор синтаксис**, вы узнали, что должно вызываться, когда компилятор обрабатывает ObjectCreationExpression.  Настройка обратного вызова, используйте следующий код:

```csharp
context.RegisterSyntaxNodeAction(c => AnalyzeObjectCreation(c),
                                 SyntaxKind.ObjectCreationExpression);
```

Регистрация для узла синтаксис и фильтр для только узлы синтаксис создания объекта.  По соглашению авторы анализатора использовать лямбда-выражение, при регистрации действий, которые позволяет обеспечить анализаторы без сохранения состояния.  Можно использовать функцию Visual Studio **создание в результате использования** для создания `AnalyzeObjectCreation` метод.  Это приводит к возникновению ошибки правильный тип параметра контекста для вас слишком.

## <a name="setting-properties-for-users-of-your-analyzer"></a>Задание свойств для пользователей вашей анализатора

Чтобы вашей анализатора отображается в пользовательском Интерфейсе Visual Studio соответствующим образом, найдите и измените следующую строку кода для обозначения вашей анализатора:

```csharp
internal const string Category = "Naming";
```

Change `"Naming"` to `"API Guidance"`.

Затем найдите и откройте `Resources.resx` файл в проект с помощью **обозревателе решений**.  Можно поместить в описание для анализатора, заголовок, и т. д.  Можно изменить значение для всех параметров значение `"Don't use ImmutableArray<T> constructor"` сейчас.  Можно поместить строку форматирования аргументы в строке ({0}, {1}, т. д.) и более поздних версий, при вызове `Diagnostic.Create()`, можно указать `params` массив аргументов для передачи.

## <a name="analyzing-an-object-creation-expression"></a>Анализ выражения для создания объектов

`AnalyzeObjectCreation` Метод принимает различные типы контекста, предоставленного платформой анализатора кода.  Метод Initialize `AnalysisContext` позволяет регистрировать обратные вызовы действия для настройки вашей анализатора.  `SyntaxNodeAnalysisContext`, Например, имеет `CancellationToken` , который можно передать вокруг.  Если пользователь запускает ввод в редакторе, Roslyn приведет к отмене выполнения анализаторы, чтобы сохранить работу и повысить производительность.  Другой пример: этот контекст имеет свойство узла, которое возвращает узел синтаксис создания объекта.

Получите узел, который предполагается тип, для которого отфильтрованные действия узла синтаксис:

```csharp
var objectCreation = (ObjectCreationExpressionSyntax)context.Node;
```

### <a name="launching-visual-studio-with-your-analyzer-the-first-time"></a>При запуске Visual Studio с вашей анализатора в первый раз

Запустите Visual Studio, построения и выполнения вашей analyzer (нажмите клавишу **F5**).  Так как начальный проект в **обозревателе решений** проект VSIX, выполнение кода сборки кода и расширение VSIX и затем запускает Visual Studio с VSIX, что установлен.  При запуске Visual Studio таким образом, он запускает с куст реестра distinct, чтобы не будут затронуты основной использование Visual Studio по тестированию экземпляры во время построения анализаторов.  При первом запуске таким образом, Visual Studio выполняет несколько инициализаций аналогично при первом запуске Visual Studio после его установки.

Создайте проект консольного приложения, а затем введите код массива в методе Main приложения консоли:

```csharp
var b1 = new ImmutableArray<int>();
Console.WriteLine("b1.Length = {0}", b1.Length);
var b2 = new ImmutableArray<int> { 1, 2, 3, 4, 5 };
Console.WriteLine("b2.Length = {0}", b2.Length);
```

Строки кода с `ImmutableArray` имеют волнистые линии, так как необходимо для получения неизменяемый пакета NuGet и добавьте `using` инструкции в коде.  Нажмите правой кнопкой мыши узел проекта в **обозревателе решений** и выберите **управление пакетами NuGet...** .  В диспетчер NuGet, введите «Неизменяемые» в поле поиска и выберите элемент «System.Collections.Immutable» (не выбирайте «Microsoft.Bcl.Immutable») в левой панели и нажмите кнопку "установить" на правой панели.  Установка пакета добавляет ссылку в ссылки проекта.

Вы по-прежнему видите красные волнистые линии под `ImmutableArray`, поэтому можно поместить курсор в код и нажмите клавишу **CTRL +.** (точка) для вызова меню предложенного исправления и добавить соответствующий `using` инструкции.

**Сохранить все и закрыть** второй экземпляр Visual Studio теперь можно поместить в исходное состояние, чтобы продолжить.

## <a name="finishing-the-analyzer-using-edit-and-continue"></a>Завершение анализа с помощью изменить и продолжить

В первом экземпляре Visual Studio, установите точку останова в начале вашей `AnalyzeObjectCreation` метод нажатием **F9** с курсор в первой строке.

Запустите ваш анализатор с **F5**и во втором экземпляре Visual Studio, снова откройте консольного приложения, созданного время последнего.

Возвращается на первый экземпляр Visual Studio, в точке останова, так как компилятор Roslyn видел выражения для создания объектов и вызывается в вашей анализатора.

**Получает узел создания объекта.** Шаг с обходом строки, которая задает `objectCreation` переменных, нажав клавишу **F10**и в **окна интерпретации** вычислить выражение `"objectCreation.ToString()"`.  Можно увидеть, что переменная указывает на узел синтаксического код `"new ImmutableArray<int>()"`, только что вы ищете.

**Получить ImmutableArray < T\> тип объекта.** Необходимо проверить, если тип, который создается ImmutableArray.  Во-первых можно получить объект, представляющий этот тип.  Необходимо проверить типов с помощью Семантическая модель, гарантирующую точно правильного типа и не будет сравнивать строки из ToString().  Введите следующую строку кода в конце функции:

```csharp
var immutableArrayOfTType =
    context.SemanticModel
           .Compilation
           .GetTypeByMetadataName("System.Collections.Immutable.ImmutableArray`1");
```

Можно назначить универсальных типов в метаданные с backquotes (') и число универсальных параметров.  Поэтому вы не видите «... ImmutableArray\<T >» в имя метаданных.

Семантическая модель содержит много полезных вещей, где можно задавать вопросы о символы, поток данных, время существования переменной, и т. д.  Roslyn разделяет узлы синтаксис семантической модели по различным причинам engineering (производительности моделирования ошибочный код и т. д.).  Требуется модель компиляции для поиска сведений, содержащихся в ссылках для точное сравнение.

Можно перетащить указатель выполнения желтый левой части окна редактора.  Перетащите его до строки, которая задает `objectCreation` переменной и шаг с обходом новую строку кода с помощью **F10**.  Если навести указатель мыши на переменную `immutableArrayOfType`, вы видите, что обнаружено точный тип в семантической модели.

**Получите тип выражения для создания объектов.** «Тип» используется несколькими способами, в этой статье, однако это означает, что если у вас есть «новый Foo» выражения, которые необходимо получить модель Foo.  Вам необходимо получить тип выражения для создания объектов на предмет ImmutableArray\<T > тип.  Повторно используйте семантической модели для получения сведений о символах для типа символа (ImmutableArray) в выражения для создания объектов.  Введите следующую строку кода в конце функции:

```csharp
var symbolInfo = context.SemanticModel.GetSymbolInfo(objectCreation.Type).Symbol as INamedTypeSymbol;
```

Так как ваш анализатор должен обрабатывать неполные или неверные код в буферах редактор (например, отсутствует `using` инструкции), необходимо проверить наличие `symbolInfo` , `null`.  Необходимо получить именованного типа (INamedTypeSymbol) из объекта сведения символ завершения анализа.

**Сравнения типов.** Так как отсутствует открытый универсальный тип T, который мы ищем, а тип в коде конкретный универсальный тип, запрос сведений о символах для типа формируется из (открытый универсальный тип) и сравните результат с `immutableArrayOfTType`.  Введите следующую команду в конце метода:

```csharp
if (symbolInfo != null &&
    symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType))
{}
```

**Отчетов диагностики.** Диагностические отчеты довольно просто.  Можно использовать правила, созданные в шаблоне проекта определенные до метода инициализации.  Поскольку такая ситуация, в коде является ошибка, можно изменить строку, инициализированный правило для замены `DiagnosticSeverity.Warning` (зеленая волнистая линия) с `DiagnosticSeverity.Error` (красная волнистая линия).  Остальная часть правила инициализирует от ресурсов, измененные в начале этого пошагового руководства.  Вам также необходимо получить расположение для пометки, в которой находится спецификация типа выражение создания объекта.  Введите этот код в `if` блока:

```csharp
context.ReportDiagnostic(Diagnostic.Create(Rule, objectCreation.Type.GetLocation()));
```

Функция должен выглядеть следующим образом (может быть отформатирован по-разному):

```csharp
private void AnalyzeObjectCreation(SyntaxNodeAnalysisContext context)
{
    var objectCreation = (ObjectCreationExpressionSyntax)context.Node;
    var immutableArrayOfTType =
        context.SemanticModel
               .Compilation
               .GetTypeByMetadataName(
                   "System.Collections.Immutable.ImmutableArray`1");
    var symbolInfo = context.SemanticModel.GetSymbolInfo(objectCreation.Type).Symbol as
        INamedTypeSymbol;
    if (symbolInfo != null &&
        symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType))
    {
        context.ReportDiagnostic(
            Diagnostic.Create(Rule, objectCreation.Type.GetLocation()));
    }
}
```

Удалите точку останова, чтобы можно увидеть в рабочую analyzer (и остановить возврат к первому экземпляру Visual Studio).  Перетащите указатель выполнения в начало метода и нажмите клавишу **F5** продолжить выполнение.  При переключении второй экземпляр Visual Studio, компилятор будет запущена изучить код еще раз и будет вызывать ваш анализатора.  Вы увидите волнистой линией `ImmutableType<int>`.

## <a name="adding-a-code-fix-for-the-code-issue"></a>Добавление «Исправить код» для кода проблемы

Прежде чем начать, закройте второй экземпляр Visual Studio и останавливать отладку в первом экземпляре Visual Studio (где вы разрабатываете анализатор).

**Добавьте новый класс.** Используйте контекстное меню (правой кнопкой мыши) на узел проекта в обозревателе решений и выберите команду Добавить новый элемент.  Добавьте класс с именем `BuildCodeFixProvider`.  Этот класс должен быть производным от `CodeFixProvider`, и необходимо будет использовать **CTRL +.** (точка) для вызова исправления кода, добавляющего правильные `using` инструкции.  Этот класс также должен сопровождаться атрибутом `ExportCodeFixProvider` потребуется добавить атрибут и `using` инструкции для устранения `LanguageNames` перечисления.  Файл класса следующим кодом, в нем должно быть:

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeFixes;

namespace ImmutableArrayAnalyzer
{
    [ExportCodeFixProvider(LanguageNames.CSharp)]
    class BuildCodeFixProvider : CodeFixProvider
    {}

```

**Заглушки для унаследованных членов.** Теперь поместите курсор редактора в идентификаторе `CodeFixProvider` и нажмите клавишу **CTRL +.** (точка) для заглушки для реализации этого абстрактного базового класса.  Создает для вас это свойство и метод.

**Реализует свойство.** Заполните `FixableDiagnosticIds` свойства `get` текста с помощью следующего кода:

```csharp
return ImmutableArray.Create(ImmutableArrayAnalyzerAnalyzer.DiagnosticId);
```

Roslyn объединяет в себе диагностики и исправления, сопоставляя эти идентификаторы, которые являются только строки.  Шаблон проекта создается код диагностики, и вы можете изменить его.  Код в свойстве просто возвращает идентификатор класса анализатора.

**Метод RegisterCodeFixAsync принимает контекст.** Контекст важен, поскольку исправления кода можно применить к нескольким диагностики или в строке кода может быть более одной проблемы.  Если ввести «контекст». в теле метода списка завершения IntelliSense покажет некоторые полезные элементы.  Нет CancellationToken член, который можно проверить, если что-то хочет отменить исправления.  Есть элемент документа, который имеет множество полезных элементов и позволяет получить объектов модели проекта и решения.  Отсутствует элемент Span, который находится в начале и конец расположение кода указано, когда сообщил диагностики.

**Сделайте метод быть асинхронным.** Первое, что нужно сделать — Устранение созданный метод объявление так, чтобы быть `async` метод.  Исправление кода использование заглушек для реализации абстрактного класса не включает `async` даже если метод возвращает ключевое слово `Task`.

**Получите корень дерева синтаксиса.** Для изменения кода, необходимые для создания нового дерева синтаксиса изменения делает исправление кода.  Требуется `Document` из контекст для вызова `GetSyntaxRootAsync`.  Это является асинхронным методом, из-за неизвестного работы для получения дерева синтаксиса, возможно, включающий начало файла с диска, его синтаксического анализа и построения модели кода Roslyn для него.  Пользовательского интерфейса Visual Studio следует отвечать на запросы в течение этого времени, когда `async` позволяет.  Замените строку кода в методе следующим кодом:

```csharp
var root = await context.Document
                        .GetSyntaxRootAsync(context.CancellationToken);
```

**Найти узел с проблемой.** Вы передаете в контексте области, но узел, с которым поиска не может быть код, который необходимо изменить.  Зарегистрированное диагностическое диапазон предоставляется только для типа идентификатора (где принадлежал волнистой линией), но необходимо заменить выражения для создания объектов, включая `new` ключевого слова в начале и в конце круглые скобки.  Добавьте следующий код в метод (и использовать **CTRL +.** Чтобы добавить `using` инструкции для `ObjectCreationExpressionSyntax`):

```csharp
var objectCreation = root.FindNode(context.Span)
                         .FirstAncestorOrSelf<ObjectCreationExpressionSyntax>();
```

**Зарегистрируйте исправление кода для лампочки пользовательского интерфейса.** При регистрации исправление кода Roslyn автоматически подключается к Visual Studio лампочка пользовательского интерфейса.  Конечные пользователи увидят, они могут использовать **CTRL +.** (точка), когда ваш анализатор подчеркивание слов с неверный `ImmutableArray<T>` используйте конструктор.  Так как поставщик исправление кода выполняется только в том случае, если имеется проблема, можно предположить, что у вас есть выражения создания объекта, который вы искали.  Из параметра контекста можно зарегистрировать новый исправления кода, добавив следующий код в конец `RegisterCodeFixAsync` метод:

```csharp
context.RegisterCodeFix(
            CodeAction.Create("Use ImmutableArray<T>.Empty",
                              c => ChangeToImmutableArrayEmpty(objectCreation,
                                                               context.Document,
                                                               c)),
            context.Diagnostics[0]);
```

Необходимо поместить курсор редактора в идентификаторе, `CodeAction`, затем с помощью **CTRL +.** (точка), чтобы добавить соответствующий `using` инструкции для этого типа.

Поместите курсор в редакторе в `ChangeToImmutableArrayEmpty` идентификатор и используйте **CTRL +.** еще раз, чтобы создать заглушку этого метода для вас.

Этот последний фрагмент кода, добавленного регистрирует исправления кода, передавая `CodeAction` и код диагностики для вида обнаружена проблема.  В этом примере имеется только один код диагностики, предоставляющий этот код выполняется восстановление, так можно просто передать первый элемент массива идентификаторов диагностики.  При создании `CodeAction`, передав текст, который лампочка пользовательского интерфейса в качестве описания исправления кода следует использовать.  Можно также передать в функцию, которая принимает CancellationToken и возвращает новый документ.  Новый документ имеет новое дерево синтаксиса, включающее Исправлен код, вызывающий `ImmutableArray.Empty`.  Этот фрагмент кода используются лямбда-выражение, поэтому его можно перекрыть objectCreation узла, а также в контексте документа.

**Создайте новое дерево синтаксиса.** В `ChangeToImmutableArrayEmpty` метод заглушки, которого был создан ранее, введите в строку кода: `ImmutableArray<int>.Empty;`.  Если просматривается в окне инструментов синтаксис визуализатор, видно, что этот синтаксис является узлом SimpleMemberAccessExpression.  Это необходимо для создания и возвращения в новый документ этого метода.

Первое изменение в `ChangeToImmutableArrayEmpty` заключается в добавлении `async` перед `Task<Document>` так, как генераторы кода нельзя предполагать, метод должен быть асинхронным.

Введите текст на следующий код, чтобы метод выглядел следующим образом:

```csharp
private async Task<Document> ChangeToImmutableArrayEmpty(
    ObjectCreationExpressionSyntax objectCreation, Document document,
    CancellationToken c)
{
    var generator = SyntaxGenerator.GetGenerator(document);
    var memberAccess =
        generator.MemberAccessExpression(objectCreation.Type, "Empty");
    var oldRoot = await document.GetSyntaxRootAsync(c);
    var newRoot = oldRoot.ReplaceNode(objectCreation, memberAccess);
    return document.WithSyntaxRoot(newRoot);
}
```

Необходимо поместить курсор редактора в `SyntaxGenerator` идентификатор и используйте **CTRL +.** (точка), чтобы добавить соответствующий `using` инструкции для этого типа.

Этот код использует `SyntaxGenerator`, который является типом удобно использовать для создания нового кода.  После получения генератор для документа, проблемы кода `ChangeToImmutableArrayEmpty` вызовы `MemberAccessExpression`, передав тип, имеющий член, мы хотим получить доступ к и имя члена как строка.

Затем метод извлекает корень документа и так как это может привести к произвольной рабочих в общем случае, код ожидает этот вызов и передает этот токен отмены.  Модели кода Roslyn являются неизменяемыми, как и при работе со строкой .NET; При обновлении строки, вы получаете новый объект string в ответ.  При вызове `ReplaceNode`, возвращается новый корневой узел.  Большая часть синтаксического дерева является общей (поскольку он станет неизменяемым), но `objectCreation` заменяется узел `memberAccess` узла, а также все родительские узлы, вплоть до корня дерева синтаксиса.

## <a name="trying-your-code-fix"></a>Попытка исправление кода

Теперь можно нажать клавиши **F5** для выполнения вашей анализатора на втором экземпляре Visual Studio.  Откройте проект консоли, который использовался ранее.  Теперь вы увидите лампочки отображаются, где в выражение создания нового объекта для `ImmutableArray<int>`.  Если нажать клавишу **CTRL +.** (период) будет отображен исправления кода и просмотр автоматически созданный код разница в лампочка пользовательского интерфейса.  Roslyn создает для вас.

**Совет по PRO:** Если запустить второй экземпляр Visual Studio и вы не видите лампочку с исправление кода, то может потребоваться очистить кэш компонента Visual Studio.  Очистка кэша вызывает повторный анализ компонентов, поэтому Visual Studio затем следует взять последнюю компонента в Visual Studio.  Во-первых закройте второй экземпляр Visual Studio.  В проводнике Windows перейдите в каталог пользователя (c:\users\\< userid\>) и найти AppData\Local\Microsoft\VisualStudio\14.0Roslyn\\.  В этом каталоге удалите вложенный каталог ComponentModelCache.  Изменения до версии с Visual Studio «14».

## <a name="talk-video-and-finish-code-project"></a>Видео Talk и Готово код проекта

Этот пример разработки и обсуждаются далее в [этот talk](http://channel9.msdn.com/events/Build/2015/3-725).  Поговорим демонстрирует работу анализатора и поможет выполнить для его создания.

Вы увидите все код завершения [здесь](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers).  Вложенные папки DoNotUseImmutableArrayCollectionInitializer и DoNotUseImmutableArrayCtor содержат файл C# для поиска проблем и файл C#, который реализует исправления кода, которые отображаются в Visual Studio лампочка пользовательского интерфейса.  Обратите внимание, что код завершения имеет немного более абстракции во избежание выборка ImmutableArray\<T > и снова типа object.  Она использует вложенные действия, зарегистрированного для сохранения типа объекта в контексте, который доступен всякий раз, когда вспомогательных действий (анализ создания объектов и анализировать инициализации коллекции) выполнения.

## <a name="see-also"></a>См. также

* [\\Поговорим \Build 2015 г.](http://channel9.msdn.com/events/Build/2015/3-725)
* [Полный код на GitHub](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers)
* [Несколько примеров на GitHub, сгруппированные по три вида анализаторы](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Analyzer%20Samples.md)
* [Другие документы на сайте GitHub ОС](https://github.com/dotnet/roslyn/tree/master/docs/analyzers)
* [Правила FxCop реализуется с помощью анализаторов Roslyn на GitHub](https://github.com/dotnet/roslyn/tree/master/src/Diagnostics/FxCop)
