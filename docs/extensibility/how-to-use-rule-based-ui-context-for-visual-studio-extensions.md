---
title: "Практическое руководство: использование контекста пользовательского интерфейса на основе правил для расширений Visual Studio | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 8dd2cd1d-d8ba-49b9-870a-45acf3a3259d
caps.latest.revision: 7
ms.author: "gregvanl"
caps.handback.revision: 7
---
# Практическое руководство: использование контекста пользовательского интерфейса на основе правил для расширений Visual Studio
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

Visual Studio позволяет загружать пакеты VSPackage при определенных известных <xref:Microsoft.VisualStudio.Shell.UIContext>активируются s. Эти контексты пользовательского интерфейса не очень хорошо гранулярностью, оставив расширение авторы нет выбора Однако для выбора доступного контекста пользовательского интерфейса, который активирует перед точкой подошла бы VSPackage для загрузки. Список известных контекстов пользовательского интерфейса см. в разделе <xref:Microsoft.VisualStudio.Shell.KnownUIContexts>.  
  
 Загрузка пакетов может повлиять на производительность и загружать их раньше, чем они нужны не рекомендуется. Visual Studio 2015 представляет концепцию, основанных на правилах контекстов пользовательского интерфейса, механизм, позволяющий разработчикам расширений определять точные условия, при которых активируется контекста пользовательского интерфейса и загрузить связанные пакеты VSPackage.  
  
## Контекст пользовательского интерфейса на основе правила  
 «Правило» состоит из нового контекста пользовательского интерфейса \(GUID\) и логическое выражение, которое ссылается на один или несколько «условия» в сочетании с логического «и», «или», «нет» операций. «Условия» вычисляются динамически во время выполнения и выражения вычисляется повторно, каждый раз, когда любой из его изменения условия. Если выражение имеет значение true, активируется связанный контекст пользовательского интерфейса. В противном случае — контекст пользовательского интерфейса является активным.  
  
 На основе правила контекста пользовательского интерфейса может использоваться различными способами:  
  
1.  Укажите ограничения на видимость для команд и окон инструментов. Можно скрыть команды и средства windows, пока не будет выполнено правило контекста пользовательского интерфейса.  
  
2.  Как автоматически загрузить ограничения: автоматически загрузить пакеты только в том случае, когда выполняется правило  
  
3.  Отложенные задачи: задержка загрузки, пока не истечет указанный интервал и по\-прежнему выполняется правило.  
  
 Механизм может использоваться любое расширение Visual Studio.  
  
## Создать контекст пользовательского интерфейса на основе правила  
 Предположим, что имеется расширение называется TestPackage, которая предлагает команды меню, которая применяется только к файлам с расширением «config». До VS2015, лучшим вариантом было загрузить TestPackage при <xref:Microsoft.VisualStudio.Shell.KnownUIContexts.SolutionExistsAndFullyLoadedContext%2A> пользовательского контекста активации. Это не эффективным, так как загруженное решение не может даже содержать файл .config. Сообщите нам см. в разделе как контекста пользовательского интерфейса на основе правил можно использовать для активации контекста пользовательского интерфейса, только если файл с расширением .config выбран и загрузить TestPackage при активации этого контекста пользовательского интерфейса.  
  
1.  Определить новый идентификатор GUID UIContext и добавьте в класс VSPackage <xref:Microsoft.VisualStudio.Shell.ProvideAutoLoadAttribute> и <xref:Microsoft.VisualStudio.Shell.ProvideUIContextRuleAttribute>.  
  
     Например, предположим, новый UIContext «UIContextGuid» — для добавления. Идентификатор GUID, созданный \(идентификатор GUID можно создать, щелкнув Сервис \-\> создать идентификатор guid\) — «8B40D5E2\-5626\-42AE\-99EF\-3DD1EFF46E7B». Затем добавьте следующий в класс пакета:  
  
    ```c#  
    public const string UIContextGuid = "8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B";  
    ```  
  
     Добавьте следующий код для атрибутов: \(сведения из этих атрибутов будет приведено далее\)  
  
    ```c#  
    [ProvideAutoLoad(TestPackage.UIContextGuid)]      
    [ProvideUIContextRule(TestPackage.UIContextGuid,  
        name: "Test auto load",   
        expression: "DotConfig",  
        termNames: new[] { "DotConfig" },  
        termValues: new[] { "HierSingleSelectionName:.config$" })]  
    ```  
  
     Эти метаданные определяют новый идентификатор GUID UIContext \(8B40D5E2\-5626\-42AE\-99EF\-3DD1EFF46E7B\) и выражение, ссылающееся на единственный термин «DotConfig». Термин «DotConfig» возвращает значение true, когда текущее выделение в активной иерархии имеет имя, которое соответствует шаблону регулярного выражения «\\.config$» \(заканчивается на «.config»\). Значение \(по умолчанию\) определяет необязательное имя для правила полезны для отладки.  
  
     Pkgdef формируются во время построения, затем добавляются значения атрибута.  
  
2.  В файле VSCT для команды TestPackage добавьте соответствующие команды флаг «DynamicVisibility»:  
  
    ```xml  
    <CommandFlag>DynamicVisibility</CommandFlag>  
    ```  
  
3.  В разделе видимость VSCT привязать соответствующие команды для UIContext новый идентификатор GUID, определенный в \#1:  
  
    ```xml  
    <VisibilityConstraints>   
        <VisibilityItem guid="guidTestPackageCmdSet" id="TestId"  context="guidTestUIContext"/>   
    </VisibilityConstraints>  
    ```  
  
4.  В разделе "символы" добавьте определение UIContext:  
  
    ```xml  
    <GuidSymbol name="guidTestUIContext" value="{8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B}" />  
    ```  
  
     Теперь команд контекстного меню для файлов \*.config будет видимым только в том случае, если элемент, выбранный в обозревателе решений — это файл «.config», пакет не будет загружен, пока не будет выбран один из этих команд.  
  
 Теперь давайте убедитесь, что загружает пакет, только если ожидается, что его с помощью отладчика. Чтобы отладить TestPackage:  
  
1.  Установите точку останова в <xref:Microsoft.VisualStudio.Shell.Package.Initialize%2A> метод.  
  
2.  Построение TestPackage и начать отладку.  
  
3.  Создайте проект или откройте один.  
  
4.  Выберите любой файл с расширением, отличным от .config. Не точка останова.  
  
5.  Выберите файл App.Config.  
  
 TestPackage загружает и останавливается в точке останова.  
  
## Добавление дополнительных правил для контекста пользовательского интерфейса  
 Поскольку правила контекста пользовательского интерфейса, логические выражения, можно добавить больше ограничений, правил для контекста пользовательского интерфейса. Например в контексте UI выше можно указать, что правило применяется только при загрузке решение с проектом. Таким образом команды не отображаются при открытии файла «.config» как отдельный файл, а не как часть проекта.  
  
```c#  
[ProvideAutoLoad(TestPackage.UIContextGuid)]      
[ProvideUIContextRule(TestPackage.UIContextGuid,    
    name: "Test auto load",  
    expression: "(SingleProject | MultipleProjects) & DotConfig",    
    termNames: new[] { "SingleProject", "MultipleProjects","DotConfig" },     
    termValues: new[] { VSConstants.UICONTEXT_SolutionHasSingleProject_string , VSConstants.UICONTEXT_SolutionHasMultipleProjects_string , "HierSingleSelectionName:.config$" })]  
```  
  
 Теперь выражение ссылается на три условия. Первые два условия, «SingleProject» и «MultipleProjects», см. в других известных контекстов пользовательского интерфейса \(по идентификаторам GUID\). Третий термин «DotConfig» является контекст пользовательского интерфейса на основе правил определенного ранее.  
  
## Задержки активации  
 Правила могут иметь необязательный «задержка». Задержка измеряется в миллисекундах. Если он имеется, задержка приводит к активации или деактивации контекста пользовательского интерфейса правило пришло в заданный интервал времени. Если правило изменения обратно до истечения интервала задержки, то ничего не происходит. Этот механизм может использоваться инициализация — особенно однократную инициализацию, не полагаясь на таймеры и регистрации простоя уведомлений «сдвиг».  
  
 Например можно указать правило теста нагрузки установлена задержка в 100 миллисекунд:  
  
```c#  
[ProvideAutoLoad(TestPackage.UIContextGuid)]  
[ProvideUIContextRule(TestPackage.UIContextGuid,   
    name: "Test auto load",  
    expression: "DotConfig",   
    termNames: new[] { "DotConfig" },  
    termValues: new[] { "HierSingleSelectionName:.config$" },   
    delay: 100)]  
```  
  
## Типы термин  
 Ниже приведены различные виды термин, поддерживаемых.  
  
|||  
|-|-|  
|{nnnnnnnn\-nnnn\-nnnn\-nnnn\-nnnnnnnnnnnn}|Идентификатор GUID относится контекст пользовательского интерфейса. Термин будет иметь значение true, всякий раз, когда контекст пользовательского интерфейса активных и false в противном случае.|  
|HierSingleSelectionName: \< шаблон \>|Термин будет иметь значение true, каждый раз, когда в активной иерархии выбирается один элемент и имя выбранного элемента соответствует регулярное выражение .net в «шаблон».|  
|UserSettingsStoreQuery: \< query \>|«запрос» представляет собой полный путь в хранилище настроек пользователя, которое должно быть равно ненулевое значение. Запрос состоит из «коллекции» и «propertyName» в последней косой черты.|  
|ConfigSettingsStoreQuery: \< query \>|«запрос» представляет собой полный путь в хранилище параметров конфигурации, которое должны иметь ненулевое значение. Запрос состоит из «коллекции» и «propertyName» в последней косой черты.|  
|ActiveProjectFlavor: \< projectTypeGuid \>|Термин будет иметь значение true, когда процессов выбранный проект \(совокупно\) и имеет flavor, сопоставление данного типа проекта GUID.|  
|ActiveEditorContentType: \< тип \>|Термин будет иметь значение true, если выбранный документ представляет собой текстовый редактор с заданным типом содержимого.|  
|ActiveProjectCapability: \< выражение \>|Термин имеет значение true, если приведенное выражение соответствует возможности активного проекта. Выражение может быть что\-то вроде VB &#124; C\#|  
|SolutionHasProjectCapability: \< выражение \>|Аналогична выше, но термин имеет значение true, если решение содержит любой загруженный проект, который соответствует выражению.|  
  
## Совместимость с разными версиями расширение  
 Правила на основе контексты пользовательского интерфейса — это новая функция в Visual Studio 2015 и не будут переноситься в более ранних версиях. Это создает проблему с расширениями или пакетов, предназначенных для нескольких версий Visual Studio, которая может автоматически загружаются в Visual Studio 2013 и более ранних версий, но можно воспользоваться контексты пользовательского интерфейса на основе правил для предотвращения автоматически загружаются в Visual Studio 2015.  
  
 Для поддержки такого пакета, AutoLoadPackages записи в реестре могут предоставлять флаг в поле значение для указания, что записи должны быть пропущены в Visual Studio 2015 и более поздних версий. Это можно сделать, добавив возможность флаги <xref:Microsoft.VisualStudio.Shell.PackageAutoLoadFlags>. Теперь можно добавить пакеты VSPackage **SkipWhenUIContextRulesActive** параметр для их <xref:Microsoft.VisualStudio.Shell.ProvideAutoLoadAttribute> атрибут для указания операции учитываются в Visual Studio 2015 и выше.  
  
## Правила контекста расширяемый пользовательский Интерфейс  
 В некоторых случаях пакеты нельзя использовать правила статического контекста пользовательского интерфейса. Например предположим, что пакет поддержки расширяемости, таким образом, что состояние команды на основании редактор типов, которые поддерживаются поставщиками импортированных MEF. Команда доступна, если расширение поддержки редактирования текущего типа. В таких случаях сам пакет невозможно использовать правило статического контекста пользовательского интерфейса, поскольку условия мог измениться в зависимости от того, какие MEF расширения доступны.  
  
 Для поддержки таких пакетов, контексты пользовательского интерфейса на основе правил поддержки выражение жестко «\*», указывающее, все приведенные ниже условия будут входить с или. Это обеспечивает главный пакет для определения известных правила на основе контекста пользовательского интерфейса и связать его состояние команды в этом контексте. После этого любое расширение MEF, предназначенные для главный пакет можно добавить условия для редакторов, поддерживаемых им не влияя на другие термины или master выражения.  
  
 Конструктор <xref:Microsoft.VisualStudio.Shell.ProvideExtensibleUIContextRuleAttribute.%23ctor%2A> документации показан синтаксис для расширенного правила контекста пользовательского интерфейса.