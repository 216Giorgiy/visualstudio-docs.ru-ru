---
title: Обзор протокола языка сервера | Документы Microsoft
ms.custom: ''
ms.date: 11/14/2017
ms.technology:
- vs-ide-sdk
ms.topic: conceptual
ms.assetid: 6a7d93c2-31ea-4bae-8b29-6988a567ddf2
author: gregvanl
ms.author: gregvanl
manager: douge
ms.workload:
- vssdk
ms.openlocfilehash: de7de0ce4d37ed74a7d2291ecf2f0db98c07478b
ms.sourcegitcommit: 6a9d5bd75e50947659fd6c837111a6a547884e2a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
ms.locfileid: "31147096"
---
# <a name="language-server-protocol"></a>Язык протокола сервера

## <a name="what-is-the-language-server-protocol"></a>Что такое протоколом языка?

Как и вспомогательных функций расширенного редактирования исходного кода auto завершений или **перейти к определению** для языка программирования в редакторе или в интегрированной среде разработки, в большинстве случаев очень сложным и требующим много времени. Обычно требуется, запись в доменную модель (сканер, средство синтаксического анализа, проверки типа, конструктор и многое другое) на языке программирования редактора или интегрированной среды разработки. Например подключаемый модуль Eclipse CDT, которая обеспечивает поддержку C и C++ в Интегрированной среде разработки Eclipse написан на языке Java, так как интегрированная среда разработки Eclipse, сам написан на языке Java. Следующий подход он означает реализация модели домена C/C++ в TypeScript для Visual Studio Code и модели отдельный домен в C# для Visual Studio.

Создание моделей домена для определенного языка, также намного проще, если средство разработки можно повторно использовать существующие библиотеки конкретного языка. Тем не менее эти библиотеки обычно реализуются в языке программирования (например, хорошим C/C++ домен модели реализованы в C/C++). Интеграция библиотеки C/C++ в редакторе на языке TypeScript технически возможно, но непростой задачей.

### <a name="language-servers"></a>Серверы языка

Другой подход заключается в том, для запуска библиотеки в собственном процессе и позволяет обращаться к нему межпроцессного взаимодействия. Сообщения, отправленные вперед и назад образуют протокол. Протокол сервера языка (LSP) — это совокупность стандартизация сообщений, передаваемых между средство разработки и процессом сервера языка. Использование серверов языка или программами не новые или novel идея. Редакторы, такие как Vim и Emacs ведете это некоторое время для поддержки семантического автоматического завершения. Цель LSP был для упрощения интеграции такого рода и представляют собой основную структуру полезна для предоставления возможностей языка для различных средств.

Общий протокол обеспечивает интеграцию возможности языков программирования в средство разработки с минимальными усилиями, используя существующую реализацию языка модели домена. Язык сервера внутреннего интерфейса может быть записан в PHP, Python и Java и LSP позволяет его легко интегрировать в разнообразных средств. Протокол работает на общего уровня абстракции, поэтому это средство может предложить форматированного языковые службы без необходимости полностью понимать особенности, относящиеся к доменной модели.

## <a name="how-work-on-the-lsp-started"></a>Как работают на LSP работы

LSP изменяется со временем и сегодня он находится в версии 3.0. Он начинается, когда концепция языка сервера был принят OmniSharp для предоставления богатые возможности редактирования для C#. Изначально OmniSharp использовать протокол HTTP с полезными данными JSON и встроено в нескольких редакторах, в том числе [кода Visual Studio](https://code.visualstudio.com).

В то время Microsoft начал работать на сервере языка TypeScript с принципом поддержки TypeScript в редакторах как Emacs и Sublime текста. В этой реализации редактор взаимодействует с помощью стандартного ввода вывода с TypeScript серверного процесса и использует впечатляющие протоколом отладчик V8 полезные данные JSON для запросов и ответов. TypeScript server встроено в TypeScript Sublime подключаемого модуля и VS Code для форматированного редактирования TypeScript.

После интегрированная два сервера на другой язык, команда VS Code начали работу с общего протокола сервера языка для редакторов и интегрированные среды разработки. Общий протокол позволяет поставщик языка для создания одного языка сервера, который может использоваться в различных сред разработки. Потребитель языка сервера имеет только один раз реализация протокола на стороне клиента. В результате ситуации вы всегда получаете для поставщика языка и языка потребителя.

Протокол языка сервера к работе с протокола, используемого сервером TypeScript, он был развернут с большим количеством функций языка по API языка VS Code. Протокол копируется с JSON-RPC для удаленного вызова благодаря простоте и существующих библиотек.

VS файл кода команды прототипом протокола путем реализации нескольких серверов linter языка, которые отвечать на запросы на корпус (Просмотр) и возвращают набор обнаруженных предупреждениях и ошибках. Цель заключалась в корпус файл как пользовательские изменения в документе, это означает, что будет много linting запросов во время сеанса редактора. Смысл сохранить настройку и запуск сервера, чтобы новый процесс linting не нужно запустить для каждого изменения пользователя. Несколько серверов linter были реализованы, включая VS Code ESLint и TSLint расширения. Эти два сервера linter, как реализована в TypeScript и JavaScript и работают на Node.js. Они совместно используют библиотеку, которая реализует клиентские и серверные часть протокола.

## <a name="how-the-lsp-works"></a>Как работает LSP

Язык сервера выполняется в собственном процессе и средства, такие как Visual Studio или VS Code связи с сервером по протоколу языка через JSON RPC. Еще одним преимуществом использования языка сервер, работающий в выделенном процессе является устранение проблемы производительности, связанные с моделью одного процесса. Фактический транспортный канал может быть stdio, сокеты, именованные каналы или узел ipc Если клиент и сервер записываются в Node.js.

Ниже на примере взаимодействия средство и язык сервера во время процедуры редактирования сеанса:

![Схема потока LSP](media/lsp-flow-diagram.png)

* **Пользователь открывает файл (так называемый документ) в средстве**: средство уведомляет сервер языка открыт документ («textDocument/didOpen»). Теперь Правда о содержимое документа больше не находится в файловой системе, но сохраняются с помощью средства в памяти.

* **Изменения, вносимые пользователем**: средство уведомляет сервер об изменении документа («textDocument/didChange») и информацию о своем программы обновляется сервером языка. При этом сервер языка анализирует эти сведения и уведомляет средство с обнаружены ошибки и предупреждения («textDocument/publishDiagnostics»).

* **Пользователь выполняет «Перейти к определению» на символ, в редакторе**: средство отправляет запрос «textDocument определение» с двумя параметрами: (1) документа URI и (2 положение текста, из которой была запущена перейти к определению запроса на сервер. Сервер в ответ отправляет документ URI и положение определения символа внутри документа.

* **Пользователь не закроет документ (файл)**: отправляется уведомление о «textDocument/didClose» в средстве информирования языка сервера документ теперь больше не в памяти и что текущее содержимое актуален теперь в файловой системе.

В этом примере показано, как протокол взаимодействует с сервером языка на уровне функций редактора, таких как «Перейти к определению», «Найти все ссылки». Типы данных, используемого протоколом, редактора или интегрированной среды разработки «типы данных» как открытый текстовый документ и положения курсора. Типы данных не на уровне домена-модель программирования языка, которая обычно предоставляют дерева абстрактного синтаксиса и компилятора символы (например, разрешенные типы, пространства имен,...). Это значительно упрощает протокол.

Теперь давайте рассмотрим запрос «textDocument определение» более подробно. Ниже приведены полезные данные, которые выходят между средством клиента и сервера языка для запроса «Перейти к определению» в документе C++.

Это запрос:

```json
{
    "jsonrpc": "2.0",
    "id" : 1,
    "method": "textDocument/definition",
    "params": {
        "textDocument": {
            "uri": "file:///p%3A/mseng/VSCode/Playgrounds/cpp/use.cpp"
        },
        "position": {
            "line": 3,
            "character": 12
        }
    }
}
```

Это ответ:

```json
{
    "jsonrpc": "2.0",
    "id": "1",
    "result": {
        "uri": "file:///p%3A/mseng/VSCode/Playgrounds/cpp/provide.cpp",
        "range": {
            "start": {
                "line": 0,
                "character": 4
            },
            "end": {
                "line": 0,
                "character": 11
            }
        }
    }
}
```

В ретроспективе описывающие типы данных на уровне редактора, а не на уровне модели языка программирования является одной из причин для успешного протоколом языка. Гораздо проще стандартизировать текстовый документ URI или положение курсора по сравнению с стандартизация символы дерева и компилятора абстрактного синтаксиса для разных языков программирования.

Когда пользователь работает с различными языками, VS Code обычно запускает сервер языка для каждого языка программирования. В приведенном ниже примере иллюстрирует сеанс, в котором пользователь работает с Java и SASS файлами.

![Java и sass](media/lsp-java-and-sass.png)

### <a name="capabilities"></a>Возможности

Не каждый язык сервер может поддерживать все функции, определенные в протоколе. Таким образом клиент и сервер сообщает их набор поддерживаемых функций через «возможности». Например сервер сообщает, он сможет обработать запрос «textDocument определение», но он не может обработать запрос «рабочей области или символ». Аналогичным образом клиенты может объявить, что они способны предоставить «попытка сохранить» уведомления до сохранения документа, чтобы сервер может вычислять текстовое изменения автоматически форматировать отредактированный документ.

## <a name="integrating-a-language-server"></a>Интеграция сервера языка

Фактический интеграции server языка в определенный средство не определяется протоколом языка и остается для средства реализации средства. Некоторые средства интеграции серверов языка универсальной, что расширение, которое можно запустить и обратиться к любой язык сервера. Другие, как VS Code создавать пользовательский модуль на каждом сервере языка, таким образом, существует возможность некоторые функции языка пользовательского расширения.

Для упрощения реализации языка серверов и клиентов, существует библиотеки и пакеты SDK для клиентских и серверных компонентов. Эти библиотеки предназначены для разных языков. Например, имеется [языка клиент npm модуль](https://www.npmjs.com/package/vscode-languageclient) для упрощения интеграции сервера языка в расширения VS Code, а другой [npm модуль языка сервера](https://www.npmjs.com/package/vscode-languageserver) для записи язык сервера, с помощью Node.js. Это текущий [списка](https://github.com/Microsoft/language-server-protocol/wiki/Protocol-Implementations) поддержки библиотек.

## <a name="using-the-language-server-protocol-in-visual-studio"></a>С помощью протокола сервера языка в Visual Studio

* [Добавление расширения протокола сервера языка](adding-an-lsp-extension.md) -Дополнительные сведения об интеграции сервера языка в Visual Studio.
