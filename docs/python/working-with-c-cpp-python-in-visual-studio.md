---
title: Работа с C++ и Python
description: Пошаговое руководство по созданию расширения C++ для Python с помощью Visual Studio, включая отладку в смешанном режиме.
ms.date: 06/27/2018
ms.prod: visual-studio-dev15
ms.technology: vs-python
ms.topic: conceptual
author: kraigb
ms.author: kraigb
manager: douge
ms.workload:
- python
- data-science
ms.openlocfilehash: fc885df4b85e89c85c366f033113678243fbfe0b
ms.sourcegitcommit: 4ab232758d308bda742434beff8349a80c167890
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/05/2018
ms.locfileid: "37847821"
---
# <a name="creating-a-c-extension-for-python"></a>Создание расширения C++ для Python

Модули, написанные на C++ (или C), обычно используются для расширения возможностей интерпретатора Python, а также для доступа к низкоуровневым возможностям операционной системы. Существует три основных типа модулей:

- Модули акселератора: так как Python — это интерпретируемый язык, для повышения производительности некоторые фрагменты кода могут быть написаны на C++.
- Модули оболочки: предоставляют существующие интерфейсы C/C++ для кода Python или адаптированный API, который удобно использовать в Python.
- Модули низкоуровневого системного доступа: созданы для доступа к низкоуровневым функциям среды выполнения CPython, операционной системы и базового оборудования.

В этой статье рассматривается создание модуля расширения C++ для CPython, вычисляющего гиперболический тангенс и вызывающего его из кода Python. Подпрограмма реализована сначала на языке Python, чтобы продемонстрировать относительный прирост производительности по сравнению с реализацией той же подпрограммы на C++.

Используемый здесь подход применяется для стандартных модулей CPython, как описано в [документации по Python](https://docs.python.org/3/c-api/). Сравнение этого и других средств описано в разделе [Альтернативные подходы](#alternative-approaches) в конце этой статьи.

Полный пример из этого руководства: [python-samples-vs-cpp-extension](https://github.com/Microsoft/python-sample-vs-cpp-extension) (GitHub).

## <a name="prerequisites"></a>Предварительные требования

- Visual Studio 2017 с установленными рабочими нагрузками **Разработка классических приложений на C++** и **Разработка на Python** с параметрами по умолчанию.
- В рабочей нагрузке **Разработка на Python** также установите флажок справа для параметра **Собственные средства разработки Python**. Этот параметр позволяет настроить большую часть конфигурации, описанной в этой статье. (Этот параметр также автоматически включает рабочую нагрузку C++.)

    ![Выбор параметра "Собственные средства разработки Python"](media/cpp-install-native.png)

    > [!Tip]
    > При установке рабочей нагрузки **Приложения для обработки и анализа данных и аналитические приложения** по умолчанию включаются среда Python и параметр **Собственные средства разработки Python**.

Дополнительные сведения, включая использование других версий Visual Studio, см. в разделе [Установка поддержки Python для Visual Studio](installing-python-support-in-visual-studio.md). Если вы устанавливаете Python отдельно, обязательно выберите параметры **Download debugging symbols** (Скачать отладочные символы) и **Download debug binaries** (Скачать двоичные файлы отладки) в разделе **Дополнительные параметры** установщика. Это гарантирует наличие необходимых отладочных библиотек, если вы решите сделать отладочную сборку.

## <a name="create-the-python-application"></a>Создание приложения Python

1. Создайте проект Python в Visual Studio, выбрав **Файл > Создать > Проект**. Выполните поиск слова "Python", выберите шаблон **Приложение Python**, назначьте ему подходящее имя и расположение, а затем нажмите кнопку **ОК**.

1. Для работы с C++ необходимо использовать 32-разрядный интерпретатор Python (рекомендуемая версия — Python 3.6). В окне **обозревателя решений** в Visual Studio разверните узел проекта, а затем — узел **окружения Python**. Если вы не видите 32-разрядное окружение по умолчанию (выделенное либо жирным шрифтом, или меткой "глобальное значение по умолчанию"), следуйте инструкциям по [выбору окружения Python для проекта](selecting-a-python-environment-for-a-project.md). Если у вас не установлена 32-разрядная версия интерпретарора, см. инмструкции по [установке интерпретаторов Python](installing-python-interpreters.md).

1. В файл `.py` проекта вставьте следующий код, отвечающий за тестирование производительности при вычислении гиперболического тангенса (для упрощения сравнения реализуется без использования математической библиотеки). Вы можете ввести код вручную, чтобы оценить некоторые [функции редактирования Python](editing-python-code-in-visual-studio.md).

    ```python
    from itertools import islice
    from random import random
    from time import perf_counter

    COUNT = 500000  # Change this value depending on the speed of your computer
    DATA = list(islice(iter(lambda: (random() - 0.5) * 3.0, None), COUNT))

    e = 2.7182818284590452353602874713527

    def sinh(x):
        return (1 - (e ** (-2 * x))) / (2 * (e ** -x))

    def cosh(x):
        return (1 + (e ** (-2 * x))) / (2 * (e ** -x))

    def tanh(x):
        tanh_x = sinh(x) / cosh(x)
        return tanh_x

    def sequence_tanh(data):
        '''Applies the hyperbolic tangent function to map all values in
        the sequence to a value between -1.0 and 1.0.
        '''
        result = []
        for x in data:
            result.append(tanh(x))
        return result

    def test(fn, name):
        start = perf_counter()
        result = fn(DATA)
        duration = perf_counter() - start
        print('{} took {:.3f} seconds\n\n'.format(name, duration))

        for d in result:
            assert -1 <= d <= 1, " incorrect values"

    if __name__ == "__main__":
        print('Running benchmarks with COUNT = {}'.format(COUNT))

        test(sequence_tanh, 'sequence_tanh')

        test(lambda d: [tanh(x) for x in d], '[tanh(x) for x in d]')
    ```

1. Запустите программу с помощью команды **Отладка > Запуск без отладки** (CTRL+F5), чтобы просмотреть результаты. Чтобы изменить длительность выполнения тестов производительности, можно настроить переменную `COUNT`. В целях этого руководства задайте значение так, чтобы каждый тест производительности занимал приблизительно две секунды.

## <a name="create-the-core-c-project"></a>Создание основного проекта C++

1. Щелкните правой кнопкой мыши решение в обозревателе решений и выберите **Добавить > Новый проект...**. Решение Visual Studio может одновременно содержать проекты Python и C++ (одно из преимуществ использования Visual Studio для Python).

1. Выполните поиск "C++", выберите **Пустой проект**, укажите имя (в этой статье используется "superfastcode") и нажмите кнопку **ОК**.

    > [!Tip]
    > Если вы уже установили **собственные средства разработки Python** в Visual Studio 2017, то можете начать с шаблона **Модуль расширения Python**, который уже содержит большую часть описываемых ниже функций. Но в этом пошаговом руководстве начало работы с пустого проекта позволяет шаг за шагом продемонстрировать создание модуля расширения. Когда вы освоите процесс, шаблон позволит вам сэкономить время при написании собственных расширений.

1. Создайте файл C++ в новом проекте. Для этого щелкните правой кнопкой мыши узел **Исходные файлы** и выберите **Добавить > Новый элемент…**, затем выберите **Файл C++**, присвойте ему имя `module.cpp` и нажмите кнопку **ОК**.

    > [!Important]
    > Файл с расширением `.cpp` нужен, чтобы активировать страницы свойств C++ в последующих шагах.

1. В решении щелкните проект C++ правой кнопкой мыши и выберите пункт **Свойства**.

1. В верхней части появившегося диалогового окна **Страницы свойств** задайте для параметра **Конфигурация** значение **Все конфигурации**, а для параметра **Платформа** — **Win32**.

1. Задайте определенные свойства, как описано в таблице ниже, а затем нажмите кнопку **ОК**.

    | Tab | Свойство. | Значение |
    | --- | --- | --- |
    | Общие | Общие > Целевое имя | Укажите имя модуля, которое будет использоваться из Python в инструкциях `from...import`. Это же имя используется в C++ при определении модуля для Python. Если вы хотите применять имя проекта в качестве имени модуля, оставьте значение по умолчанию `$(ProjectName)`. |
    | | Общие > Конечное расширение | .pyd |
    | | Значения по умолчанию для проекта > Тип конфигурации | Динамическая библиотека (.dll) |
    | C/C++ > Общие | Дополнительные каталоги включаемых файлов | Добавьте подходящую для вашей установки папку `include` Python, например `c:\Python36\include`.  |
    | C/C++ > Препроцессор | Определения препроцессора | Добавьте `Py_LIMITED_API;` в начало строки (включая точку с запятой). Это определение ограничивает некоторые функции, которые можно вызывать из Python, и расширяет возможности по переносу кода между разными версиями Python. |
    | C/C++ > Создание кода | Библиотека времени выполнения | Многопоточная DLL (/MD) (см. предупреждение ниже) |
    | Компоновщик > Общие | Дополнительные каталоги библиотек | Добавьте подходящую для вашей установки папку `libs` Python с файлами `.lib`, например `c:\Python36\libs`. (Нужно указать папку `libs`, содержащую файлы `.lib`, а *не* папку `Lib`, содержащую файлы `.py`.) |

    > [!Tip]
    > Если вы не видите вкладку C/C++ в свойствах проекта, значит, в проекте нет файлов, определенных как исходные файлы C и C++. Это условие может возникнуть при создании исходного файла без расширения `.c` или `.cpp`. Например, если ранее вы случайно ввели `module.coo` вместо `module.cpp` в диалоговом окне создания элемента, Visual Studio создает файл, но не задает для него тип "Код C/C+", что требуется для активации вкладки свойств C/C++. Такая неправильная идентификация остается актуальной и в случае переименования файла с использованием `.cpp`. Чтобы правильно задать тип файла, щелкните файл правой кнопкой мыши в обозревателе решений, выберите **Свойства** и задайте для параметра **Тип файла** значение **Код C/C++**.

    > [!Warning]
    > Всегда задавайте параметру **C/C++ > Создание кода > Библиотека времени выполнения** значение "Многопоточная библиотека DLL (/MD)" даже для конфигурации отладки, так как этот параметр используется для создания неотладочных двоичных файлов Python. Если задать параметр "Многопоточная библиотека DLL (/MDd)", при создании конфигурации отладки возникает ошибка *C1189: Py_LIMITED_API не совместим с Py_DEBUG, Py_TRACE_REFS и Py_REF_DEBUG*. Кроме того, если удалить `Py_LIMITED_API` во избежание этой ошибки сборки, Python аварийно завершает работу при попытке импортировать модуль. (Этот сбой возникает в вызове библиотеки DLL `PyModule_Create`, как описано ниже, и сопровождается сообщением *Fatal Python error: PyThreadState_Get: no current thread* (Неустранимая ошибка Python: PyThreadState_Get — нет текущего потока).)
    >
    > Параметр /MDd используется для сборки двоичных файлов отладки Python (например, python_d.exe), но его выбор для библиотеки DLL расширения по-прежнему вызывает ошибку сборки с `Py_LIMITED_API`.

1. Щелкните проект C++ правой кнопкой мыши и выберите **Сборка**, чтобы протестировать конфигурации (отладочную и окончательную). Файлы `.pyd` находятся в папке *solution* в каталоге **Debug** и **Release**, а не в самой папке проекта C++.

1. Добавьте в файл `module.cpp` проекта C++ следующий код.

    ```cpp
    #include <Windows.h>
    #include <cmath>

    const double e = 2.7182818284590452353602874713527;

    double sinh_impl(double x) {
        return (1 - pow(e, (-2 * x))) / (2 * pow(e, -x));
    }

    double cosh_impl(double x) {
        return (1 + pow(e, (-2 * x))) / (2 * pow(e, -x));
    }

    double tanh_impl(double x) {
        return sinh_impl(x) / cosh_impl(x);
    }
    ```

1. Еще раз выполните сборку проекта C++, чтобы убедиться в правильности кода.

## <a name="convert-the-c-project-to-an-extension-for-python"></a>Преобразование проекта C++ в расширение для Python

Чтобы превратить библиотеку DLL на C++ в расширение для Python, сначала нужно изменить экспортированные методы для взаимодействия с типами Python. После этого нужно добавить функцию, экспортирующую модуль, а также определения методов модуля.

Пояснения к тому, что показано в этом разделе для Python 3.x, см. в [справочном руководстве по API Python/C](https://docs.python.org/3/c-api/index.html) и, главным образом, в разделе [Module Objects](https://docs.python.org/3/c-api/module.html) (Модульные объекты) на сайте python.org (не забудьте выбрать вашу версию Python в раскрывающемся списке в правом верхнем углу, чтобы увидеть подходящую документацию).

Если вы работаете с Python 2.7, см. статьи [Extending Python 2.7 with C or C++](https://docs.python.org/2.7/extending/extending.html) (Расширение Python 2.7 с помощью C и C++) и [Porting Extension Modules to Python 3](https://docs.python.org/2.7/howto/cporting.html) (Перенос модулей расширения на Python 3) на сайте python.org.

1. В начало файла C++ включите `Python.h`:

    ```cpp
    #include <Python.h>
    ```

1. Измените метод `tanh_impl`, чтобы он принимал и возвращал типы Python (`PyOjbect*`):

    ```cpp
    PyObject* tanh_impl(PyObject *, PyObject* o) {
        double x = PyFloat_AsDouble(o);
        double tanh_x = sinh_impl(x) / cosh_impl(x);
        return PyFloat_FromDouble(tanh_x);
    }
    ```

1. Добавьте структуру, определяющую способ представления функции `tanh_impl` C++ для Python:

    ```cpp
    static PyMethodDef superfastcode_methods[] = {
        // The first property is the name exposed to Python, fast_tanh, the second is the C++
        // function name that contains the implementation.
        { "fast_tanh", (PyCFunction)tanh_impl, METH_O, nullptr },

        // Terminate the array with an object containing nulls.
        { nullptr, nullptr, 0, nullptr }
    };
    ```

1. Добавьте структуру, которая определяет модуль так, как вы хотите ссылаться на него в своем коде Python, в частности, при использовании оператора `from...import`. (Сделайте это значением в свойствах проекта в разделе **свойства конфигурации > Общие > Конечное имя**.) В приведенном ниже примере имя модуля superfastcode означает, что `from superfastcode import fast_tanh` можно использовать в Python, так как функция `fast_tanh` определена в `superfastcode_methods`. (Внутренние для проекта C++ имена файлов, такие как module.cpp, являются несущественными.)

    ```cpp
    static PyModuleDef superfastcode_module = {
        PyModuleDef_HEAD_INIT,
        "superfastcode",                        // Module name to use with Python import statements
        "Provides some functions, but faster",  // Module description
        0,
        superfastcode_methods                   // Structure that defines the methods of the module
    };
    ```

1. Добавьте метод, вызываемый Python при загрузке модуля. Он должен иметь имя `PyInit_<module-name>`, где *&lt;module_name&gt;* точно соответствует свойству **Общие > Конечное имя** проекта C++ (то есть соответствует имени файла `.pyd`, созданного проектом).

    ```cpp
    PyMODINIT_FUNC PyInit_superfastcode() {
        return PyModule_Create(&superfastcode_module);
    }
    ```

1. Задайте целевой конфигурации значение "Выпуск" и повторно создайте проект C++, чтобы проверить код. Если возникают ошибки, проверьте следующие варианты:
    - Не удается найти Python.h (*E1696: не удается открыть исходный файл "Python.h"* и/или *C1083: не удается открыть включаемый файл "Python.h", файл или каталог не существуют*): проверьте, что в свойствах проекта в разделе **C/C++ > Общие > Дополнительные каталоги включаемых файлов** верно указан путь к папке `include` вашей установки Python. См. шаг 6 в разделе [Создание основного проекта C++](#create-the-core-c-project).
    - Не удается найти библиотеки Python. Убедитесь, что путь **C/C++ > Общие > Дополнительные каталоги библиотеки** в свойствах проекта указывает на папку `libs` установки Python. См. шаг 6 в разделе [Создание основного проекта C++](#create-the-core-c-project).
    - Ошибки компоновщика, связанные с целевой архитектурой. Измените архитектуру целевого проекта C++ в соответствии с вашей установкой Python. Например, если вы хотите использовать в проекте C++ версию Python x64, но у вас установлена версия x86, измените проект C++ для работы с версией х86.

## <a name="test-the-code-and-compare-the-results"></a>Тестирование кода и сравнение результатов

Теперь, когда библиотека DLL структурирована как расширение Python, можно ссылаться на нее из проекта Python, импортировать модуль и использовать его методы.

### <a name="make-the-dll-available-to-python"></a>Предоставление доступа к библиотеке DLL для Python

Предоставить Python доступ к библиотеке DLL можно двумя способами.

Первый метод работает, если проект Python и проект C++ находятся в одном решении. В обозревателе решений щелкните правой кнопкой мыши узел **Ссылки** в проекте Python и затем выберите команду **Добавить ссылку**. В открывшемся диалоговом окне перейдите на вкладку **Проекты**, выберите проект **superfastcode** (или другой проект, с которым вы работаете) и нажмите кнопку **ОК**.

![Добавление ссылки на проект superfastcode](media/cpp-add-reference.png)

Альтернативный метод, описанный далее, предполагает установку модуля в глобальной среде Python и предоставление к нему доступа в других проектах Python. (При этом обычно требуется обновить базу данных завершения IntelliSense для этой среды в Visual Studio 2017 версии 15.5 и более ранних версий. Обновление также требуется и при извлечении модуля из среды.)

1. Если вы используете Visual Studio 2017, запустите установщик Visual Studio, выберите **Изменить**, затем **Отдельные компоненты > Компиляторы, средства сборки и среды выполнения > Набор инструментов Visual C++ 2015.3 версии 140**. Этот шаг необходим, так как Python (для Windows) сам создан с помощью Visual Studio 2015 (версия 14.0) и поэтому ожидает наличия этих средств при создании расширения одним из описанных здесь способов. (Обратите внимание, что может потребоваться установить 32-разрядную версию Python и нацелить библиотеку DLL на Win32, а не на x64.)

1. Создайте в проекте C++ файл с именем `setup.py`, щелкнув проект правой кнопкой мыши и выбрав пункт **Добавить > Новый элемент...**. Выберите тип файла "Файл C++ (.cpp)", присвойте файлу имя `setup.py` и нажмите кнопку **ОК**. (Присвоение файлу расширения `.py` позволяет Visual Studio распознавать его как файл Python несмотря на использование шаблона файла C++.) Когда файл откроется в редакторе, вставьте в него следующий код:

    ```python
    from distutils.core import setup, Extension, DEBUG

    sfc_module = Extension('superfastcode', sources = ['module.cpp'])

    setup(name = 'superfastcode', version = '1.0',
        description = 'Python Package with superfastcode C++ extension',
        ext_modules = [sfc_module]
        )
    ```

    Документация к этому скрипту приведена в статье о [создании расширений на C и C++](https://docs.python.org/3/extending/building.html) (python.org).

1. При использовании в командной строке код `setup.py` предписывает Python создать расширение с помощью набора инструментов C++ Visual Studio 2015. Откройте командную строку с повышенными привилегиями, перейдите в папку с проектом C++ (то есть в папку, содержащую `setup.py`), а затем введите следующую команду:

    ```command
    pip install .
    ```

### <a name="call-the-dll-from-python"></a>Вызов библиотеки DLL из Python

После выполнения одного из описанных выше методов можно вызвать функцию `fast_tanh` из кода Python и сравнить ее производительность с реализацией Python:

1. Добавьте приведенные ниже строки в файл `.py`, чтобы вызвать метод `fast_tanh`, экспортированный из библиотеки DLL, и получить его выходные данные.

    ```python
    from superfastcode import fast_tanh
    test(lambda d: [fast_tanh(x) for x in d], '[fast_tanh(x) for x in d]')
    ```

1. Запустите программу Python (**Отладка > Запуск без отладки** или CTRL+F5) и обратите внимание, что подпрограмма C++ выполняется в 5–20 раз быстрее, чем реализация Python. Обычно выводится следующий результат.

    ```output
    Running benchmarks with COUNT = 500000
    sequence_tanh took 1.542 seconds

    [tanh(x) for x in d] took 1.087 seconds

    [fast_tanh(x) for x in d] took 0.158 seconds
    ```

    Если команда **Запуск без отладки** недоступна, в обозревателе решений щелкните правой кнопкой мыши проект Python и выберите команду **Назначить запускаемым проектом**.

1. Попробуйте увеличить значение переменной `COUNT`, чтобы разница стала еще очевиднее. Отладочная сборка модуля C++ также выполняется медленнее, чем сборка выпуска, так как отладочная сборка менее оптимизирована и включает в себя различные проверки ошибок. Вы можете свободно переключаться между этими конфигурациями для их сравнения.

## <a name="debug-the-c-code"></a>Отладка кода C++

Visual Studio поддерживает совместную отладку кода на Python и C++.

1. Щелкните проект Python правой кнопкой мыши в обозревателе решений, выберите **Свойства**, откройте вкладку **Отладка** и выберите параметр **Отладка > Разрешить отладку машинного кода**.

    > [!Tip]
    > При включении отладки машинного кода окно вывода Python может исчезнуть сразу после завершения программы без обычной паузы с сообщением "Для продолжения нажмите любую клавишу...". Чтобы сделать паузу принудительно, добавьте параметр `-i` в поле **Запуск > Аргументы интерпретатора** на вкладке **Отладка** при включении отладки машинного кода. Этот аргумент переводит интерпретатор Python в интерактивный режим по завершении кода, после чего он ожидает нажатия клавиш CTRL+Z и ВВОД для выхода. (Кроме того, если вы не против изменения кода Python, можно добавить в конец программы операторы `import os` и `os.system("pause")`. Этот код дублирует исходный запрос с паузой.)

1. Чтобы сохранить изменения свойств, выберите пункт меню **Файл > Сохранить**.

1. На панели инструментов Visual Studio измените конфигурацию сборки на режим "Отладка".

    ![Изменение конфигурации сборки на режим "Отладка"](media/cpp-set-debug.png)

1. Так как код, как правило, выполняется в отладчике дольше, может потребоваться уменьшить значение переменной `COUNT` в файле `.py` приблизительно в пять раз (например, измените его с `500000` на `100000`).

1. В коде C++ установите точку останова в первой строке метода `tanh_impl`, а затем запустите отладчик (клавиша F5 или команда **Отладка > Начать отладку**). При вызове этого кода отладчик останавливается. Если точка останова не достигнута, проверьте, выбрана ли конфигурация отладки и сохранен ли проект (при запуске отладчика он не сохраняется автоматически).

    ![Остановка на точке останова в коде C++](media/cpp-debugging.png)

1. На этом этапе вы можете пошагово выполнять код на C++, проверять переменные и т. д. Эти возможности подробно описаны в разделе [Совместная отладка C++ и Python](debugging-mixed-mode-c-cpp-python-in-visual-studio.md).

## <a name="alternative-approaches"></a>Альтернативные подходы

Существуют различные средства для создания расширений Python, как описано в таблице ниже. Первый пункт для CPython уже рассмотрен в этой статье.

| Подход | Появление | Представители | Преимущества | Недостатки |
| --- | --- | --- | --- | --- |
| Модули расширений C/C++ для CPython | 1991 | Стандартная библиотека | [Подробная документация и учебники](https://docs.python.org/3/c-api/). Полный контроль. | Компиляция, переносимость, управление ссылками. Хорошее знание C. |
| [pybind11](https://github.com/pybind/pybind11) (рекомендуется для C++) | 2015 |  | Упрощенная библиотека заголовков для создания привязок Python к существующему коду C++. Малое число зависимостей. Совместимость с PyPy. | Новый, менее проверенный подход. Частое использование функций C++11. Краткий список поддерживаемых компиляторов (включает Visual Studio). |
| Cython (рекомендуется для C) | 2007 | [gevent](http://www.gevent.org/), [kivy](https://kivy.org/) | Аналогичен Python. Высокая степень зрелости. Высокая производительность. | Компиляция, новый синтаксис, новая цепочка инструментов. |
| [Boost.Python](https://www.boost.org/doc/libs/1_66_0/libs/python/doc/html/index.html) | 2002 | | Работает практически с любым компилятором C++. | Большой и сложный набор библиотек. Содержит много обходных путей для старых компиляторов. |
| ctypes | 2003 | [oscrypto](https://github.com/wbond/oscrypto) | Отсутствие компиляции, широкая доступность. | Обращение к структурам C и их изменение затруднено и подвержено ошибкам. |
| SWIG | 1996 | [crfsuite](http://www.chokkan.org/software/crfsuite/) | Создание привязок сразу для нескольких языков. | Чрезмерные затраты, когда единственной целью является Python. |
| cffi | 2013 | [cryptography](https://cryptography.io/en/latest/), [pypy](http://pypy.org/) | Простота интеграции, совместимость с PyPy. | Новый, менее проверенный подход. |

## <a name="see-also"></a>См. также

Полный пример из этого руководства: [python-samples-vs-cpp-extension](https://github.com/Microsoft/python-sample-vs-cpp-extension) (GitHub).