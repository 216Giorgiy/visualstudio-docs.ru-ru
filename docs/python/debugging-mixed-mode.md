---
title: "Смешанный режим отладки для Python в Visual Studio | Документы Майкрософт"
ms.custom: 
ms.date: 5/8/2017
ms.prod: visual-studio-dev15
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-python
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 4ca86a87-e254-4ab7-b3ba-a0ab99c1da93
caps.latest.revision: 1
author: kraigb
ms.author: kraigb
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: Human Translation
ms.sourcegitcommit: 90b2481b0ec4f9387fe3a2c0b733a103e8c03845
ms.openlocfilehash: 9e8ac0cbafe296223de68eb5b4f1b89680f61088
ms.contentlocale: ru-ru
ms.lasthandoff: 05/23/2017

---

# <a name="debugging-python-and-c-together"></a>Совместная отладка Python и C++

Большинство обычных отладчиков Python поддерживает только отладку кода Python. Но на практике Python используется совместно с C или C++, если требуется высокая производительность или возможность напрямую вызывать интерфейсы API платформ (например, см. раздел [Создание расширения C++ для Python](cpp-and-python.md). При загрузке проекта Python Visual Studio предоставляет интегрированную одновременную отладку в смешанном режиме для Python и машинного кода (C/C++) с объединением стеков вызовов, возможностью переключаться между Python и машинным кодом, точками останова для кода любого типа, а также возможностью видеть представления объектов Python в кадрах машинного кода и наоборот.

![Отладка в смешанном режиме](~/docs/python/media/mixed-mode-debugging.png) 

Введение в создание, тестирование и отладку модулей машинного кода С с помощью Visual Studio см. в видео [Deep Dive: Creating Native Modules](https://youtu.be/D9RlT06a1EI) (Подробный обзор. Создание собственных модулей) длительностью 9 мин 9 с, размещенном на сайте youtube.com.

> [!VIDEO https://www.youtube.com/embed/D9RlT06a1EI]

> [!Note]
> Смешанный режим отладки не доступен в Инструментах Python для Visual Studio 1.x.

## <a name="enabling-mixed-mode-debugging"></a>Включение смешанного режима отладки

1. Щелкните правой кнопкой мыши проект в обозревателе решений и выберите **Свойства**, щелкните вкладку **Отладка**, а затем установите флажок **Включить отладку машинного кода**. Включится смешанный режим для всех сеансов отладки.

    ![Включение отладки машинного кода](~/docs/python/media/mixed-mode-debugging-enable-native.png)

    > [!Tip]    
    > При включении отладки машинного кода окно вывода Python может исчезнуть сразу после завершения программы без обычной паузы с сообщением "Для продолжения нажмите любую клавишу...". Чтобы сделать паузу принудительно, добавьте параметр `-i` в поле **Запуск > Аргументы интерпретатора** на вкладке **Отладка** при включении отладки машинного кода. Это приведет к переходу интерпретатора Python в интерактивный режим по завершении кода, после чего он ожидает нажатия клавиш CTRL+Z и ВВОД для выхода.

1. При присоединении к существующему процессу отладчика смешанного режима (**Отладка > Присоединиться к процессу...**) нажмите кнопку **Выбрать...**, чтобы открыть диалоговое окно **Выбор типа кода**, установите переключатель **Выполнять отладку кода следующих типов** и выберите в списке **Машинный код** и **Python**.

    ![Выбор типов кода Python и машинного кода](~/docs/python/media/mixed-mode-debugging-code-type.png)

    Параметры типа кода являются постоянными, поэтому, если позже вам понадобится отключить отладку в смешанном режиме при присоединении к другому процессу, необходимо повторить эти действия и очистить тип кода Python.

    Можно выбрать другие типы кода в дополнение к **машинному коду** или вместо него. Например, если CPython размещается в управляемом приложении, которое, в свою очередь, использует собственный модуль расширения, и необходимо выполнить отладку всех трех компонентов, можно одновременно выбрать **Python**, **Машинный код** и "Управляемый код" для единой отладки, в том числе использования объединенных стеков вызовов и переключения между всеми тремя средами выполнения.

1. Когда вы впервые приступите к отладке в смешанном режиме, может отобразится диалоговое окно **Необходимые символы Python**. Дополнительные сведения см. в статье [Установка отладочных символов для интерпретаторов Python](debugging-symbols-for-mixed-mode.md). Символы для любой среды Python необходимо установить только один раз. Обратите внимание, что при установке поддержки Python с помощью установщика Visual Studio 2017 символы включаются автоматически.

1. Вам также может потребоваться иметь под рукой исходный код Python. Для стандартного Python его можно получить на странице [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/). Скачайте подходящий архив для своей версии и извлеките его в папку. Указывайте Visual Studio на конкретные файлы в этой папке при отображении соответствующего запроса.

> [!Note]
> Смешанный режим отладки, как описано здесь, включается только в том случае, если в Visual Studio загружен проект Python. Этот проект определяет режим отладки в Visual Studio, что делает доступным параметр смешанного режима. Если, однако, загружен проект C++ (как и при [внедрении Python в другое приложение, как описано на python.org](https://docs.python.org/3/extending/embedding.html)), то Visual Studio использует собственный отладчик C++, который не поддерживает отладку в смешанном режиме.
>
> В этом случае запустите проект C++ без отладки (выберите **Отладка > Запуск без отладки** или нажмите клавиши CTRL + F5) и затем выберите команду **Отладка > Присоединение к процессу**. В появившемся диалоговом окне выберите соответствующий процесс, затем нажмите кнопку **Выбрать**, чтобы открыть диалоговое окно **Выбор типа кода**, в котором можно выбрать Python, как показано ниже. Нажмите **ОК**, чтобы закрыть диалоговое окно, затем нажмите **Присоединить** для запуска отладчика. Обратите внимание, что может потребоваться добавить соответствующую задержку в приложение C++, чтобы убедиться в том, что Python, отладку которого необходимо выполнить, не будет вызван до того, как можно будет подсоединить отладчик.
>
> ![Выбор Python в качестве типа отладки при подсоединении отладчика](~/docs/python/media/mixed-mode-debugging-attach-type.png)

## <a name="mixed-mode-specific-features"></a>Функции, характерные для смешанного режима

- [Объединенный стек вызовов](#combined-call-stack)
- [Переход между кодом Python и машинным кодом](#stepping-between-python-and-native-code)
- [Представление значений PyObject в машинном коде](#pyobject-values-view-in-native-code)
- [Представление значений машинного кода в коде Python](#native-values-view-in-python-code)

### <a name="combined-call-stack"></a>Объединенный стек вызовов

В окне стека вызовов представлены чередующиеся кадры стеков машинного кода и Python с помеченными переходами.

![Объединенный стек вызовов](~/docs/python/media/mixed-mode-debugging-call-stack.png)

> [!Note]
> Переходы отображаются в виде внешнего кода без указания направления перехода, если задан параметр **Инструменты > Параметры > Отладка > Общие > Включить только мой код**.

Если дважды щелкнуть какой-либо кадр вызова, он станет активным и откроется соответствующий исходный код, если это возможно. Если исходный код недоступен, кадр все равно становится активным и можно проверить локальные переменные.

### <a name="stepping-between-python-and-native-code"></a>Переход между кодом Python и машинным кодом

При использовании команд "Шаг с заходом" (F11) или "Шаг с выходом" (SHIFT+F11) отладчик в смешанном режиме правильно обрабатывает изменения типов кода. Например, когда Python вызывает метод типа, который реализован на языке C, переход с заходом в вызов этого метода останавливается в начале собственной функции, реализующей метод. Аналогичным образом, когда машинный код вызывает функцию API Python, вызывается код Python. Например, шаг с заходом в `PyObject_CallObject` значения функции, которая была изначально определена на языке Python, остановится в начале функции Python. Шаг с заходом из Python в машинный код также поддерживается для функций машинного кода, которые вызываются из Python с помощью модуля [ctypes](http://docs.python.org/3/library/ctypes.html).

### <a name="pyobject-values-view-in-native-code"></a>Представление значений PyObject в машинном коде

Если кадр машинного кода (C или C++) активен, его локальные переменные отображаются в окне локальных переменных отладчика. В собственных модулях расширения Python многие из них относятся к типу `PyObject` (который является typedef для `_object`) или к другим базовым типам Python (см. список ниже). При отладке в смешанном режиме эти значения представляют дополнительный дочерний узел с меткой "Представление Python". При развертывании этот узел отображает представление переменной Python, как и в случае, когда локальная переменная, которая ссылается на тот же объект, присутствует в кадре Python. Дочерние узлы данного узла можно изменять.

![Представление Python](~/docs/python/media/mixed-mode-debugging-python-view.png)

Чтобы отключить эту функцию, щелкните правой кнопкой мыши в окне локальных переменных и снимите флажок для параметра меню **Python > Show Python View Nodes** (Показать узлы представления Python):

![Включение представления Python](~/docs/python/media/mixed-mode-debugging-enable-python-view.png)

Типы C, для которых отображаются узлы представления Python (если включено).

- `PyObject `
- `PyVarObject`
- `PyTypeObject`
- `PyByteArrayObject`
- `PyBytesObject`
- `PyTupleObject`
- `PyListObject`
- `PyDictObject`
- `PySetObject`
- `PyIntObject`
- `PyLongObject`
- `PyFloatObject`
- `PyStringObject`
- `PyUnicodeObject`

Для типов, которые вы создаете самостоятельно, представление Python не отображается автоматически. При создании расширений для Python 3.x обычно это не проблема, так как любой объект в конечном итоге имеет поле `ob_base` одного из типов, перечисленных выше, вследствие чего отображается представление Python. 

Для Python 2.x каждый тип объектов обычно объявляет заголовок как коллекцию встроенных полей. При этом отсутствует связь между создаваемыми пользовательскими типами и `PyObject` на уровне системы типов в коде C или C++. Чтобы включить узлы представления Python для таких пользовательских типов, измените `PythonDkm.natvis` в [каталоге установки инструментов Python](installation.md#install-locations) и просто добавьте другой элемент в XML для структуры C или класса C++.

В качестве альтернативного (и лучшего) варианта можно следовать [PEP 3123](http://www.python.org/dev/peps/pep-3123/) и использовать явное поле `PyObject ob_base;` вместо `PyObject_HEAD`, хотя это может привести к проблемам с обратной совместимостью.


### <a name="native-values-view-in-python-code"></a>Представление значений машинного кода в коде Python

Как и в предыдущем разделе, можно включить представление C++ для значений машинного кода в окне локальных переменных при активном кадре Python. Эта функция отключена по умолчанию. Чтобы включить ее, щелкните правой кнопкой мыши в окне локальных значений и установите флажок для параметра меню **Python > Show C++ View Nodes** (Показать узлы представления C++).

![Включение представления C++](~/docs/python/media/mixed-mode-debugging-enable-cpp-view.png)

Узел представления C++ отображает базовую структуру C/C++ для значения, идентичную той, которую вы видите в кадре машинного кода. Например, он отображает экземпляр `_longobject` (для которого `PyLongObject` является определением типа typedef) для длинного целого числа Python и пытается определить типы собственных классов, созданных вручную. Дочерние узлы данного узла можно изменять.

![Представление C++](~/docs/python/media/mixed-mode-debugging-cpp-view.png)

Если дочернее поле объекта имеет тип `PyObject` или один из других поддерживаемых типов, он будет иметь узел представления Python (если включен), что позволит перемещаться по графам объекта, где ссылки не предоставляются непосредственно в Python.

В отличие от узлов представления Python, использующих метаданные объекта Python для определения типа объекта, такого же надежного механизма для представления C++ не существует. В сущности, для заданного значения Python (для ссылки `PyObject`) невозможно точно определить резервную структуру C/C++. Отладчик смешанного режима пытается угадать этот тип, просматривая различные поля типа объекта (например, на `PyTypeObject` ссылается его поле `ob_type`), которые имеют типы указателей функций. Если один из этих указателей ссылается на функцию, которая может быть разрешена, а функция имеет параметр `self` с типом, более точным, чем `PyObject*`, тогда предполагается, что этот тип является резервным. Например, если `ob_type->tp_init` данного объекта указывает на следующую функцию:

```c
static int FobObject_init(FobObject* self, PyObject* args, PyObject* kwds) {
    return 0;
}
```

То отладчик может правильно предположить, что типом C объекта является `FobObject`. Если исходя из `tp_init` не удается определить тип более точно, отладчик переходит к другим полям. Если не удается определить тип на основе любого из этих полей, узел представления C++ представляет объект как экземпляр `PyObject`.

Чтобы всегда получать полезное представление пользовательских типов, рекомендуется зарегистрировать по крайней мере одну специальную функцию при регистрации типа и использовать строго типизированный параметр `self`. Большинство типов соответствует этому требованию естественным образом. Если это не так, для этой цели обычно лучше всего использовать запись `tp_init`. Фиктивная реализация `tp_init` для типа, которая присутствует только для того, чтобы определить тип отладки, сразу же возвращает ноль, как в приведенном выше примере.

## <a name="differences-from-standard-python-debugging"></a>Отличия от стандартной отладки Python

Отладчик смешанного режима отличается от [стандартного отладчика Python](debugging.md) тем, что в нем представлены некоторые дополнительные функции, но отсутствуют определенные возможности, связанные с Python.

- Неподдерживаемые функции: условные точки останова, интерактивное окно отладки и удаленная отладка между различными платформами.
- Окно интерпретации: доступно, но с ограниченным набором функциональных возможностей, включая все перечисленные здесь ограничения.
- Поддерживаемые версии Python: только CPython 2.7 и 3.3+.
- Оболочка Visual Studio. При использовании Python с оболочкой Visual Studio (например, при выполнении установки с помощью интегрированного средства установки) в Visual Studio не откроются проекты C++, а редактирование файлов C++ будет ограничено возможностями простого текстового редактора. В оболочке полностью поддерживается отладка C/C++ и отладка в смешанном режиме, что позволяет работать с исходным кодом, переходить к машинному коду и вычислять выражения C++ в окнах отладчика.
- Просмотр и развертывание объектов. При просмотре объектов Python в окнах локальных и контрольных значений отладчика смешанного режима будет отображаться только структура объектов. Свойства не вычисляются автоматически, и вычисляемые атрибуты не отображаются. Для коллекций будут отображаться только элементы встроенных типов (`tuple`, `list`, `dict`, `set`). Пользовательские коллекции не визуализируются в виде коллекций, если они наследуются от коллекции встроенного типа.
- Вычисление выражений: см. сведения ниже.

### <a name="expression-evaluation"></a>Вычисление выражений

Стандартный отладчик Python позволяет вычислять произвольные выражения Python в окнах контрольных значений и интерпретации отладчика при приостановке отладки в любой точке кода, если она не заблокирована с помощью операции ввода-вывода или другого аналогичного системного вызова. В смешанном режиме отладки произвольные выражения можно вычислить только при остановке в коде Python после точки останова или при шаге с заходом в код и только в потоке, в котором были выполнены вышеуказанные операции.

При остановке в машинном коде или в коде Python, где вышеуказанные условия не применяются (например, после выполнения шага с выходом или в другом потоке), вычисление выражений ограничено доступом к локальным и глобальным переменным в рамках текущего выбранного кадра, а также доступом к их полям и индексированию коллекций встроенных типов с литералами. Например, следующее выражение может вычисляться в любом контексте (при условии, что все идентификаторы ссылаются на существующие переменные и поля соответствующих типов).

```python
foo.bar[0].baz['key']
```

Отладчик смешанного режима разрешает такие выражения по-разному. Все операции доступа к элементам ищут только поля, которые непосредственно принадлежат объекту (например, запись в его `__dict__` или `__slots__` либо поле собственной структуры, которое предоставляется Python с помощью `tp_members`), и игнорируют методы `__getattr__`, `__getattribute__` или логику дескриптора. Аналогичным образом все операции индексирования игнорируют `__getitem__` и получают доступ к внутренним структурам данных коллекций напрямую.

Для обеспечения согласованности такая схема разрешения используется для всех выражений, которые соответствуют ограничениям вычисления выражений вне зависимости от того, разрешены ли произвольные выражения в текущей точке остановки. Чтобы обеспечить правильную семантику Python, когда доступен полнофункциональный вычислитель, заключите выражение в скобки.

```python
(foo.bar[0].baz['key'])
```
