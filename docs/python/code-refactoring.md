---
title: "Рефакторинг кода в Инструментах Python для Visual Studio | Документация Майкрософт"
ms.custom: 
ms.date: 3/7/2017
ms.prod: visual-studio-dev15
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-python
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 76ebcb29-72d1-4958-9a63-8984c03d5c22
caps.latest.revision: 1
author: kraigb
ms.author: kraigb
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Human Translation
ms.sourcegitcommit: b0d84db6a16861fb9554af2a644423f906784748
ms.openlocfilehash: dc51f41277c91288c0812cb5c22f48d827d741aa
ms.lasthandoff: 03/07/2017

---

# <a name="refactoring-python-code"></a>Рефакторинг кода Python

Инструменты Python для Visual Studio (PTVS) предлагают несколько команд для автоматического преобразования и очистки исходного кода.

- [Переименовать](#rename) — переименовывает указанный класс, метод или переменную.
- [Извлечение метода](#extract-method) — создает новый метод из выбранного фрагмента кода.
- [Добавление импорта](#add-import) — предоставляет смарт-тег для добавления отсутствующего импорта.
- [Удаление неиспользуемых инструкций import](#remove-imports) — удаляет неиспользуемые операции импорта.

<a name="rename-variable"</a>
## <a name="rename"></a>Переименовать

1. Щелкните правой кнопкой мыши идентификатор, который нужно переименовать, и выберите команду **Переименовать** или поместите курсор внутрь этого идентификатора и выберите команду меню **Правка > Рефакторинг > Переименовать...** или нажмите клавишу F2.
1. В окне **Переименовать** введите новое имя для выбранного идентификатора и нажмите кнопку **ОК**.

  ![Переименовать. Запрос на ввод нового имени идентификатора](media/code-refactor-rename-1.png)

1. В следующем диалоговом окне выберите файлы и экземпляры, к которым следует применить переименование. Здесь можно выбрать любой отдельный экземпляр для предварительного просмотра конкретных изменений:

  ![Переименовать. Диалоговое окно для выбора мест применения изменений](media/code-refactor-rename-2.png)

1. Нажмите **Применить**, чтобы внести изменения в файлы исходного кода. Это действие можно отменить.

## <a name="extract-method"></a>Извлечение метода

1. Выберите строки кода или выражение, из которых хотите создать отдельный метод.
1. Выберите команду меню **Правка > Рефакторинг > Извлечение метода...** или последовательно нажмите клавиши Ctrl+R, M.
1. В открывшемся диалоговом окне введите имя для нового метода, укажите место для его создания и выберите переменные для закрытия. Переменные, которые не будут выбраны для закрытия, преобразуются в аргументы метода:

  ![Диалоговое окно извлечения метода](media/code-refactor-extract-method-1.png)

1. Нажмите кнопку **ОК**, и код будет изменен соответствующим образом:

  ![Результат извлечения метода](media/code-refactor-extract-method-2.png)

## <a name="add-import"></a>Добавление импорта

Когда курсор наводится на идентификатор, для которого отсутствует информация о типе, PTVS предлагает смарт-тег (значок лампочки слева от кода). Если его щелкнуть, можно выполнить команды для добавления необходимой инструкции `import` или `from ... import`:

![Смарт-тег для добавления импорта](media/code-refactor-add-import-1.png)

Завершения `import` предлагаются для пакетов и модулей верхнего уровня, определенных в текущем проекте или стандартных библиотеках. Завершения `from ... import` предлагаются для вложенных модулей и вложенных пакетов, а также для членов модулей. В них учитываются функции, классы и экспортированные данные. Если вы выберете любой из вариантов, будет добавлена соответствующая инструкция в верхней части файла, сразу после других инструкций import или внутри существующей инструкции `from ... import`, если указанный модуль уже импортирован.

![Результат добавления импорта](media/code-refactor-add-import-2.png)

PTVS старается отфильтровать те члены, которые не определены в самом модуле, например модули, импортированные в другой модуль, но не являющиеся дочерними для модуля, выполняющего импорт. Например, во многих модулях используется `import sys` вместо `from xyz import sys`, поэтому PTVS не предлагает вариант завершения для импорта `sys` из других модулей, даже если в них нет члена `__all__`, исключающего `sys`.

Аналогичным образом PTVS фильтрует функции, импортированные из других модулей или из встроенного пространства имен. Например, если модуль импортирует функцию `settrace` из модуля `sys`, теоретически вы вправе импортировать ее из этого модуля. Но гораздо лучше напрямую использовать `import settrace from sys`, поэтому PTVS предлагает добавить именно такую инструкцию.

И наконец, если некоторая сущность исключена из предложений по описанным выше правилам, но для нее существуют другие значения, которые обычно следует включить в список (например, если в модуле этому имени присваивается значение), PTVS все равно исключает импорт из предложений. Такое поведение основано на предположении, что рассматриваемая сущность не должна импортироваться, поскольку определена в другом модуле. При этом дополнительное назначение считается фиктивным и не подлежащим экспорту.

<a name="remove-imports"</a>
## <a name="remove-unused-imports"></a>Удаление неиспользуемых инструкций import

Нередко получается так, что в коде сохраняются инструкции `import` для модулей, которые вообще не используются. PTVS анализирует код и может автоматически определить, нужна ли в нем инструкция `import`, изучив использование импортированного имени во всех областях ниже той, где встречается эта инструкция.

Щелкните правой кнопкой мыши в любом месте редактора и выберите команду **Удалить инструкции import**, которая позволяет выполнить удаление **из всех областей** или только **из текущей области**:

![Меню удаления инструкций import](media/code-refactor-remove-imports-1.png)

PTVS внесет соответствующие изменения в код:

![Результат удаления инструкций import](media/code-refactor-remove-imports-2.png)

Обратите внимание, что PTVS не учитывает поток управления. Если имя указано в коде до инструкции `import`, это все равно будет рассматриваться как использование имени. Кроме того, PTVS игнорирует все операции импорта `from __future__`, а также выполняемые внутри определения класса и из инструкций `from ... import *`.
