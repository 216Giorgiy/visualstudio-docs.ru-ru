---
title: Переопределение и расширение созданных классов | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.topic: conceptual
helpviewer_keywords:
- Domain-Specific Language, providing overridable classes
author: gewarren
ms.author: gewarren
manager: douge
ms.workload:
- multiple
ms.technology: vs-ide-modeling
ms.openlocfilehash: 80dd80a88b0244008efde9b10a1706ff18ba6136
ms.sourcegitcommit: 6a9d5bd75e50947659fd6c837111a6a547884e2a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="overriding-and-extending-the-generated-classes"></a>Переопределение и расширение созданных классов
Определение DSL — это платформа, на которой можно построить мощный набор средств, которые основаны на доменного языка. Многие модули и процесса можно сделать путем переопределения и расширение классов, которые создаются из определения DSL. Эти классы включают не только доменные классы, явно определенных в схема определения DSL, но также и другие классы, определяющие области элементов, обозреватель, сериализации и т. д.  
  
## <a name="extensibility-mechanisms"></a>Механизмы расширяемости  
 Несколько механизмов, позволяющих позволяют расширить созданный код.  
  
### <a name="overriding-methods-in-a-partial-class"></a>Переопределение методов в разделяемом классе  
 Определения разделяемого класса позволяет определять класс определен в нескольких местах. Это позволяет отделить от самостоятельном написании кода, созданного кода. В коде, созданных вручную можно переопределить классов, унаследованных в созданном коде.  
  
 Например, если в определении DSL определить класс с именем домена `Book`, можно написать пользовательский код, который добавляет методы переопределения:  
  
 `public partial class Book`  
  
 `{`  
  
 `protected override void OnDeleting()`  
  
 `{`  
  
 `MessageBox.Show("Deleting book " + this.Title);`  
  
 `base.OnDeleting();`  
  
 `} }`  
  
> [!NOTE]
>  Для переопределения методов в созданном классе, всегда писать код в файле, который отделяется от созданные файлы. Как правило файл хранится в папке, которая называется CustomCode. Если изменить созданный код, они будут потеряны при повторном создании кода из определения DSL.  
  
 Чтобы узнать, какие методы можно переопределить, введите **переопределить** в классе, за которыми следует пробел. Подсказка IntelliSense поможет определить, какие методы могут быть переопределены.  
  
### <a name="double-derived-classes"></a>Классы, производные от типа Double  
 Большинство методов в созданные классы наследуются от фиксированный набор классы в пространствах имен моделирования. Тем не менее некоторые методы определяются в созданном коде. Как правило это означает, что не может переопределить их; нельзя переопределить в одном классе частичных методов, определенных в другом частичном определении того же класса.  
  
 Тем не менее, эти методы можно переопределить, задав **приводит к возникновению ошибки производного типа Double** флаг для класса домена. Это причины два классы для создаваемого, были другого абстрактного базового класса. Все определения методов и свойств, в базовом классе, и только конструктор находится в производном классе.  
  
 Например, в образце Library.dsl `CirculationBook` класс домена имеет `Generates``Double Derived` свойство `true`. Созданный код для этого класса домена содержит два класса:  
  
-   `CirculationBookBase`, который является абстрактным и которая содержит все методы и свойства.  
  
-   `CirculationBook`, который является производным от `CirculationBookBase`. Он пуст, за исключением его конструкторов.  
  
 Чтобы переопределить любой метод, создать частичное определение класса, производного например `CirculationBook`. Можно переопределить созданные методы и методы, унаследованные от платформа моделирования.  
  
 Этот метод можно использовать со всеми типами элемента, включая элементы модели, связи, фигур, схем и соединителей. Кроме того, можно переопределить методы другими классами. Некоторые созданные классы, таких как ToolboxHelper всегда производного типа double.  
  
### <a name="custom-constructors"></a>Пользовательские конструкторы  
 Конструктор не может переопределить. Даже в классах, производных от типа double конструктор должен быть в производном классе.  
  
 Если вы хотите предоставить собственный конструктор, это можно сделать, задав `Has Custom Constructor` для класса домена в определения DSL. При нажатии кнопки **преобразовать все шаблоны**, созданный код не будет содержать конструктор для этого класса. Сюда входят вызов конструктора отсутствует. При построении решения в результате отчет об ошибке. Дважды щелкните для просмотра комментария в созданном коде, объясняется, какие сведения необходимо предоставить отчет об ошибке.  
  
 Написать частичное определение класса в файле, который отделен от созданных файлов и предоставляют конструктор.  
  
### <a name="flagged-extension-points"></a>Помеченные точек расширения  
 Точки расширения, помеченные — это часть определения DSL, где можно задать свойство или флажок, чтобы указать, что обеспечит пользовательский метод. Пользовательские конструкторы являются одним из примеров. Другие примеры включают параметр `Kind` свойства домена, вычисляемые или пользовательского хранилища или параметр **— настраиваемый** флаг в построитель подключения.  
  
 В каждом случае если задан флаг и пересоздать код, приведет к ошибке построения. Дважды щелкните ошибку, чтобы выяснить комментарий, объясняющий, вы должны предоставить.  
  
### <a name="rules"></a>Правила  
 Диспетчер транзакций можно задать правил, которые выполняются до завершения транзакции, в котором указанного события, например об изменениях в свойстве. Правила обычно используются для поддержания synchronism между разными элементами в хранилище. Например правила используются для убедитесь, что схема отображает текущее состояние модели.  
  
 Правила определяются на основе каждого класса, чтобы не требовалось имеется код, который регистрирует правила для каждого объекта. Дополнительные сведения см. в разделе [распространение изменений в модели правил](../modeling/rules-propagate-changes-within-the-model.md).  
  
### <a name="store-events"></a>События хранилища  
 Хранилище моделирования предоставляет механизм событий, которые можно использовать для прослушивания определенного типа изменения в хранилище, включая добавление и удаление элементов, изменения значений свойств и т. д. Обработчики событий вызываются после закрытия транзакции, в котором были внесены изменения. Как правило эти события используются для обновления ресурсов за пределами хранилища.  
  
### <a name="net-events"></a>События .NET  
 Можно подписаться на фигур некоторые события. Например может прослушивать мышью в фигуры. Необходимо написать код, который подписывается на событие для каждого объекта. Этот код может быть написан переопределение InitializeInstanceResources().  
  
 Некоторые события создаются для ShapeFields, который используется для отрисовки декораторов в фигуру. Пример см. в разделе [как: перехватывать нажатие фигуры или Decorator](../modeling/how-to-intercept-a-click-on-a-shape-or-decorator.md).  
  
 Обычно эти события не возникают внутри транзакции. Следует создать транзакцию, если вы хотите внести изменения в хранилище.