---
title: "Практическое руководство. Обновление модели с помощью транзакций | Microsoft Docs"
ms.custom: ""
ms.date: "12/15/2016"
ms.prod: "visual-studio-tfs-dev14"
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: e24436a5-7f97-401b-bc83-20d188d10d5b
caps.latest.revision: 7
caps.handback.revision: 7
author: "alancameronwills"
ms.author: "awills"
manager: "douge"
---
# Практическое руководство. Обновление модели с помощью транзакций
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

Транзакции гарантируют, что изменения, внесенные в хранилище рассматриваются как группа.  Изменения, группирует можно зафиксировать или откатить как единый блок.  
  
 Если программный код изменяет добавляет или удаляет все элементы в хранилище внутри [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] Пакет SDK для визуализации данных и моделирования, он должен сделать внутри транзакции.  Должен быть активным экземпляр <xref:Microsoft.VisualStudio.Modeling.Transaction> связанные с хранилищем, если изменение происходит.  Это применяется ко всем элементам модели связей, фигурам, схемам и их свойствами.  
  
 Механизм транзакции помогает избежать несогласованные состояния.  Когда ошибка происходит во время транзакции, то все изменения откаченны.  Если пользователь выполняет команду отката, то каждая последняя транзакция рассматривается как один шаг.  Пользователь не может отменить части последнего изменения, если явно не будет помещать их в отдельной транзакции.  
  
## Открывать транзакцию  
 Самый удобный метод управления транзакция с a `using` выписка, заключенная в a  `try...catch` оператор:  
  
```  
Store store; ...  
try  
{  
  using (Transaction transaction =  
    store.TransactionManager.BeginTransaction("update model"))  
    // Outermost transaction must always have a name.  
  {  
    // Make several changes in Store:  
    Person p = new Person(store);  
    p.FamilyTreeModel = familyTree;  
    p.Name = "Edward VI";  
    // end of changes to Store  
  
    transaction.Commit(); // Don't forget this!  
  } // transaction disposed here  
}  
catch (Exception ex)  
{  
  // If an exception occurs, the Store will be   
  // rolled back to its previous state.  
}  
```  
  
 Если исключение, которое предотвращает выпускные экзамены `Commit()`происходит во время изменения к своему хранилищу будет сброшен предыдущее состояние.  Это позволяет убедиться в том, что ошибки не оставляют модель в несогласованном состоянии.  
  
 Можно выполнить любое количество изменений в пределах одной транзакции.  Можно открывать новые транзакции внутри активной транзакции.  Вложенные транзакции должны зафиксировать или откатить, содержащий транзакцию до завершения.  Дополнительные сведения см. в разделе пример <xref:Microsoft.VisualStudio.Modeling.Transaction.TransactionDepth%2A> свойство.  
  
 Сделать свою постоянное изменений, `Commit` транзакция, прежде чем она будет освобождается.  При возникновении исключения, которое не перехватывается в транзакции, хранилище будет сброшен в состояние перед изменениями.  
  
## Откатить транзакцию  
 Чтобы убедиться, что хранилище остается в или отменить изменения в состояние до транзакции можно использовать любую из этих тактик:  
  
1.  Вызывайте исключение, которое не перехватывается в пределах области транзакции.  
  
2.  Явно откатите транзакции:  
  
    ```  
    this.Store.TransactionManager.CurrentTransaction.Rollback();  
    ```  
  
## Транзакции не влияют на объекты Non\-Магазина  
 Только транзакции управляет состоянием хранилища.  Они не могут отмены частично выполненные изменения к внешним элементам, таким как файлы, базы данных или объекты, объявляли с обычными типами за пределами определения DSL.  
  
 Если исключение может оставить то изменение сбивчивым с хранилищем, необходимо работать с выбранной возможностью в обработчике исключений.  Один из способов проверить, что внешние ресурсы остаются синхронизированными с объектами хранилища подключить каждый внешний объект к элементу в\-магазина с помощью обработчиков событий.  Дополнительные сведения см. в разделе [Обработчики событий распространяют изменения за пределы модели](../modeling/event-handlers-propagate-changes-outside-the-model.md).  
  
## Правила возникают в конце транзакции  
 В конце транзакции, прежде чем транзакция освобождается, предоставляются правила вложенных элементов в хранилище.  Каждое правило метод, который применяется к элементу модели, который был изменен.  Например, существует фиксируют "вверх" правила, которые обновляют состояние формы при ее элемент модели был изменен и создать фигуру, когда элемент модели был создан.  Не определен порядок работы цилиндров.  Изменение, сделанное правилом может создать другое правило.  
  
 Можно определить собственные правила.  Дополнительные сведения о правилах см. в разделе [Реагирование на изменения и их распространение](../modeling/responding-to-and-propagating-changes.md).  
  
 Правила не возникают после отката, повтор или команду отката.  
  
## Контекст транзакции  
 Каждая транзакция имеет словарь, в котором можно хранить любое сведения:  
  
 `store.TransactionManager`  
  
 `.CurrentTransaction.TopLevelTransaction`  
  
 `.Context.Add(aKey, aValue);`  
  
 Это особенно полезно для передачи сведений между правилами.  
  
## Состояние транзакции  
 В некоторых случаях необходимо избежать передать изменения, если изменение вызвано отменить или повторить транзакцию.  Это может произойти, например, при написании обработчика, то значения свойств, который может обновить другого значения в хранилище.  Поскольку операция отката сбросить все значения в хранилище к своим предыдущим состояниям нет необходимости вычислять обновленные значения.  Используйте этот код:  
  
```  
if (!this.Store.InUndoRedoOrRollback) {...}  
```  
  
 Правила могут создать при загрузке из хранилища исходного файла.  Чтобы избежать реагировать на эти изменения следует использовать:  
  
```  
if (!this.Store.InSerializationTransaction) {...}  
  
```