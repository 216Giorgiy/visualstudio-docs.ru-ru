---
title: "Определение политики блокировки для создания сегментов, доступных только для чтения | Microsoft Docs"
ms.custom: ""
ms.date: "12/15/2016"
ms.prod: "visual-studio-tfs-dev14"
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: fa549c71-2bf6-4b08-b7b2-7756dd6f1dc8
caps.latest.revision: 12
caps.handback.revision: 12
author: "alancameronwills"
ms.author: "awills"
manager: "douge"
---
# Определение политики блокировки для создания сегментов, доступных только для чтения
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

API непреложности  [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] Пакет SDK для визуализации данных и моделирования позволяет программа к части блокировки или все модели доменного языка \(DSL\) так, что его можно читать, но не изменять.  Этот параметр только для чтения может использоваться, например, чтобы пользователь мог запросить, что коллегаы аннотировали и рассмотрели модели DSL, но может не допускать внесения их в исходные. изменение  
  
 Кроме того, в качестве создателя DSL, можно указать a *блокирование политику.* Блокируя политика определяет, которая блокирует разрешено, не разрешено и обязательно.  Например, если можно публиковать DSL, ободрить сторонним разработчикам расширять его с новыми командами.  Однако можно также использовать блокируя политику, чтобы предотвратить их править только для чтения состояние определенных частей модели.  
  
> [!NOTE]
>  Блокируя политика может избежаться с помощью отражения.  Она предоставляет ясную границу для сторонних разработчиков, но не предоставляет усиленную безопасность.  
  
 Дополнительные сведения и примеры доступны на [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] [Пакет SDK для визуализации данных и моделирования](http://go.microsoft.com/fwlink/?LinkId=186128) Веб\-сайта.  
  
## Установка и получение блокируют  
 Можно установить блокируете в хранилище, на шаге или на отдельном элементе.  Например, это выписка приведет к тому, что элемент модели не удаляются, а также предотвратит ее свойства с изменением:  
  
```  
using Microsoft.VisualStudio.Modeling.Immutability; ...  
element.SetLocks(Locks.Delete | Locks.Property);  
```  
  
 Другие значения могут использоваться блокировки для предотвращения изменения в связях создании элемента, движении между разделами и переупорядочения ссылки в роли.  
  
 Блокирует применяются и к действиям пользователя и идентификатору программы.  Если программный код пытается сделать, то изменение `InvalidOperationException` вызывает исключение.  Блокирует пропустить в откате или повторить операцию.  
  
 Можно узнать, имеет ли элемент все блокировки в заданном наборе с помощью `IsLocked(Locks)` и можно получить текущий набор блокируете на элементе с помощью  `GetLocks()`.  
  
 Можно установить кратковременную блокировку производится без использования транзакции.  База данных блокировки не является частью хранилища.  Если установить блокировку в ответ на изменение значения в хранилище, например в OnValueChanged необходимо разрешить изменения, которые являются частью операции отката.  
  
 Эти методы методы расширения, определенные в <xref:Microsoft.VisualStudio.Modeling.Immutability> пространство имен.  
  
### Блокирует в секциях и сохраняет  
 Блокирует также может применяться к разделам и хранилищу.  Блокировку, установленную в разделе применяется ко всем элементам в области.  Поэтому, например, следующий оператор приведет к тому, что все элементы в разделе из быть удалены, независимо от их состояния собственного блокирует.  Однако другое блокирует как `Locks.Property` может все еще быть задано в отдельных элементах.  
  
```  
partition.SetLocks(Locks.Delete);  
```  
  
 Блокировку, установленную в хранилище применяется ко всем по элементам ", независимо от параметров этой блокировки в секциях и элементах.  
  
### Использование блокирует  
 Блокируете можно использовать для ссылки схемы, как в следующих примерах:  
  
-   Запретить изменения на все элементы и отношения за исключением тех, которые представляют комментарии.  Это позволяет пользователям аннотации модель, не изменяя его.  
  
-   Запретить изменения в разделе по умолчанию, но разрешить изменения в разделе схемы.  Пользователь может изменить порядок схему, но не может изменить базовую модель.  
  
-   Не допускать внесения изменений в хранилище за исключением группы в составе пользователи, которые зарегистрированы в отдельной базе данных.  Для других пользователей, схема и модель только для чтения.  
  
-   Запретить изменения в модель схемы, если логическое свойство имеет значение true.  Введите команду меню изменить свойство.  Это позволяет обеспечить пользователям, которые они не выполняют изменения случайным образом.  
  
-   Запретить добавление и удаление элементов и связей, определенных классов, но разрешить изменения свойства.  Это предоставляет пользователям с фиксированной формой, в которой они могут занимать свойства.  
  
## Значения блокировки  
 Блокирует может быть установлены в хранилище, разделе или отдельного ModelElement.  Блокирует a `Flags` перечисление: можно объединять свои значения, используя "&#124;".  
  
-   Блокирует ModelElement всегда включайте блокирует его секции.  
  
-   Блокирует раздела всегда включайте блокирует хранилища.  
  
 Нельзя установить блокировку на шаге или сохранить и одновременно блокировать блокировку на отдельном элементе.  
  
|Значение|Если `IsLocked(Value)` true|  
|--------------|---------------------------------|  
|None|Без ограничений.|  
|Свойство.|Свойства домена элементов нельзя изменить.  Это не применяется к свойствам, которые создаются роли доменного класса в связи.|  
|Add|Новые элементы и ссылки нельзя создать в разделе или хранилище.<br /><br /> Неприменимо к `ModelElement`.|  
|Переместить|Элемент нельзя перемещать между разделами, если `element.IsLocked(Move)` значение true, если  `targetPartition.IsLocked(Move)` \- true.|  
|Delete|Элемент нельзя удалять, если эта блокировка сам на элемент, набор или на любом элементе, к которым удаление распространитьTfо мере, как внедренные элементы и фигуры.<br /><br /> Можно использовать `element.CanDelete()` определить, является ли элемент может быть удален.|  
|Переупорядочить|Упорядочение ссылок на roleplayer нельзя изменить.|  
|RolePlayer|Набор ссылок, источником для этого элемента нельзя изменить.  Например, нельзя внедрять новые элементы под этим элементом.  Это не влияет на связи для которых данный элемент целевой объект.<br /><br /> Если этот элемент ссылку, то его источник и целевой объект не затрагиваются.|  
|Все|Побитовый оператор или других значений.|  
  
## Блокирование политики  
 Как создатель DSL, можно указать a *блокирование политика*.  Блокируя политика умеряет операцию SetLocks \(\), что позволяет предотвратить определенное блокируете из быть установлены или mandate, что на блокирует быть заданы.  Обычно использовался бы блокируя политику, чтобы препятствовать группированию по этому атрибуту пользователи или разработчики от случайно contravening предполагаемую использование DSL, аналогичным образом, что можно объявить переменную `private`.  
  
 Можно также использовать блокируя политику для задания блокируете для всех элементов зависимых от типа элемента.  Это происходит потому, что `SetLocks(Locks.None)` всегда вызывается, когда элемент создан или десериализован из файла.  
  
 Однако нельзя использовать политику для изменения блокируете в элементе во время его существования.  Чтобы достичь этого эффекта необходимо использовать вызовы `SetLocks()`.  
  
 Указать блокируя политику.  
  
-   Создайте класс, реализующий <xref:Microsoft.VisualStudio.Modeling.Immutability.ILockingPolicy>.  
  
-   Добавьте этот класс к службам, которые доступны через DocData вашего DSL.  
  
### Задать политику блокируя  
 <xref:Microsoft.VisualStudio.Modeling.Immutability.ILockingPolicy> имеет следующее определение:  
  
```  
public interface ILockingPolicy  
{  
  Locks RefineLocks(ModelElement element, Locks proposedLocks);  
  Locks RefineLocks(Partition partition, Locks proposedLocks);  
  Locks RefineLocks(Store store, Locks proposedLocks);  
}  
```  
  
 Эти методы вызываются при вызове `SetLocks()` в хранилище, разделе или ModelElement.  В каждом методе предоставляются, предлагаемым набором блокируете.  Можно вернуть предложенный набор или блокирует сложения и вычитания.  
  
 Примеры.  
  
```  
using Microsoft.VisualStudio.Modeling;  
using Microsoft.VisualStudio.Modeling.Immutability;  
namespace Company.YourDsl.DslPackage // Change  
{  
  public class MyLockingPolicy : ILockingPolicy  
  {  
    /// <summary>  
    /// Moderate SetLocks(this ModelElement target, Locks locks)  
    /// </summary>  
    /// <param name="element">target</param>  
    /// <param name="proposedLocks">locks</param>  
    /// <returns></returns>  
    public Locks RefineLocks(ModelElement element, Locks proposedLocks)  
    {  
      // In my policy, users can never delete an element,  
      // and other developers cannot easily change that:  
      return proposedLocks | Locks.Delete);  
    }  
    public Locks RefineLocks(Store store, Locks proposedLocks)  
    {  
      // Only one user can change this model:  
      return Environment.UserName == "aUser"   
           ? proposedLocks : Locks.All;  
    }  
  
```  
  
 Убедиться в том, что пользователи могут удалять элементы всегда, даже если остальные вызовы кода `SetLocks(Lock.Delete):`  
  
 `return proposedLocks & (Locks.All ^ Locks.Delete);`  
  
 Запретить изменение всех свойствах каждого элемента MyClass:  
  
 `return element is MyClass ?  (proposedLocks | Locks.Property) : proposedLocks;`  
  
### Сделать доступным политики в качестве службы  
 в вашем `DslPackage` проект добавляется новый файл, содержащий код, который будет выглядеть примерно так:  
  
```  
using Microsoft.VisualStudio.Modeling;  
using Microsoft.VisualStudio.Modeling.Immutability;  
namespace Company.YourDsl.DslPackage // Change  
{   
  // Override the DocData GetService() for this DSL.  
  internal partial class YourDslDocData // Change  
  {  
    /// <summary>  
    /// Custom locking policy cache.  
    /// </summary>  
    private ILockingPolicy myLockingPolicy = null;  
  
    /// <summary>  
    /// Called when a service is requested.  
    /// </summary>  
    /// <param name="serviceType">Service requested</param>  
    /// <returns>Service implementation</returns>  
    public override object GetService(System.Type serviceType)  
    {  
      if (serviceType == typeof(SLockingPolicy)   
       || serviceType == typeof(ILockingPolicy))  
      {  
        if (myLockingPolicy == null)  
        {  
          myLockingPolicy = new MyLockingPolicy();  
        }  
        return myLockingPolicy;  
      }  
      // Request is for some other service.  
      return base.GetService(serviceType);  
    }  
}  
```