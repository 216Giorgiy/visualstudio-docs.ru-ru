---
title: "Определение политики блокировки для создания сегментов, доступных только для чтения | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.topic: article
author: gewarren
ms.author: gewarren
manager: ghogen
ms.workload:
- multiple
ms.technology: vs-ide-modeling
ms.openlocfilehash: dc7e620c04e31a063bbe8fada68527d391f0a903
ms.sourcegitcommit: 205d15f4558315e585c67f33d5335d5b41d0fcea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/09/2018
---
# <a name="defining-a-locking-policy-to-create-read-only-segments"></a>Определение политики блокировки для создания сегментов, доступных только для чтения
Неизменность API-Интерфейс [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] визуализации и моделирования SDK позволяет программам для блокировки всех или части модели доменного языка (DSL), чтобы его можно считывать, но не изменяется. Этот параметр только для чтения может использоваться, например, чтобы пользователь, можно попросить коллеги можно добавить заметки и просмотрите модель DSL, но запретить их изменять исходный.  
  
 Кроме того, как автор DSL, можно определить *политика блокировки.* Политики блокировки определяет, какие блокировки, разрешенных, запрещено или обязательным. Например при публикации DSL может порекомендовать сторонними разработчиками, чтобы дополнить новые команды. Однако можно также использовать политики блокировки для предотвращения изменения состояния указанные части модели только для чтения.  
  
> [!NOTE]
>  Политики блокировки, можно обойти с помощью отражения. Он предоставляет четкой границы для сторонних разработчиков, но не обеспечивают надежную защиту.  
  
 Дополнительные сведения и примеры можно найти по адресу Visual Studio [визуализации и моделирования SDK](https://code.msdn.microsoft.com/Visualization-and-Modeling-313535db) веб-сайта.

[!INCLUDE[modeling_sdk_info](includes/modeling_sdk_info.md)]
  
## <a name="setting-and-getting-locks"></a>Настройка и получение блокировки  
 Можно задать блокировки хранилище, секции или отдельный элемент. Например Эта инструкция будет предотвратить удаление элемента модели и будет также запретить его свойства изменение:  
  
```  
using Microsoft.VisualStudio.Modeling.Immutability; ...  
element.SetLocks(Locks.Delete | Locks.Property);  
```  
  
 Можно использовать другие значения блокировки для предотвращения изменения связей, создания элемента, перемещение между секциями и повторно упорядочивания ссылки в роли.  
  
 Блокировка применяется на действия пользователя и для программного кода. Если программный код пытается изменить, `InvalidOperationException` будет создано. Блокировки учитываются в операции отмены или повтора.  
  
 Вы можете узнать, имеет ли элемент все блокировки в заданном наборе с помощью `IsLocked(Locks)` и текущий набор блокировок для элемента можно получить с помощью `GetLocks()`.  
  
 Можно задать блокировку без использования транзакции. Блокировка базы данных не является частью хранилища. Если задать блокировку в ответ на изменение значения в хранилище, например в OnValueChanged, следует разрешать изменения, которые являются частью операции отмены.  
  
 Эти методы являются методами расширения, которые определены в <xref:Microsoft.VisualStudio.Modeling.Immutability> пространства имен.  
  
### <a name="locks-on-partitions-and-stores"></a>Блокировки на секции и хранилищ  
 Блокировки могут также применяться для секций и хранилище данных. Блокировка, устанавливаемая на секции применяется ко всем элементам в секции. Таким образом например, следующая инструкция сделает невозможным все элементы в секции удаляются независимо от состояния собственные блокировки. Тем не менее, других блокировок например `Locks.Property` еще можно задать в отдельных элементов:  
  
```  
partition.SetLocks(Locks.Delete);  
```  
  
 Блокировка, устанавливаемая на хранилище применяется для всех его элементов, независимо от параметров блокировки на секции, а также элементы.  
  
### <a name="using-locks"></a>Использование блокировок  
 Блокировки можно использовать для реализации схем, таких как в следующих примерах:  
  
-   Запрет изменения всех элементов и отношений, за исключением тех, которые представляют комментарии. Это позволяет пользователям для создания заметок к модели без изменений.  
  
-   Запрет изменений в секции по умолчанию, но разрешить изменения в схеме секционирования. Пользователь может изменить схему, но невозможно изменить базовую модель.  
  
-   Запрет изменений в хранилище, за исключением группы пользователей, зарегистрированных в отдельной базе данных. Для других пользователей схеме и модели доступны только для чтения.  
  
-   Запрет изменений в модели, если значение логического свойства диаграммы значение true. Укажите команду меню, чтобы изменить это свойство. Это помогает обеспечить пользователям, которые не вносят изменения случайно.  
  
-   Запрет добавления и удаления элементов и связей определенного класса, но разрешить изменения свойств. Это предоставляет пользователям с предопределенной формы, в котором можно заполнить свойства.  
  
## <a name="lock-values"></a>Блокировки значения  
 Можно задать блокировки на хранилище, раздел или отдельных ModelElement. Блокирует `Flags` перечисления: можно объединять его с помощью значения "&#124;".  
  
-   Блокировки Управление складом всегда включать блокировки его секции.  
  
-   Блокировки секции всегда включать блокировки хранилища.  
  
 Не удается установить блокировку на секции или хранения и в то же время отключить блокировку отдельного элемента.  
  
|Значение|То есть если `IsLocked(Value)` имеет значение true|  
|-----------|------------------------------------------|  
|Нет|Без ограничений.|  
|Свойство.|Невозможно изменить свойства домена элементов. Это не относится к свойствам, которые создаются в роли доменного класса в связи.|  
|Add|Нельзя создать новые элементы и ссылки в секции или хранения.<br /><br /> Не применимо к `ModelElement`.|  
|Перемещение|Элемент нельзя перемещать между разделами, если `element.IsLocked(Move)` имеет значение true, или если `targetPartition.IsLocked(Move)` имеет значение true.|  
|Удаление|Элемент нельзя удалить, если эта блокировка устанавливается в самом элементе или на всех элементов, к которому будет распространять удаления, таких как встроенные элементы и фигуры.<br /><br /> Можно использовать `element.CanDelete()` для обнаружения, может ли быть удален элемент.|  
|Изменение порядка|Невозможно изменить порядок ссылок в roleplayer.|  
|RolePlayer|Набор ссылок, которые предоставляются в этот элемент нельзя изменить. Например новые элементы не могут быть внедрены в этом элементе. Это не влияет на связи, для которой этот элемент является целевым.<br /><br /> Если этот элемент является ссылкой, его исходной и целевой не затрагиваются.|  
|Все|Побитовое или другие значения.|  
  
## <a name="locking-policies"></a>Политики блокировки  
 Как автор доменный язык DSL, можно определить *политика блокировки*. Политики блокировки moderates операцию SetLocks(), так, чтобы можно было предотвратить конкретные блокировки из процесса установки или требует, что конкретные блокировки должен быть установлен. Как правило, используется политики блокировки для запрета пользователей и разработчиков от случайно contravening предназначения DSL, таким же образом, что можно объявить переменную `private`.  
  
 Можно также использовать политики блокировки установка блокировки для всех элементов зависит от типа элемента. Это вызвано `SetLocks(Locks.None)` вызывается всегда, когда элемент сначала создается или десериализован из файла.  
  
 Тем не менее нельзя использовать политику для меняться блокировки на элемент в течение его жизненного цикла. Чтобы добиться этого, следует использовать вызовы `SetLocks()`.  
  
 Для определения политики блокировки, необходимо выполнить следующее:  
  
-   Создайте класс, реализующий <xref:Microsoft.VisualStudio.Modeling.Immutability.ILockingPolicy>.  
  
-   Добавьте этот класс службы, которые доступны через DocData доменного языка.  
  
### <a name="to-define-a-locking-policy"></a>Для определения политики блокировки  
 <xref:Microsoft.VisualStudio.Modeling.Immutability.ILockingPolicy>применяются следующие определения:  
  
```  
public interface ILockingPolicy  
{  
  Locks RefineLocks(ModelElement element, Locks proposedLocks);  
  Locks RefineLocks(Partition partition, Locks proposedLocks);  
  Locks RefineLocks(Store store, Locks proposedLocks);  
}  
```  
  
 Эти методы вызываются в том случае, когда выполняется вызов `SetLocks()` на хранилище, раздел или ModelElement. В каждом методе будет предоставлен предложенный набор блокировок. Может возвращать предложенный набора, или можно добавлять и удалять блокировки.  
  
 Пример:  
  
```  
using Microsoft.VisualStudio.Modeling;  
using Microsoft.VisualStudio.Modeling.Immutability;  
namespace Company.YourDsl.DslPackage // Change  
{  
  public class MyLockingPolicy : ILockingPolicy  
  {  
    /// <summary>  
    /// Moderate SetLocks(this ModelElement target, Locks locks)  
    /// </summary>  
    /// <param name="element">target</param>  
    /// <param name="proposedLocks">locks</param>  
    /// <returns></returns>  
    public Locks RefineLocks(ModelElement element, Locks proposedLocks)  
    {  
      // In my policy, users can never delete an element,  
      // and other developers cannot easily change that:  
      return proposedLocks | Locks.Delete);  
    }  
    public Locks RefineLocks(Store store, Locks proposedLocks)  
    {  
      // Only one user can change this model:  
      return Environment.UserName == "aUser"   
           ? proposedLocks : Locks.All;  
    }  
  
```  
  
 Чтобы убедиться в том, что пользователи всегда могут удалять элементы, даже если другие код вызывает метод`SetLocks(Lock.Delete):`  
  
 `return proposedLocks & (Locks.All ^ Locks.Delete);`  
  
 Чтобы запретить изменение в окне свойств каждого элемента MyClass:  
  
 `return element is MyClass ? (proposedLocks | Locks.Property) : proposedLocks;`  
  
### <a name="to-make-your-policy-available-as-a-service"></a>Чтобы сделать доступными как служба политикой  
 В вашей `DslPackage` проект, добавить новый файл, который содержит код, аналогичный следующему примеру:  
  
```  
using Microsoft.VisualStudio.Modeling;  
using Microsoft.VisualStudio.Modeling.Immutability;  
namespace Company.YourDsl.DslPackage // Change  
{   
  // Override the DocData GetService() for this DSL.  
  internal partial class YourDslDocData // Change  
  {  
    /// <summary>  
    /// Custom locking policy cache.  
    /// </summary>  
    private ILockingPolicy myLockingPolicy = null;  
  
    /// <summary>  
    /// Called when a service is requested.  
    /// </summary>  
    /// <param name="serviceType">Service requested</param>  
    /// <returns>Service implementation</returns>  
    public override object GetService(System.Type serviceType)  
    {  
      if (serviceType == typeof(SLockingPolicy)   
       || serviceType == typeof(ILockingPolicy))  
      {  
        if (myLockingPolicy == null)  
        {  
          myLockingPolicy = new MyLockingPolicy();  
        }  
        return myLockingPolicy;  
      }  
      // Request is for some other service.  
      return base.GetService(serviceType);  
    }  
}  
```
