---
title: Настройка создания и перемещения элементов
ms.date: 11/04/2016
ms.topic: conceptual
f1_keywords:
- vs.dsltools.dsldesigner.elementmergedirective
helpviewer_keywords:
- Domain-Specific Language, element merge directives
author: gewarren
ms.author: gewarren
manager: douge
ms.workload:
- multiple
ms.prod: visual-studio-dev15
ms.technology: vs-ide-modeling
ms.openlocfilehash: 8f4563756e42b5c0bdc1a56e938ca6326e04b104
ms.sourcegitcommit: 58052c29fc61c9a1ca55a64a63a7fdcde34668a4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2018
ms.locfileid: "34748663"
---
# <a name="customizing-element-creation-and-movement"></a>Настройка создания и перемещения элементов
Вы можете разрешить элемент, чтобы перетащить в другое, из панели элементов или в Вставка или операции перемещения. Может иметь перемещенные элементы, связанные с целевых элементов, с помощью связей, указанных вами.

 Element, директива слияния (EMD) указывает, что произойдет, если один из элементов модели *объединенные* в другой элемент модели. Это происходит, когда:

-   Пользователь перетаскивает из панели элементов на схему или фигуры.

-   Пользователь создает элемент с помощью меню "Добавить" в проводнике или фигура секции.

-   Пользователь перемещает элемент из одного дорожек в другой.

-   Пользователь вставляет элемент.

-   Программный код вызывает директиву element слияния.

 Несмотря на то, что операции создания может показаться должно отличаться от операций копирования, они фактически работают одинаково. При добавлении элемента, например из области элементов прототип его реплицируется. Прототип объединяется в модели, так же, как элементы, которые были скопированы из другой части модели.

 Ответственность за EMD является решить, как объединить объект или группу объектов в определенном месте в модели. В частности он решает, какие связи должен создаваться для связывания группы в модели. Можно также настроить его для задания свойств и создание дополнительных объектов.

 ![DSL&#45;EMD&#95;слияния](../modeling/media/dsl-emd_merge.png) роль директива слияния элементов

 При определении связи внедренные EMD создается автоматически. Это значение по умолчанию EMD экземпляра связи при добавлении новых экземпляров дочернего к родительскому элементу. Можно изменить эти EMDs по умолчанию, например путем добавления пользовательского кода.

 Можно также добавить собственные EMDs в определения DSL, чтобы позволить пользователям перетащите или вставьте различные сочетания объединенные и получения классов.

## <a name="defining-an-element-merge-directive"></a>Определение слияния директивы Element
 Доменные классы отношений между доменами, фигур, соединители и диаграмм можно добавить директивы слияния элементов. Можно добавить или найти их в обозреватель DSL в принимающего класса домена. Принимающего класса является класс домена элемента, который уже находится в модели, а также в которой будут объединены нового или скопированного элемента.

 ![DSL&#45;EMD&#95;подробные сведения](../modeling/media/dsl-emd_details.png)

 **Индексирования класс** — это класс домена элементов, которые могут быть объединены в члена принимающего класса. Экземпляры подклассы класса индексирования будут объединены с этой EMD, также если вы не задали **применяется подклассов** значение False.

 Существует два вида директива слияния.

-   Объект **процесс слияния** директива определяет связи, по которым необходимо связать новый элемент в дерево.

-   Объект **вперед слияния** директива перенаправляет нового элемента к другому элементу принимающей, обычно является родительским.

 Можно добавить пользовательский код для слияния директивы:

-   Задать **использует настраиваемый принять** Добавление кода для определения, является ли конкретный экземпляр элемента индексирования следует объединить в целевой элемент. При перетаскивании из панели элементов, указатель «недопустимый» показывает, если код не разрешает слияния.

     Например можно разрешить слияние только в том случае, если принимающее элемент находится в определенном состоянии.

-   Задать **настраиваемого объединения использует** Добавление предоставить собственный код, чтобы определить изменения, внесенные в модель при выполнении слияния.

     Например можно задать свойства в объединенный элемент с использованием данных из нового местоположения в модели.

> [!NOTE]
>  При написании кода настраиваемого объединения, оно влияет только слияния, которые выполняются с использованием этого EMD. Если существуют другие EMDs, объединяемых объекты одного типа, или если имеется другой пользовательский код, который создает эти объекты без использования EMD, затем они не затрагиваются для слияния пользовательского кода.
>
>  Если требуется, чтобы убедиться в том, что новый элемент или создать связь всегда обрабатывается в пользовательском коде, подумайте об определении `AddRule` связи внедренные и `DeleteRule` на класс домена данного элемента. Дополнительные сведения см. в разделе [распространение изменений в модели правил](../modeling/rules-propagate-changes-within-the-model.md).

## <a name="example-defining-an-emd-without-custom-code"></a>Пример: Определение EMD без пользовательского кода
 Следующий пример позволяет пользователям создавать элемент и соединителем одновременно путем перетаскивания из панели элементов на существующей фигуры. В примере добавляется EMD определения DSL. До этого изменения пользователи могут перетаскивать средства на схему, но не на существующие фигуры.

 Пользователи также можно вставить элементы в других элементах.

#### <a name="to-let-users-create-an-element-and-a-connector-at-the-same-time"></a>Чтобы пользователи могли создавать элемент и соединителем одновременно

1.  Создайте новый DSL с помощью **минимальной языка** шаблон решения.

     При запуске этого DSL, он позволяет создать фигуры и соединители между фигурами. Нельзя перетащить новый **ExampleElement** фигуры из панели элементов на существующей фигуры.

2.  Чтобы позволить пользователям объединять элементы на `ExampleElement` фигур, создание новых EMD в `ExampleElement` класса домена:

    1.  В **обозреватель DSL**, разверните **доменные классы**. Щелкните правой кнопкой мыши `ExampleElement` и нажмите кнопку **добавьте новый директивы Element слияния**.

    2.  Убедитесь, что **сведений DSL** открыт, так что можно просмотреть сведения о новых EMD. (Меню: **представление**, **других окон**, **сведений DSL**.)

3.  Задать **индексирования класс** в окне сведений DSL, чтобы определить, какому классу элементов могут быть объединены в `ExampleElement` объектов.

     В этом примере выберите `ExampleElements`, после чего пользователь может перетащить новые элементы на существующих элементов.

     Обратите внимание, что класс индексирования становится именем EMD в обозреватель DSL.

4.  В разделе **процесс слияния создаются ссылки**, добавьте два пути:

    1.  Один путь связывает новый элемент родительской модели. Выражение пути, которые нужно ввести переходит из существующего элемента вверх через связи внедренные родительской модели. Наконец он указывает роль в новой ссылке, к которому будет назначен новый элемент. Путь выглядит следующим образом:

         `ExampleModelHasElements.ExampleModel/!ExampleModel/.Elements`

    2.  Другой путь связывает новый элемент на существующий элемент. Выражение пути задает отношение ссылки и роли, к которому будет назначен новый элемент. Этот путь выглядит следующим образом:

         `ExampleElementReferencesTargets.Sources`

     Средство пути навигации можно использовать для создания каждого пути:

    1.  В разделе **процесс слияния путем создания ссылки на пути**, нажмите кнопку  **\<добавить путь >**.

    2.  Щелкните стрелку раскрывающегося списка справа от элемента списка. Отображается представление в виде дерева.

    3.  Разверните узлы в дереве для формирования пути, для которого требуется задать.

5.  Тестирование DSL.

    1.  Нажмите клавишу F5, чтобы перестроить и запустите это решение.

         Перестроение потребуется больше времени чем обычно, поскольку созданный код будет обновляться из текстовых шаблонов, чтобы они соответствовали новой определения DSL.

    2.  Когда экспериментальный экземпляр [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] был запущен, откройте файл модели DSL. Создайте некоторые элементы в примере.

    3.  Перетащите из **пример элемента** средства на существующей фигуры.

         Появится новая фигура, и он привязывается к существующей фигуры с помощью соединителя.

    4.  Скопируйте существующей фигуры. Выберите другую форму и вставьте.

         Создается копия первой фигуре.  Он имеет новое имя, и он привязывается к второй формы с помощью соединителя.

 От этой процедуры необходимо помнить следующее:

-   Создавая элемент директивы слияния, можно разрешить любой класс принимать любой другой элемент. EMD создается в принимающего класса домена, а класс обслуживаемый домен, указанный в **класс Index** поля.

-   Определив пути, можно указать, какие связи следует использовать для подключения к существующей модели новый элемент.

     Ссылки, можно указать, следует включить одной связи внедренные.

-   EMD влияет на создание и из элементов, а также операции вставки.

     При написании пользовательского кода, которая создает новые элементы, можно явным образом вызвать EMD с помощью `ElementOperations.Merge` метод. Это гарантирует, что код связывает новые элементы в модель так же, как другие операции. Дополнительные сведения см. в разделе [Настройка функции копирования](../modeling/customizing-copy-behavior.md).

## <a name="example-adding-custom-accept-code-to-an-emd"></a>Пример: Добавление принимают пользовательский код в EMD
 Путем добавления пользовательского кода для EMD, можно определить более сложные поведение при объединении. Этот простой пример запрещает добавление более фиксированное число элементов в диаграмму. В примере изменяется значение по умолчанию EMD, сопровождающее отношение внедрения.

#### <a name="to-write-custom-accept-code-to-restrict-what-the-user-can-add"></a>Для записи принимают пользовательский код для ограничения, пользователь может добавить

1.  Создать доменный язык DSL, используя **минимальной языка** шаблон решения. Откройте схема определения DSL.

2.  В обозревателе DSL разверните **доменные классы**, `ExampleModel`, **директивы слияния элемент**. Выберите директивы element слияния с именем `ExampleElement`.

     Это EMD определяет, как пользователь может создать новые `ExampleElement` объекты в модели, например путем перетаскивания из панели элементов.

3.  В **сведений DSL** выберите **использует настраиваемый принять**.

4.  Выполните повторную сборку решения. Это займет больше времени чем обычно, поскольку созданный код будет обновляться из модели.

     Ошибка построения будет отчета, как: «Company.ElementMergeSample.ExampleElement содержит определения для CanMergeExampleElement...»

     Вы должны реализовать метод `CanMergeExampleElement`.

5.  Создайте новый файл кода в **Dsl** проекта. Замените его содержимое следующим кодом и изменить пространство имен для пространства имен проекта.

    ```csharp
    using Microsoft.VisualStudio.Modeling;

    namespace Company.ElementMergeSample // EDIT.
    {
      partial class ExampleModel
      {
        /// <summary>
        /// Called whenever an ExampleElement is to be merged into this ExampleModel.
        /// This happens when the user pastes an ExampleElement
        /// or drags from the toolbox.
        /// Determines whether the merge is allowed.
        /// </summary>
        /// <param name="rootElement">The root element in the merging EGP.</param>
        /// <param name="elementGroupPrototype">The EGP that the user wants to merge.</param>
        /// <returns>True if the merge is allowed</returns>
        private bool CanMergeExampleElement(ProtoElementBase rootElement, ElementGroupPrototype elementGroupPrototype)
        {
          // Allow no more than 4 elements to be added:
          return this.Elements.Count < 4;
        }
      }
    }

    ```

     Этот простой пример ограничивает количество элементов, которые могут быть объединены в родительской модели. Условия, более интересным метод можно было проверить свойства и ссылки, получающий объект. Его также можно проверить свойства слияние элементов, которые передаются в <xref:Microsoft.VisualStudio.Modeling.ElementGroupPrototype>. Дополнительные сведения о `ElementGroupPrototypes`, в разделе [Настройка функции копирования](../modeling/customizing-copy-behavior.md). Дополнительные сведения о том, как написать код, который считывает модели см. в разделе [перехода и обновления модели в программном коде](../modeling/navigating-and-updating-a-model-in-program-code.md).

6.  Тестирование DSL.

    1.  Нажмите клавишу F5, чтобы перестроить решение. Когда экспериментальный экземпляр [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] откроется, откройте экземпляр доменного языка.

    2.  Создайте новые элементы несколькими способами:

        1.  Перетащите из **пример элемента** средства на схему.

        2.  В **обозревателя моделей пример**, щелкните правой кнопкой мыши корневой узел и нажмите кнопку **добавить новый элемент пример**.

        3.  Скопируйте и вставьте элемент на схеме.

    3.  Убедитесь, что нельзя использовать любой из этих способов добавления более четырех элементов в модели. Это потому, что их директива слияния элементов.

## <a name="example-adding-custom-merge-code-to-an-emd"></a>Пример: Добавление слияния пользовательского кода в EMD
 В коде настраиваемого объединения можно определить, что происходит, когда пользователь перетаскивает средство или вставляет на элемент. Для определения настраиваемого объединения двумя способами.

1.  Задать **слияния использует настраиваемый** и укажите требуемый код. Кода заменяется код созданный слияния. Используйте этот параметр, если требуется полностью переопределить назначение слияния.

2.  Переопределить `MergeRelate` метод и при необходимости `MergeDisconnect` метод. Чтобы сделать это, необходимо задать **приводит к возникновению ошибки производного типа Double** свойства класса домена. Код может вызвать слияния созданный код в базовом классе. Используйте этот параметр, если требуется выполнить дополнительные операции после выполнения слияния.

 Эти подходы влияют только на слияния, которые выполняются с использованием этого EMD. Если требуется управлять всеми способами, в которых можно создать объединенный элемент, альтернативой является определение `AddRule` связи внедренные и `DeleteRule` на класс объединенных домена. Дополнительные сведения см. в разделе [распространение изменений в модели правил](../modeling/rules-propagate-changes-within-the-model.md).

#### <a name="to-override-mergerelate"></a>Чтобы переопределить MergeRelate

1.  В определении DSL убедитесь, что вы определили EMD, к которому нужно добавить код. Если требуется, можно добавить пути и определить настраиваемый принять кода, как описано в предыдущих разделах.

2.  На схеме DslDefinition выберите принимающего класса слияния. Обычно это класс в исходном элементе связи внедренные.

     Например, в DSL, созданный из решения минимальной языка, выберите `ExampleModel`.

3.  В **свойства** задайте **приводит к возникновению ошибки производного типа Double** для **true**.

4.  Выполните повторную сборку решения.

5.  Проверить содержимое **Dsl\Generated Files\DomainClasses.cs**. Поиск методов с именем `MergeRelate` и просматривать их содержимое. Это поможет вам создавать собственные версии.

6.  В новый файл кода, написать разделяемый класс для принимающего класса и переопределить `MergeRelate` метод. Не забудьте вызвать базовый метод. Пример:

    ```csharp
    partial class ExampleModel
    {
      /// <summary>
      /// Called when the user drags or pastes an ExampleElement onto the diagram.
      /// Sets the time of day as the name.
      /// </summary>
      /// <param name="sourceElement">Element to be added</param>
      /// <param name="elementGroup">Elements to be merged</param>
      protected override void MergeRelate(ModelElement sourceElement, ElementGroup elementGroup)
      {
        // Connect the element according to the EMD:
        base.MergeRelate(sourceElement, elementGroup);

        // Custom actions:
        ExampleElement mergingElement = sourceElement as ExampleElement;
        if (mergingElement != null)
        {
          mergingElement.Name = DateTime.Now.ToLongTimeString();
        }
      }
    }

    ```

#### <a name="to-write-custom-merge-code"></a>Создание слияния пользовательского кода

1.  В **Dsl\Generated Code\DomainClasses.cs**, проверять методов с именем `MergeRelate`. Эти методы создают связи между элементом новой и существующей модели.

     Кроме того, проверить методов с именем `MergeDisconnect`. Эти методы разорвать связь элемента из модели, если удалить.

2.  В **обозреватель DSL**выберите или создайте директива слияния элементов, которую нужно настроить. В **сведений DSL** задайте **слияния использует настраиваемый**.

     При установке этого параметра **процесс слияния** и **вперед слияния** параметры учитываются. Вместо него используется код.

3.  Выполните повторную сборку решения. Займет больше времени, чем обычно, так как в созданных файлах кода будет обновляться из модели.

     Будут отображаться сообщения об ошибках. Дважды щелкните сообщения об ошибках для просмотра инструкций в созданном коде. Эти инструкции предложит указать два метода `MergeRelate` *YourDomainClass* и `MergeDisconnect` *YourDomainClass*

4.  Создайте методы в определении разделяемого класса в отдельном файле кода. Примеры, которые можно проверить ранее должна предлагать необходимые условия.

 Код настраиваемого объединения не повлияет на код, который создает объекты и связи, напрямую и не влияет на другие EMDs. Чтобы убедиться в том, что независимо от способа создания элемента реализованы дополнительные изменения, рассмотрите возможность записи `AddRule` и `DeleteRule` вместо него. Дополнительные сведения см. в разделе [распространение изменений в модели правил](../modeling/rules-propagate-changes-within-the-model.md).

## <a name="redirecting-a-merge-operation"></a>Перенаправление операции слияния
 Директива прямой слияния перенаправляет целевого объекта для операции слияния. Как правило новый целевой объект является родительским внедрения начальной целевого объекта.

 Например DSL, созданный с помощью шаблона схемы компонентов, порты внедрены в компонентах. Порты, отображаются как маленьких фигур на границе форму компонента. Пользователь создает порты, перетащив инструмент «порт» в форму компонента. Но иногда пользователь по ошибке перетащить средство Port существующему порту, вместо компонента, и операция завершится ошибкой. Это простой ошибки при наличии нескольких существующих портов. Чтобы помочь пользователю, чтобы избежать этого неудобство, вы можете разрешить портов перетащить существующему порту, но действия, перенаправление для родительского компонента. Операция работает так, будто целевого элемента компонента.

 Директива прямой слияния можно создать в решении модели компонентов. Если скомпилировать и запустить решение на исходный, вы увидите, что пользователи могут перетаскивать любое количество **входного порта** или **выходной порт** элементы из **элементов** для **Компонент** элемента. Однако их нельзя перетаскивать порта к существующему порту. Им это не включены оповещения указатель недоступен. Тем не менее, можно создать директивы слияния вперед, чтобы порт, который был случайно удален на существующем **входного порта** перенаправляется **компонент** элемента.

#### <a name="to-create-a-forward-merge-directive"></a>Для создания прямого слияния директивы

1.  Создание [!INCLUDE[dsl](../modeling/includes/dsl_md.md)] решения с помощью шаблона модели компонентов.

2.  Отображение **обозреватель DSL** , открыв DslDefinition.dsl.

3.  В **обозреватель DSL**, разверните **доменные классы**.

4.  **ComponentPort** домена абстрактный класс является базовым классом обоих **InPort** и **OutPort**. Щелкните правой кнопкой мыши **ComponentPort** и нажмите кнопку **добавьте новый директивы Element слияния**.

     Новый **директива слияния элементов** узел отображается в узле **директивы слияния элемент** узла.

5.  Выберите **директива слияния элементов** узел и откройте **сведений DSL** окна.

6.  В списке классов индексирования выберите **ComponentPort**.

7.  Выберите **вперед слияния в другом домене класс**.

8.  В списке выбора пути, разверните **ComponentPort**, разверните **ComponentHasPorts**, а затем выберите **компонента**.

     Новый путь должен быть похож на следующее:

     **ComponentHasPorts.Component/!Component**

9. Сохраните решение, а затем для преобразования шаблоны, щелкнув правой кнопкой **обозревателе решений** инструментов.

10. Постройте и запустите это решение. Новый экземпляр [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] отображается.

11. В **обозревателе решений**, откройте Sample.mydsl. Схемы и **ComponentLanguage элементов** отображаются.

12. Перетащите **входного порта** из **элементов** в другой **входного порта.** Затем перетащите **OutputPort** для **InputPort** и затем на другой **OutputPort**.

     Не должны видеть указатель недоступен и можно сбросить новый **входного порта** на существующую. Выберите новый **входного порта** и перетащите его на другую точку **компонента**.

## <a name="see-also"></a>См. также

- [Перемещение по модели и обновление модели в коде программы](../modeling/navigating-and-updating-a-model-in-program-code.md)
- [Настройка элементов и панели элементов](../modeling/customizing-tools-and-the-toolbox.md)
- [Образец схемы цепи DSL](http://code.msdn.microsoft.com/Visualization-Modeling-SDK-763778e8)