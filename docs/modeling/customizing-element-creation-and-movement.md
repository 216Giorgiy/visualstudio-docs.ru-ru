---
title: "Настройка создания и перемещения элементов | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vs.dsltools.dsldesigner.elementmergedirective"
helpviewer_keywords: 
  - "Доменный язык, директивы слияния элементов"
ms.assetid: cbd28f15-dfd7-46bd-ab79-5430e3ed83c8
caps.latest.revision: 36
author: "alancameronwills"
ms.author: "awills"
manager: "douge"
caps.handback.revision: 36
---
# Настройка создания и перемещения элементов
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

Можно разрешить элемент перетащить на другой, с панели инструментов или в вставить или переместить операции. Может иметь перемещенный элементов, связанных с целевыми элементами с помощью связей, которые можно задать.  
  
 Директива слияния элементов (EMD) указывает, что происходит, если один элемент модели *объединенные* в другой элемент модели. Это происходит, когда:  
  
-   Пользователь перетаскивает из панели элементов на схему или форму.  
  
-   Пользователь создает элемент с помощью меню "Добавить" в обозревателе или фигуры секции.  
  
-   Пользователь перемещает элемент из одной дорожки в другую.  
  
-   Пользователь вставляет элемент.  
  
-   Программный код вызывает директива слияния элементов.  
  
 Несмотря на то, что операции создания может показаться должно отличаться от операций копирования, на самом деле работают таким же образом. При добавлении элемента, например из панели элементов прототип его реплицируется. Так же, как элементы, которые были скопированы из другой части модели прототипа объединяются в модель.  
  
 Ответственность за EMD является определение того, как следует объединить объект или группу объектов в определенном месте в модели. В частности он решает, какие связи должен создаваться для связывания группы объединенных в модель. Также можно настроить его для задания свойств и создания дополнительных объектов.  
  
 ![DSL &#45; EMD &#95; Слияние](../modeling/media/dsl-emd_merge.png "DSL-EMD_Merge")  
Роль директива слияния элементов  
  
 EMD создается автоматически при определении отношения внедрения. Это значение по умолчанию EMD экземпляра связи при добавлении новых экземпляров дочернего к родительскому элементу. Можно изменить эти EMDs по умолчанию, например, путем добавления пользовательского кода.  
  
 Можно также добавить собственные EMDs в определении DSL, позволяющим перетаскивать или вставить различные сочетания объединенных и принимающий классов.  
  
## <a name="defining-an-element-merge-directive"></a>Определение директиву слияния элементов  
 Директивы слияния элементов можно добавить классы доменов доменных связей, фигуры, соединители и схемы. Можно добавить или найти их в обозревателе DSL под принимающего класса домена. Принимающего класса является класс домена элемента, который уже находится в модели и на которой будут объединены нового или скопированного элемента.  
  
 ![DSL &#45; EMD &#95; подробные сведения](../modeling/media/dsl-emd_details.png "DSL-EMD_Details")  
  
  **Индексирование класс** — это класс домена элементов, которые могут быть объединены в члены, принимающего класса. Экземпляры подклассы класса индексирования также объединяются по этой EMD, если не задать **применяется в подклассы** значение False.  
  
 Существует два вида директива слияния.  
  
-   A **процесс слияния** директива указывает связи, по которым необходимо связать новый элемент в дерево.  
  
-   A **вперед слияния** директива перенаправляет нового элемента к другому элементу приемки, обычно родительского.  
  
 Можно добавить пользовательский код для директивы слияния:  
  
-   Задайте **использует настраиваемое принятие** Добавление кода для определения, является ли конкретный экземпляр элемента индексирования следует объединить в целевой элемент. При перетаскивании из панели элементов, указатель «недопустимый» показывает, если код запрещает слияния.  
  
     Например можно разрешить слияние только в том случае, если принимающее элемент находится в определенном состоянии.  
  
-   Задайте **использует настраиваемого объединения** Добавление предоставить собственный код, чтобы определить изменения, внесенные в модель при выполнении слияния.  
  
     Например в элементе объединенных удалось задать свойства, используя данные из нового местоположения в модели.  
  
> [!NOTE]
>  При написании кода настраиваемого объединения, он влияет только слияния, которые выполняются с использованием этого EMD. При отсутствии других EMDs, объединяемых тому же типу объектов, или если есть другой пользовательский код, который создает эти объекты без использования EMD, затем они не затрагиваются код настраиваемого объединения.  
>   
>  Если требуется, чтобы убедиться в том, что новый элемент или создать связь всегда обрабатывается пользовательский код, подумайте об определении `AddRule` на отношение внедрения и `DeleteRule` на класс домена этого элемента. Дополнительные сведения см. в разделе [Распространение изменений в модели правил](../modeling/rules-propagate-changes-within-the-model.md).  
  
## <a name="example-defining-an-emd-without-custom-code"></a>Пример: Определение EMD без пользовательского кода  
 Следующий пример разрешает пользователям создавать элемент и соединитель одновременно путем перетаскивания с панели элементов на существующей фигуры. В примере добавляется EMD определения DSL. До этого изменения пользователи смогут перетаскивать средства на схему, но не на существующие фигуры.  
  
 Пользователи также можно вставить элементы в других элементов.  
  
#### <a name="to-let-users-create-an-element-and-a-connector-at-the-same-time"></a>Чтобы разрешить пользователям создавать элемент и соединитель в то же время  
  
1.  Создайте новый DSL с помощью **Минимальный язык** шаблона решения.  
  
     При запуске этот DSL, он позволяет создавать фигур и соединителей между фигурами. Нельзя перетащить новый **ExampleElement** фигуры с панели элементов на существующей фигуры.  
  
2.  Чтобы позволить пользователям объединять элементы на `ExampleElement` фигур, создание новых EMD в `ExampleElement` класса домена:  
  
    1.  В **Обозреватель DSL**, разверните **классов доменов**. Щелкните правой кнопкой мыши `ExampleElement` и нажмите кнопку **добавьте директивы слияния новый элемент**.  
  
    2.  Убедитесь, что **Подробные сведения о DSL** окно открыт, таким образом, можно просмотреть сведения о новых EMD. (Меню: **Просмотр**, **других окон**, **Подробные сведения о DSL**.)  
  
3.  Задайте **индексирования класс** в окне сведений DSL, чтобы определить, какой класс элементов могут быть объединены в `ExampleElement` объектов.  
  
     В этом примере выберите `ExampleElements`, так что пользователь может перетащить новые элементы на существующих элементов.  
  
     Обратите внимание, что класс индексирования становится именем EMD в обозревателе DSL.  
  
4.  В разделе **процесс слияния создаются ссылки**, добавьте два пути:  
  
    1.  Один путь связывает новый элемент родительской модели. Выражение пути, необходимо ввести переходит из существующего элемента вверх через отношение внедрения родительской модели. Наконец он указывает роль в новой ссылке, к которому будет назначен новый элемент. Путь выглядит следующим образом:  
  
         `ExampleModelHasElements.ExampleModel/!ExampleModel/.Elements`  
  
    2.  Другой путь связывает новый элемент на существующий элемент. Выражение пути задает ссылочная связь и роли, к которому будет назначен новый элемент. Этот путь выглядит следующим образом:  
  
         `ExampleElementReferencesTargets.Sources`  
  
     Для создания каждого пути можно использовать средство путь навигации:  
  
    1.  В разделе **процесс слияния путем создания ссылки на пути**, нажмите кнопку **\< Добавить путь>**.  
  
    2.  Щелкните стрелку раскрывающегося списка справа от элемента списка. Откроется представление в виде дерева.  
  
    3.  Разверните узлы в дереве к форме, чтобы указать путь.  
  
5.  Проверьте DSL:  
  
    1.  Нажмите клавишу F5, чтобы построить и запустить решение.  
  
         Перестроение займет больше времени чем обычно, поскольку созданный код будет обновляться из текстовых шаблонов для обеспечения соответствия нового определения DSL.  
  
    2.  Когда экспериментальный экземпляр [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] был запущен, откройте файл модели DSL. Создайте некоторые элементы примера.  
  
    3.  Перетащите из **Пример элемента** средство на существующей фигуры.  
  
         Появится новая фигура, и он связан с существующей фигуры с помощью соединителя.  
  
    4.  Копирование существующей фигуры. Выберите другую форму и вставьте.  
  
         Создается копия первой фигуры.  Он имеет новое имя и связывается второй формы с помощью соединителя.  
  
 Обратите внимание на следующие моменты, из этой процедуры:  
  
-   Создавая директивы слияния элементов, можно разрешить любой класс элемента, чтобы принимать другие. EMD создается в классе домена принимающей и класс обслуживаемый домен, указанный в **класс Index** поле.  
  
-   Определение путей, можно указать, какие ссылки следует использовать для подключения нового элемента к существующей модели.  
  
     Ссылки, можно указать, должен включать одного отношения внедрения.  
  
-   EMD влияет на создание и из элементов, а также операции вставки.  
  
     Если написать пользовательский код, который создает новые элементы, можно явно вызывать EMD с помощью `ElementOperations.Merge` метод. Это гарантирует, что код связывает новые элементы в модель так же, как другие операции. Дополнительные сведения см. в разделе [Настройка поведения копирования](../modeling/customizing-copy-behavior.md).  
  
## <a name="example-adding-custom-accept-code-to-an-emd"></a>Пример: Добавление кода настраиваемое принятие EMD  
 Путем добавления пользовательского кода для EMD, можно определить более сложное поведение слияния. В этом простом примере запрещает пользователю добавлять более фиксированное число элементов в схеме. В примере изменяется значение по умолчанию EMD, сопровождающий отношение внедрения.  
  
#### <a name="to-write-custom-accept-code-to-restrict-what-the-user-can-add"></a>В коде настраиваемое принятие ограничения, пользователь может добавить  
  
1.  Создать DSL с помощью **Минимальный язык** шаблона решения. Откройте схему определения DSL.  
  
2.  В обозревателе DSL разверните **классов доменов**, `ExampleModel`, **директивы слияния элементов**. Выберите директива слияния элементов с именем `ExampleElement`.  
  
     Это EMD определяет, как пользователь может создать `ExampleElement` объекты модели, например путем перетаскивания с панели инструментов.  
  
3.  В **Подробные сведения о DSL** выберите **использует настраиваемое принятие**.  
  
4.  Выполните повторную сборку решения. Это займет больше времени, чем обычно, поскольку созданный код будет обновляться из модели.  
  
     Ошибка построения будет отчета, как: «Company.ElementMergeSample.ExampleElement содержит определения для CanMergeExampleElement...»  
  
     Необходимо реализовать метод `CanMergeExampleElement`.  
  
5.  Создайте новый файл кода в **Dsl** проекта. Замените его содержимое следующим кодом и измените пространство имен своего проекта.  
  
    ```c#  
    using Microsoft.VisualStudio.Modeling;  
  
    namespace Company.ElementMergeSample // EDIT.  
    {  
      partial class ExampleModel  
      {  
        /// <summary>  
        /// Called whenever an ExampleElement is to be merged into this ExampleModel.  
        /// This happens when the user pastes an ExampleElement  
        /// or drags from the toolbox.  
        /// Determines whether the merge is allowed.  
        /// </summary>  
        /// <param name="rootElement">The root element in the merging EGP.</param>  
        /// <param name="elementGroupPrototype">The EGP that the user wants to merge.</param>  
        /// <returns>True if the merge is allowed</returns>  
        private bool CanMergeExampleElement(ProtoElementBase rootElement, ElementGroupPrototype elementGroupPrototype)  
        {  
          // Allow no more than 4 elements to be added:  
          return this.Elements.Count < 4;  
        }  
      }  
    }  
  
    ```  
  
     В этом простом примере ограничивает количество элементов, которые могут быть объединены в родительской модели. Условия, более интересным метод можно проверить свойства и ссылки для получения объекта. Он также может проверять свойства слияния элементов, которые передаются в <xref:Microsoft.VisualStudio.Modeling.ElementGroupPrototype>. Дополнительные сведения о `ElementGroupPrototypes`, в разделе [Настройка поведения копирования](../modeling/customizing-copy-behavior.md). Дополнительные сведения о том, как написать код, выполняющий считывание модели см. в разделе [Перемещение и обновление модели в программном коде](../modeling/navigating-and-updating-a-model-in-program-code.md).  
  
6.  Проверьте DSL:  
  
    1.  Нажмите клавишу F5, чтобы перестроить решение. Когда экспериментальный экземпляр [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] откроется, откройте экземпляр DSL.  
  
    2.  Создание новых элементов несколькими способами:  
  
        1.  Перетащите из **Пример элемента** средство на схему.  
  
        2.  В **примере обозревателя моделей**, щелкните правой кнопкой мыши корневой узел и нажмите кнопку **Добавьте пример элемента**.  
  
        3.  Скопируйте и вставьте элемент на схеме.  
  
    3.  Убедитесь, что нельзя использовать любой из этих способов добавления более четырех элементов модели. Это потому, что их директива слияния элементов.  
  
## <a name="example-adding-custom-merge-code-to-an-emd"></a>Пример: Добавление EMD слияния пользовательского кода  
 В коде для настраиваемого объединения можно определить, что происходит, когда пользователь перетаскивает средство или вставляет данные в элемент. Существует два способа определения настраиваемого объединения:  
  
1.  Задайте **слияния использует настраиваемый** и укажите требуемый код. Код заменяет слияния созданного кода. Используйте этот параметр, если требуется полностью переопределить назначение слияния.  
  
2.  Переопределение `MergeRelate` метод и при необходимости `MergeDisconnect` метод. Для этого необходимо задать **создает двойную производную** Свойства класса домена. Код может вызвать слияния созданный код в базовом классе. Используйте этот параметр, если требуется выполнить дополнительные операции после выполнения слияния.  
  
 Эти подходы влияют только на слияния, которые выполняются с использованием этого EMD. Если вы хотите повлиять на все средства, в которых можно создать объединенный элемент, альтернативой является определение `AddRule` на отношение внедрения и `DeleteRule` в классе объединенных домена. Дополнительные сведения см. в разделе [Распространение изменений в модели правил](../modeling/rules-propagate-changes-within-the-model.md).  
  
#### <a name="to-override-mergerelate"></a>Чтобы переопределить MergeRelate  
  
1.  В определении DSL убедитесь, что вы определили EMD, к которому требуется добавить код. Если требуется, можно добавить пути и определить настраиваемое принятие кода, как описано в предыдущих разделах.  
  
2.  В схеме DslDefinition выберите принимающего класса слияния. Обычно это класс в конце исходного отношения внедрения.  
  
     Например, в DSL, созданном из решения минимальный язык, выберите `ExampleModel`.  
  
3.  В **Свойства** установите **создает двойную производную** для **true**.  
  
4.  Выполните повторную сборку решения.  
  
5.  Проверить содержимое **Dsl\Generated Files\DomainClasses.cs**. Поиск методов с именами `MergeRelate` и просматривать их содержимое. Это поможет вам создавать собственные версии.  
  
6.  В новый файл кода, написать разделяемый класс для принимающего класса и переопределить `MergeRelate` метод. Не забудьте вызвать базовый метод. Например:  
  
    ```c#  
    partial class ExampleModel  
    {  
      /// <summary>  
      /// Called when the user drags or pastes an ExampleElement onto the diagram.  
      /// Sets the time of day as the name.  
      /// </summary>  
      /// <param name="sourceElement">Element to be added</param>  
      /// <param name="elementGroup">Elements to be merged</param>  
      protected override void MergeRelate(ModelElement sourceElement, ElementGroup elementGroup)  
      {  
        // Connect the element according to the EMD:  
        base.MergeRelate(sourceElement, elementGroup);  
  
        // Custom actions:   
        ExampleElement mergingElement = sourceElement as ExampleElement;  
        if (mergingElement != null)  
        {  
          mergingElement.Name = DateTime.Now.ToLongTimeString();  
        }  
      }  
    }  
  
    ```  
  
#### <a name="to-write-custom-merge-code"></a>Написание кода пользовательского слияния  
  
1.  В **Dsl\Generated Code\DomainClasses.cs**, проверки методов с именем `MergeRelate`. Эти методы создают связи между новый элемент и существующей модели.  
  
     Проверьте, методы с именами `MergeDisconnect`. Эти методы разорвать связь элемента из модели, когда удаляется.  
  
2.  В **Обозреватель DSL**, Выберите или создайте директива слияния элементов, которую нужно настроить. В **Подробные сведения о DSL** установите **слияния использует настраиваемый**.  
  
     При выборе этого параметра **процесс слияния** и **вперед слияния** параметры учитываются. Вместо этого используется код.  
  
3.  Выполните повторную сборку решения. Займет больше времени, чем обычно, так как созданные файлы кода будет обновляться из модели.  
  
     Будут отображаться сообщения об ошибках. Дважды щелкните сообщения об ошибках для получения инструкций в созданном коде. Эти инструкции предложит указать два метода `MergeRelate`*YourDomainClass* и `MergeDisconnect`*YourDomainClass*  
  
4.  Создайте методы в определение разделяемого класса в отдельном файле кода. Примеры можно проверить ранее должна предлагать вам требуется.  
  
 Код настраиваемого объединения не влияют на код, который создает объекты и отношения напрямую и не влияет на другие EMDs. Чтобы убедиться в том, что независимо от способа создания элемента реализованы дополнительные изменения, рассмотрите возможность записи `AddRule` и `DeleteRule` вместо. Дополнительные сведения см. в разделе [Распространение изменений в модели правил](../modeling/rules-propagate-changes-within-the-model.md).  
  
## <a name="redirecting-a-merge-operation"></a>Перенаправление операции объединения  
 Директива слияния прямой перенаправляет целевой объект операции слияния. Как правило новую цель является внедрение родительским исходного целевого объекта.  
  
 Например в DSL, который был создан с помощью шаблона схемы компонентов, порты встроены в компоненты. Порты, отображаются как небольшие фигуры на краю фигуры компонента. Пользователь создает порты перетаскиванием инструмента порта на форму компонента. Но иногда ошибочно перетаскиваемые пользователем средство Port существующий порт, вместо компонента, и операция завершится ошибкой. Это простой ошибки, когда существует несколько существующих портов. Чтобы помочь пользователю, чтобы избежать это неудобство, можно разрешить порты перетащить существующего порта, но действие перенаправляется родительского компонента. Операция работает так, будто целевой элемент компонента.  
  
 Можно создать директива слияния вперед в решении модели компонентов. Если скомпилировать и запустить исходного решения, вы увидите, что пользователи могут перетаскивать любое количество **входной порт** или **выходной порт** элементы из **элементов** для **компонент** элемента. Тем не менее они не смогут перетаскивать порта существующего порта. Указатель недоступен оповещения их не включен этот переход. Тем не менее, можно создать директива прямой слияния таким образом, порт, непреднамеренно удалены на существующем **входного порта** перенаправляется **компонент** элемента.  
  
#### <a name="to-create-a-forward-merge-directive"></a>Чтобы создать директива слияния вперед  
  
1.  Создание [!INCLUDE[dsl](../modeling/includes/dsl_md.md)] решения с помощью шаблона модели компонентов.  
  
2.  Отображение **Обозреватель DSL** открыв DslDefinition.dsl.  
  
3.  В **Обозреватель DSL**, разверните **классов доменов**.  
  
4.   **ComponentPort** абстрактного класса домена является базовым классом обоих **InPort** и **OutPort**. Щелкните правой кнопкой мыши **ComponentPort** и нажмите кнопку **добавьте директивы слияния новый элемент**.  
  
     Новый **директива слияния элементов** узел отображается в узле **директивы слияния элементов** узла.  
  
5.  Выберите **директива слияния элементов** узел и откройте **Подробные сведения о DSL** окна.  
  
6.  Выберите в списке класса индексирования **ComponentPort**.  
  
7.  Выберите **вперед слияния в другом домене класс**.  
  
8.  В списке выбора пути, разверните **ComponentPort**, разверните **ComponentHasPorts**, а затем выберите **компонента**.  
  
     Новый путь должен иметь примерно такой:  
  
     **ComponentHasPorts.Component/!Component**  
  
9. Сохраните решение, а затем преобразует шаблоны, щелкнув правой кнопкой **обозревателе решений** инструментов.  
  
10. Постройте и запустите это решение. Новый экземпляр [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] отображается.  
  
11. В **обозревателе**, откройте Sample.mydsl. Схемы и **элементов ComponentLanguage** отображаются.  
  
12. Перетащите **входного порта** из **элементов** в другой **входного порта.** Затем перетащите **OutputPort** для **InputPort** и затем на другой **OutputPort**.  
  
     Не должны видеть указатель недоступен, и можно будет удалить новый **входного порта** на существующую. Выберите новый **входного порта** и перетащите его на другую точку **компонента**.  
  
## <a name="see-also"></a>См. также  
 [Перемещение и обновление модели в программном коде](../modeling/navigating-and-updating-a-model-in-program-code.md)   
 [Настройка элементов и панели элементов](../modeling/customizing-tools-and-the-toolbox.md)   
 [Пример принципиальной схемы DSL](http://code.msdn.microsoft.com/Visualization-Modeling-SDK-763778e8)