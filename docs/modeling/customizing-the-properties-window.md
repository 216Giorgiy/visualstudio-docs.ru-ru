---
title: "Настройка окна свойств | Microsoft Docs"
ms.custom: ""
ms.date: "12/15/2016"
ms.prod: "visual-studio-tfs-dev14"
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "Доменный язык, окно свойств"
ms.assetid: b6658de5-4e85-4628-93b2-5cc12f63d25b
caps.latest.revision: 20
caps.handback.revision: 20
author: "alancameronwills"
ms.author: "awills"
manager: "douge"
---
# Настройка окна свойств
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

Можно настраивать внешний вид и функциональности окна свойства в доменном языке DSL, in [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)].  В определении DSL, можно задать свойства домена для каждого доменном классе.  По умолчанию при выборе экземпляр класса или на схеме или в обозревателе модели домена, каждое свойство отображается в окне свойств.  Это позволяет просматривать и редактировать значения свойств домена, даже если они не сопоставления для формирования поля на схеме.  
  
## Имена, описания и категории  
 **имя и отображаемое имя**.  В определении свойства домена отображаемое имя свойства имя, которое отображается во время выполнения в окне свойства.  Напротив, имя используется при написании программного кода, чтобы обновить свойство.  Имя должно быть именем правильного среды CLR цифробуквенным, но отображаемое имя может содержать пробелы.  
  
 При задании имени свойства в определении DSL, отображаемым именем автоматически устанавливается на копию имени.  При написании имя покрыванное Паскалем как "FuelGauge", то отображаемое имя автоматически будет содержать пространство: Горючего уровня "датчик".  Однако можно задать отображаемое имя явно к другому значению.  
  
 **Описание**.  Описание свойства домена отображается в 2 размещения:  
  
-   В нижней части окна свойства, когда пользователь выбирает свойство.  Можно использовать его для объяснения пользователю, что свойство представляет.  
  
-   В созданном коде программы.  При использовании средства документации для извлечения в документации по API, то оно появится в виде описание этого свойства в API.  
  
 **Категория** Категория заголовок в окне свойства.  
  
## Предоставление доступа к функции стиля  
 Некоторые динамических функций могут быть представлены или графических элементов *предоставляется* как свойства домена.  Функция, которая была обеспечена таким образом может быть обновлена пользователем и более легко может быть обновлена идентификатором программы.  
  
 Щелкните правой кнопкой мыши класс формы, укажите в определении DSL **Добавьте предоставляется**, а затем выберите функцию.  
  
 Можно предоставлять на фигурах **FillColor**"  **OutlineColor**"  **TextColor**"  **OutlineDashStyle**"  **OutlineThickness** и  **FillGradientMode** свойства.  Можно предоставлять на соединителях **Цвет**`,`**TextColor**"  **DashStyle**и  **Толщина** свойства.  Можно предоставлять на схемах **FillColor** и  **TextColor** свойства.  
  
## Переадресованы: Свойства отображения связанных элементов  
 Когда пользователь выбирает элемент в модели DSL пользовательского свойства элемента отображаются в окне свойства.  Однако можно также указать свойства, определенных связанных элементов.  Это полезно, если вы определили группу в составе элементы, которая работает вместе.  Например, можно указать основной элемент и необязательный элемент подключаемого модуля.  Если главный элемент сопоставляется к фигуре, а другое нет, то полезно посмотреть все их свойства, как если бы они находились в одном элементе.  
  
 Этот результат называется *переадресованы свойства*и вызываются автоматически в нескольких случаях.  В других случаях можно добиться свойства переадресуя путем указания дескриптора типа домена.  
  
### Свойство по умолчанию переадресуя case  
 Когда пользователь выбирает фигуры или соединитель или элемент в обозревателе следующие свойства отображаются в окне свойства:  
  
-   Свойства домена, определенные на доменном классе элемента модели, включая те, которые определены в базовых классах.  Исключение свойства домена, для которых имеется набор **Отображается** В  `False`.  
  
-   Имена элементов, связанных в связи с количеством элементов 0..1.  Это обеспечивает удобный метод видеть при необходимости связанные элементы, даже если не указанные сопоставление соединителя для связи.  
  
-   Содержит свойства домена связи, предназначен для элемента.  Поскольку внедрение связи обычно не указывает явно, это позволяет пользователю видеть их свойства.  
  
-   Свойства домена, определенные для выбранных фигуры или соединителе.  
  
### Добавление переадресованы свойства  
 Чтобы переадресованы свойство можно указать дескриптор типа домена.  При наличии доменную связь между 2 доменными классами, можно использовать дескриптор типа домена для задания свойства домена в первом классе свойства домена в доменном классе.  Например, если существует отношение между классом и доменным классом доменным книги автора, можно использовать дескриптор типа домена для свойства имя автора книги отображаться в окне свойств при выборе пользователем книги.  
  
> [!NOTE]
>  Переадресованы свойства затрагивает только окно свойств, когда пользователь изменяет модели.  Оно не задает свойство домена на принимающей классе.  Если необходимо получить доступ к переадресованное свойство домена в других частях определения DSL либо в коде программы, необходимо получить доступ к элементу препровождения.  
  
 В следующей процедуре предполагается, что вы создали DSL.  В первых шагах объединяют условия.  
  
##### Переадресованы свойство из другого элемента  
  
1.  Create a [!INCLUDE[dsl](../modeling/includes/dsl_md.md)] решения, содержащего не менее 2 класса, который в данном примере вызываются Книгой и автором.  Должно быть любого типа связи между книгой и автором.  
  
     Количество элементов в роли источника \(роли на стороне книги\) должно быть 0..1 или 1..1, так что каждая книга будет иметь одного автора.  
  
2.  IN **Обозреватель DSL**щелкните правой кнопкой мыши доменный класс книги, а затем выберите команду  **Добавьте новое DomainTypeDescriptor**.  
  
     Узел с именем **Пути дескрипторов пользовательских свойств** отображается под  **Настраиваемый дескриптор типа** узел.  
  
3.  Щелкните правой кнопкой мыши **Настраиваемый дескриптор типа** узел и нажмите кнопку  **Добавьте новое PropertyPath**.  
  
     Новый путь свойства отображается под **Пути дескрипторов пользовательских свойств** узел.  
  
4.  Выберите новый путь свойства и в **Свойства** окно, набор  **Путь к свойству** в пути соответствующего элемента модели.  
  
     Можно изменить путь в представлении в виде дерева, щелкните стрелку вниз справа от этого свойства.  Дополнительные сведения о путях домена см. в разделе [Синтаксис пути домена](../modeling/domain-path-syntax.md).  После редактирования его путь должен напоминать **BookReferencesAuthor.Author\/\! Автор**.  
  
5.  Установка **Свойство** к  **Name** свойство author домена.  
  
6.  Установка **Отображаемое имя** имя автора.  
  
7.  Преобразовать все шаблоны, построение и выполнение DSL.  
  
8.  В схеме модели, создание книги автора и свяжите их с помощью связи ссылки.  Выберите элемент книги, и в окне свойств появится имя автора в дополнение к свойствам книги.  Измените имя связанного автора или автору книги ссылку на другой, и убедитесь, что имя автора книги.  
  
## Редакторы пользовательских свойств  
 Окно свойства предоставляет соответствующее редактирования по умолчанию для типа каждого свойства домена.  Например, для перечислимого типа, пользователь видит раскрывающегося списка, а для числового свойства, пользователь может вводить цифры.  Это верно только для встроенных типов.  Если указать внешний тип, то у пользователя будет видеть значения свойства, но нельзя изменять их.  
  
 Однако можно задать следующие редакторы и типы:  
  
1.  Другой редактор, используемый с стандартным типом.  Например, можно указать редактор пути к файлу для строкового свойства.  
  
2.  Внешний тип для свойства домена и редактор.  
  
3.  Редактор .NET, таких как редактор пути к файлу или можно создать собственный редактор настраиваемых свойств.  
  
     Преобразование между внешним типом и типом в виде строки, которой принадлежит редактор по умолчанию.  
  
 в DSL, *внешний вид* любой тип, который не является одной из простых типов \(в качестве логического или Int32\) или строки.  
  
#### Определить свойство домена, имеющую внешний вид  
  
1.  IN **Обозреватель решений**добавьте ссылку на сборку \(DLL\), содержащей внешний тип в  **Dsl** этот проект.  
  
     Сборка может быть сборкой .NET или сборкой предоставленной пользователем.  
  
2.  Добавьте тип **Типы домена** перечислите, если это уже не будет.  
  
    1.  Откройте DslDefinition.dsl и in **Обозреватель DSL**щелкните правой кнопкой мыши корневой узел, а затем выберите команду  **Добавьте новый внешний вид**.  
  
         Новая запись отображается под **Типы домена** узел.  
  
        > [!WARNING]
        >  Пункт меню не в корневом узле DSL **Типы домена** узел.  
  
    2.  Задайте имя и пространство имен в окне свойства.  
  
3.  Добавьте свойство к классу домена доменному обычным способом.  
  
     В окне свойства выберите внешний тип из раскрывающегося списка в **тип** поле.  
  
 В этот момент пользователи могут просматривать значения свойств, но они не могут изменять его.  Показанные значения получаются из `ToString()` функция.  Можно написать программный код, который устанавливает значение свойства, например в команде или правило.  
  
### Установка редактор свойств  
 Добавьте атрибут среды CLR к свойству домена, в следующей форме:  
  
```  
[System.ComponentModel.Editor (  
   typeof(AnEditor),  
   typeof(System.Drawing.Design.UITypeEditor))]  
  
```  
  
 Можно установить свойства, используя атрибут **Настраиваемый атрибут** записи в окне свойства.  
  
 Тип  `AnEditor` быть производным от типа, заданного во втором параметре.  Второй параметр должен быть одним <xref:System.Drawing.Design.UITypeEditor> OR  <xref:System.ComponentModel.ComponentEditor>.  Дополнительные сведения см. в разделе <xref:System.ComponentModel.EditorAttribute>.  
  
 Можно указать собственный редактор или редактор в предоставленный [!INCLUDE[.net framework]()]как  <xref:System.Windows.Forms.Design.FileNameEditor> OR  <xref:System.Drawing.Design.ImageEditor>.  Например, используйте следующую процедуру для иметь свойство, в котором пользователь может ввести имя файла.  
  
##### Определить свойство домена имени файла  
  
1.  Добавьте свойство к классу доменному домена DSL в своем определении.  
  
2.  Выберите новое свойство.  в **Настраиваемый атрибут** поле в окне свойства введите следующий атрибут.  Чтобы ввести этот атрибут, нажмите кнопку с многоточием \[...\] затем введите имя атрибута и параметры отдельно.  
  
    ```  
    [System.ComponentModel.Editor (  
       typeof(System.Windows.Forms.Design.FileNameEditor)  
       , typeof(System.Drawing.Design.UITypeEditor))]  
  
    ```  
  
3.  Оставьте тип свойства домена в качестве параметра по умолчанию **Строка**.  
  
4.  Чтобы тестирование редактора, убедитесь в том, что пользователи могут открыть редактор имени файла для редактирования свойство домена.  
  
    1.  Нажмите клавиши CTRL\+F5 или F5.  В решении отладки, откройте тестовый файл.  Создайте элемент доменного класса и выберите его.  
  
    2.  В окне свойства выберите свойство домена.  Поле значение отображается многоточие \[...\].  
  
    3.  Нажмите кнопку с многоточием \(...\).  Диалоговое окно файла.  Выберите файл и закрыть диалоговое окно.  Путь к файлу теперь значение свойства домена.  
  
### Указание собственный редактор свойств  
 Можно указать собственный редактор.  Необходимо выполнить это, чтобы разрешить пользователю, чтобы изменить тип, который вы определили или изменять стандартное введите особым образом.  Например, можно разрешить пользователю вход строка, представляющая формулу.  
  
 Указать редактор написать класс, производный от <xref:System.Drawing.Design.UITypeEditor>.  Класс должен переопределять:  
  
-   <xref:System.Drawing.Design.UITypeEditor.EditValue%2A>взаимодействие с пользователем, и обновить значение свойства.  
  
-   <xref:System.Drawing.Design.UITypeEditor.GetEditStyle%2A>определить, является ли редактор, будет открыто диалоговое окно или обеспечит раскрывающееся меню.  
  
 Можно также предоставить графическое представление значения свойства, которая будет отображаться в сетке свойств.  Это сделать, переопределение `GetPaintValueSupported`и  `PaintValue`.  Дополнительные сведения см. в разделе <xref:System.Drawing.Design.UITypeEditor>.  
  
> [!NOTE]
>  Добавьте код в отдельном файле кода **Dsl** этот проект.  
  
 Примеры.  
  
```  
internal class TextFileNameEditor : System.Windows.Forms.Design.FileNameEditor  
{  
  protected override void InitializeDialog(System.Windows.Forms.OpenFileDialog openFileDialog)  
  {  
    base.InitializeDialog(openFileDialog);  
    openFileDialog.Filter = "Text files(*.txt)|*.txt|All files (*.*)|*.*";  
    openFileDialog.Title = "Select a text file";  
  }  
}  
  
```  
  
 Чтобы использовать этот редактор, установите **Настраиваемый атрибут** свойства домена.  
  
```  
[System.ComponentModel.Editor (  
   typeof(MyNamespace.TextFileNameEditor)  
   , typeof(System.Drawing.Design.UITypeEditor))]  
  
```  
  
 Дополнительные сведения см. в разделе <xref:System.Drawing.Design.UITypeEditor>.  
  
## Защита раскрывающегося списка значений  
 Можно предоставить список значений для пользователя для выбора.  
  
> [!NOTE]
>  Этот метод предоставляет список значений, которые могут изменяться во время выполнения.  Если требуется предоставить список, который не меняется, попробуйте вместо этого использовать перечислимый тип как тип своего свойства домена.  
  
 Чтобы указать список стандартных значений, добавляемые к пользовательскому свойству домена атрибут среды CLR, который имеет следующую форму:  
  
```  
[System.ComponentModel.TypeConverter   
(typeof(MyTypeConverter))]  
  
```  
  
 Определите класс, производный от класса <xref:System.ComponentModel.TypeConverter>.  Добавьте код в отдельном файле в **Dsl** этот проект.  Примеры.  
  
```c#  
/// <summary>  
/// Type converter that provides a list of values   
/// to be displayed in the property grid.  
/// </summary>  
/// <remarks>This type converter returns a list   
/// of the names of all "ExampleElements" in the   
/// current store.</remarks>  
public class MyTypeConverter : System.ComponentModel.TypeConverter  
{  
  /// <summary>  
  /// Return true to indicate that we return a list of values to choose from  
  /// </summary>  
  /// <param name="context"></param>  
  public override bool GetStandardValuesSupported  
    (System.ComponentModel.ITypeDescriptorContext context)  
  {  
    return true;  
  }  
  
  /// <summary>  
  /// Returns true to indicate that the user has   
  /// to select a value from the list  
  /// </summary>  
  /// <param name="context"></param>  
  /// <returns>If we returned false, the user would   
  /// be able to either select a value from   
  /// the list or type in a value that is not in the list.</returns>  
  public override bool GetStandardValuesExclusive  
      (System.ComponentModel.ITypeDescriptorContext context)  
  {  
    return true;  
  }  
  
  /// <summary>  
  /// Return a list of the values to display in the grid  
  /// </summary>  
  /// <param name="context"></param>  
  /// <returns>A list of values the user can choose from</returns>  
  public override StandardValuesCollection GetStandardValues  
      (System.ComponentModel.ITypeDescriptorContext context)  
  {  
    // Try to get a store from the current context  
    // "context.Instance"  returns the element(s) that   
    // are currently selected i.e. whose values are being  
    // shown in the property grid.   
    // Note that the user could have selected multiple objects,   
    // in which case context.Instance will be an array.  
    Store store = GetStore(context.Instance);  
  
    List<string> values = new List<string>();  
  
    if (store != null)  
    {  
      values.AddRange(store.ElementDirectory  
        .FindElements<ExampleElement>()  
        .Select<ExampleElement, string>(e =>   
      {  
        return e.Name;  
      }));  
    }  
    return new StandardValuesCollection(values);  
  }  
  
  /// <summary>  
  /// Attempts to get to a store from the currently selected object(s)  
  /// in the property grid.  
  /// </summary>  
  private Store GetStore(object gridSelection)  
  {  
    // We assume that "instance" will either be a single model element, or   
    // an array of model elements (if multiple items are selected).  
  
    ModelElement currentElement = null;  
  
    object[] objects = gridSelection as object[];  
    if (objects != null && objects.Length > 0)  
    {  
      currentElement = objects[0] as ModelElement;  
    }  
    else  
    {  
        currentElement = gridSelection as ModelElement;  
    }  
  
    return (currentElement == null) ? null : currentElement.Store;  
  }  
  
}  
  
```  
  
## См. также  
 [Перемещение по модели и обновление модели в коде программы](../modeling/navigating-and-updating-a-model-in-program-code.md)