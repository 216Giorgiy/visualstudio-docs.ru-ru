---
title: Установка контрольных значений для переменных в Visual Studio | Документация Майкрософт
ms.custom: H1Hack27Feb2017
ms.date: 04/04/2017
ms.technology: vs-ide-debug
ms.topic: conceptual
f1_keywords:
- vs.debug.watch
helpviewer_keywords:
- debugging [Visual Studio], Watch window
- expressions [debugger], evaluating
- variables [debugger], evaluating
- expression evaluation
- registers, evaluating
- debugging [Visual Studio], expression evaluation
author: mikejo5000
ms.author: mikejo
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: aaba3f16ccf08fa56e6f529192ae9ad9cab6d496
ms.sourcegitcommit: 55f7ce2d5d2e458e35c45787f1935b237ee5c9f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2018
ms.locfileid: "42635441"
---
# <a name="set-a-watch-on-variables-using-the-watch-and-quickwatch-windows-in-visual-studio"></a>Установка контрольных значений для переменных с помощью контрольных значений и "Быстрая проверка" Windows в Visual Studio
При отладке, можно использовать **Watch** и **"Быстрая проверка"** для наблюдения за переменными и выражениями.  Отличие в том, что в окне **Контрольные значения** могут одновременно выводиться несколько переменных, а в окне **Быстрая проверка** — только одна. 

Windows доступны только во время сеанса отладки. Чтобы открыть **Watch** окно, выберите **Отладка > Windows > Контрольные значения > Контрольные значения (1, 2, 3, 4)**). Чтобы открыть **"Быстрая проверка"** окна, или щелкните правой кнопкой мыши на переменную, а выберите **"Быстрая проверка"** или выберите **Отладка > Быстрая проверка**.
  
## <a name="observing-a-single-variable-with-quickwatch"></a>Наблюдение за одной переменной с помощью окна "Быстрая проверка"  
 Окно **Быстрая проверка** можно использовать для наблюдения за одной переменной. Например, предположим, что имеется следующий код:  
  
```csharp
static void Main(string[] args)  
{  
    int a, b;  
    a = 1;  
    b = 2;  
    for (int i = 0; i < 10; i++)  
    {  
        a = a + b;  
    }   
}  
```  
  
 Вы можете наблюдать за переменной в окне "Быстрая проверка" следующим образом:  
  
1.  Установите точку останова на строке `a = a + b;` .  
  
2.  Приступите к отладке. Выполнение прекратится в точке останова.  
  
3.  Откройте **"Быстрая проверка"** окна (щелкните правой кнопкой мыши `a`, затем выберите **"Быстрая проверка"**, или выберите `a` и нажмите клавишу **SHIFT + F9**).

    Вы должны увидеть переменной в **значения** окно со значением 1.

    ![Выражение "Быстрая проверка"](../debugger/media/watchexpression.png "QuickWatchExpression")  

    Если вы хотите вычислить выражение, с помощью переменной, добавьте выражение например `a + b` для **выражение** и щелкните **пересчитать**. 
  
4.  Добавить переменную **Watch** окна из **"Быстрая проверка"** , щелкнув **Добавить контрольное значение**. 

    > [!NOTE]
    > **"Быстрая проверка"** — это модальное диалоговое окно, поэтому вы не можете продолжать отладку, пока он открыт.  
  
5.  Закройте окно **Быстрая проверка** . Теперь вы можете продолжать отладку, наблюдая за значением в окне **Контрольные значения** .  
  
## <a name="observing-variables-with-the-watch-window"></a>Наблюдение за переменными в окне "Контрольные значения"  
 С помощью окна **Контрольные значения** можно наблюдать за несколькими переменными. Например, предположим, что имеется следующий код:  
  
```C++  
int main()
{
    int a, b, c;
    a = 1;
    b = 2;
    c = 0;

    for (int i = 0; i < 10; i++)
    {
        a++;
        b *= 2;
        c = a + b;
    }

    return 0;
}
  
```  
  
 Добавьте значения трех переменных в окно "Контрольные значения", выполнив указанные ниже действия.  
  
1.  Установите точку останова на строке `c = a + b;` .  
  
2.  Начните отладку (**F5**). Выполнение прекратится в точке останова.  
  
3.  Откройте окно контрольных значений (**Отладка > Windows > Контрольные значения > Контрольные значения 1**, или **CTRL + ALT + W, 1**).  
  
4.  Добавьте переменную `a` в первую строку, переменную `b` — во вторую строку, а переменную `c` — в третью строку.

    Можно создавать переменные, щелкнув пустую строку и введя имя переменной.
  
5.  Продолжить отладку (нажмите клавишу **F11** для развития отладчик).  
  
 В процессе итерации по циклу `for` значения переменных должны меняться.  
  
 При программировании в машинных кодах иногда может потребоваться уточнить контекст имени переменной или выражения, содержащего имя переменной. Контекст — это функция, файл исходного кода и модуль, где находится переменная. Если вам нужно определить контекст, можно использовать синтаксис оператора контекста. Для получения дополнительной информации см. [Context Operator (C++)](../debugger/context-operator-cpp.md).  
  
## <a name="observing-expressions-with-the-watch-window"></a>Наблюдение за выражениями в окне "Контрольные значения"  
 Теперь давайте попробуем использовать выражение. Добавить можно любое допустимое выражение, которое распознает отладчик.  
  
 Например, если имеется код, приведенный в предыдущем разделе, можно вычислить среднее трех значений следующим образом:  
  
 ![Посмотреть выражение](../debugger/media/watchexpression.png "WatchExpression")  
  
 В целом правила вычисления выражений в окне **Контрольные значения** аналогичны правилам вычисления выражений в используемом языке программирования. Если в выражении есть синтаксическая ошибка, должна произойти та же ошибка компилятора, которая возникла бы в редакторе кода. Ниже приведен пример:  
  
 ![Просмотрите ошибки выражение](../debugger/media/watchexpressionerror.png "WatchExpressionError")  
  
##  <a name="bkmk_refreshWatch"></a> Обновление устаревших контрольных значений  
 В некоторых случаях может появиться значок обновления (круговой стрелки) при вычислении выражения в **Watch** окна.  Например, если у вас есть отключить вычисление свойств (**Сервис > Параметры > Отладка > Включить вычисление свойств и другие неявные вызовы функций**), и у вас есть следующий код:  
  
```csharp  
static void Main(string[] args)  
{  
    List<string> list = new List<string>();  
    list.Add("hello");  
    list.Add("goodbye");  
}  
  
```  
  
 Если вы устанавливаете наблюдение за свойством `Count` списка, то должны увидеть что-то подобное:  
  
 ![RefreshWatch](../debugger/media/refreshwatch.png "RefreshWatch")  
  
 Ошибка или значение, устарела на предыдущем рисунке. Обычно можно обновить значение, щелкнув значок, но в некоторых случаях может быть предпочтительнее не делать этого. Сначала нужно узнать, почему значение не было рассчитано.  
  
 При наведении указателя мыши на значок отображается всплывающая подсказка, в которой указаны причины, по которым нельзя вычислить значение выражения.  Значок с изогнутыми стрелками может отображаться по следующим причинам:  
  
-   При вычислении выражения возникла ошибка. Например, истекло время ожидания или переменная находилась вне области действия.  
  
-   Выражение содержит вызов функции, который мог вызвать побочный эффект в приложении (см. в разделе [побочные эффекты и выражения](#bkmk_sideEffects)).  
  
-   Автоматическое вычисление свойств и неявных вызовов функций отладчиком отключено (**Сервис > Параметры > Отладка > Включить вычисление свойств и другие неявные вызовы функций**), и затем выражение не может быть автоматическая оценка.  
  
 Чтобы обновить значение, щелкните значок обновления или нажмите клавишу ПРОБЕЛ. Отладчик попытается пересчитать выражение. Если значок обновления отображался из-за отключения автоматического вычисления свойств и другие неявные вызовы функций, можно вычислить выражение.  
  
 Если появляется значок в виде кружка с двумя волнистыми линиями, выражение не было вычислено из-за возможной зависимости между потоками. Иными словами, для вычисления коду требуется временно запустить другие потоки в приложении. Как правило, при нахождении в режиме приостановки выполнения все потоки в приложении остановлены. Разрешение временного запуска других потоков может привести к непредвиденным результатам, а также привести к тому, что отладчик будет игнорировать различные события, например точки останова и исключения, созданные в этих потоках.  
  
##  <a name="bkmk_sideEffects"></a> Side Effects and Expressions  
 Вычисление некоторых выражений может привести к изменению значения некоторой переменной или иным образом повлиять на состояние программы. Например, вычисление следующего выражения изменяет значение `var1`:  
  
```csharp
var1 = var2  
```  
  
 Этот код может привести к [побочный эффект](https://en.wikipedia.org/wiki/Side_effect_\(computer_science\)). Побочные эффекты могут усложнить отладку из-за изменения способа работы программы.  
  
 Выражение, которое имеет побочные эффекты, вычисляется только один раз, при первом его вводе. Последующие вычисления не выполняются. Этот режим можно отменить, щелкнув значок обновления, который стоит рядом со значением.  
  
 Один из способов избежать любых побочных эффектов — отключить автоматическое вычисление функций (**Сервис > Параметры > Отладка > Включить вычисление свойств и другие неявные вызовы функций**).  
  
 Если вычисление свойств и неявных вызовов функций отключено, можно принудительно вычислить выражение с помощью модификатора формата **ac** (только в C#). См. раздел [Format Specifiers in C#](../debugger/format-specifiers-in-csharp.md).  
  
## <a name="bkmk_objectIds"></a> Использование идентификаторов объектов в окне "Контрольные значения" (C# и Visual Basic)  

 Бывают случаи, когда необходимо наблюдать за поведением определенного объекта. Например может потребоваться отслеживать объект, на который ссылается локальная переменная после эта переменная вышла за пределы области действия. В C# и Visual Basic можно создавать идентификаторы объектов для определенных экземпляров ссылочных типов и использовать их в окне "Контрольные значения" и условиях точек останова. Идентификатор объекта создается службами отладки среды CLR и связан с объектом.  
  
> [!NOTE]
>  Идентификаторы объектов создают слабые ссылки и не предотвращают сборку мусора для объекта. Они действительны только в рамках текущего сеанса отладки.  
  
 В следующем коде создается один метод `Person` с помощью локальной переменной, но вы хотите узнать, что `Person`его имя — в другом методе:  
  
```csharp  
class Person  
{  
    public Person(string name)  
    {  
        Name = name;  
    }  
    public string Name { get; set; }  
}  
  
public class Program  
{  
    List<Person> _people = new List<Person>();  
    public static void Main(string[] args)  
    {  
        MakePerson();  
        DoSomething();  
    }  
  
    private static void MakePerson()  
    {  
        var p = new Person("Bob");  
        _people.Add(p);  
    }  
  
    private static void DoSomething()  
    {  
        // more processing  
         Console.WriteLine("done");  
    }  
}  
  
```  
  
 Вы можете добавить ссылку на этот объект `Person` в окно **Контрольные значения** , выполнив указанные ниже действия.  
  
1.  Установите точку останова в коде после создания объекта.  
  
2.  Начните отладку и, когда выполнение остановится в точке останова, найдите переменную в окне **Локальные** , щелкните ее правой кнопкой мыши и выберите пункт **Создать идентификатор объекта**.  
  
3.  Вы должны увидеть **$** символ **"Локальные"** окно, которое представляет идентификатор объекта.  
  
4.  Добавьте идентификатор объекта в окно "Контрольные значения".  
  
5.  Установите точку останова, в которой вы хотите наблюдать за поведением объекта.  В приведенном выше коде это место находится внутри `DoSomething()` метод.  
  
6.  Продолжайте отладку и, когда выполнение остановится в методе `DoSomething()` , в окне **Контрольные значения** отобразится объект `Person` .  
  
> [!NOTE]
>  Если вы хотите увидеть свойства объекта, например `Person.Name` в приведенном выше примере, необходимо включить вычисление свойств.  
  
## <a name="using-registers-in-the-watch-window-c-only"></a>Использование регистров в окне "Контрольные значения" (только C++)  
 При отладке машинного кода, можно добавить имена регистров, а также имена переменных с помощью  **$ \<имя регистра >** или  **@ \<имя регистра >**.  Для получения дополнительной информации см. [Pseudovariables](../debugger/pseudovariables.md).  
  
## <a name="dynamic-view-and-the-watch-window"></a>Динамическое представление и окно контрольных значений  
 Некоторых скриптовых языках (например, JavaScript или Python) используется динамическая или [типизации по признакам](https://en.wikipedia.org/wiki/Duck_typing), и языках .NET (в версии 4.0 и более поздних) поддерживаются объекты, которые трудно наблюдать с помощью обычных окон отладки, так как они Возможно, среда выполнения свойства и методы, которые нельзя отобразить.  
  
 Когда окно наблюдения отображает объект, созданный из типа, который реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>, отладчик добавляет специальный **динамическое представление** узел **"Видимые"** отображения. В этом узле показаны динамические члены динамического объекта, но не разрешено изменять их значения.  
  
 Если щелкнуть правой кнопкой мыши любой дочерний объект узла **Динамическое представление** и выбрать пункт **Добавить контрольное значение**, отладчик вставит новую контрольную переменную, которая приводит объект к динамическому объекту. Иными словами, **object Name** становится (**(dynamic)object).Name**.  
  
 Вычисление членов **динамического представления** может иметь побочные эффекты. Объяснение того, что такое побочные эффекты, см. в разделе [Side Effects and Expressions](#bkmk_sideEffects). Для C# отладчик автоматически не пересчитывает значения, отображаемые в **Динамическом представлении** при переходе на новую строку кода. В Visual Basic выражения, добавляемые с помощью **динамического представления** , автоматически обновляются.  
  
 Инструкции по обновлению значений динамического представления см. в разделе [Обновление устаревших контрольных значений](#bkmk_refreshWatch).  
  
 Если нужно отобразить только **динамическое представление** объекта, можно использовать описатель формата **dynamic** .  
  
-   C#: **ИмяОбъекта, dynamic**  
  
-   Visual Basic: **$dynamic, ИмяОбъекта**  
  
 **Динамическое представление** также улучшает процесс отладки для COM-объектов. Когда отладчик встречает COM-объект, инкапсулированный в **System.__ComObject**, он добавляет узел **Динамическое представление** для объекта.  
  
## <a name="see-also"></a>См. также  
 [Окна отладчика](../debugger/debugger-windows.md)
