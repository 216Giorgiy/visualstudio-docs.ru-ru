---
title: "Значение контрольного значения с переменными в Visual Studio | Документы Microsoft"
ms.custom: H1Hack27Feb2017
ms.date: 04/04/2017
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-debug
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: vs.debug.watch
helpviewer_keywords:
- debugging [Visual Studio], Watch window
- expressions [debugger], evaluating
- variables [debugger], evaluating
- expression evaluation
- registers, evaluating
- debugging [Visual Studio], expression evaluation
ms.assetid: d5c18377-2a0e-4819-a645-407e24ccc58c
caps.latest.revision: "45"
author: mikejo5000
ms.author: mikejo
manager: ghogen
ms.openlocfilehash: 8792c9ed175d2ced5d9c10cc19b2d222f4d839a8
ms.sourcegitcommit: f40311056ea0b4677efcca74a285dbb0ce0e7974
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2017
---
# <a name="set-a-watch-on-variables-using-the-watch-and-quickwatch-windows-in-visual-studio"></a>Задать контрольного значения для переменных с помощью окна "Быстрая проверка" в Visual Studio и контрольных значений
При отладке, можно использовать **Контрольные значения** (**Отладка > Windows > Контрольные значения > Контрольные значения (1, 2, 3, 4)**) и **Быстрая проверка** (щелкните правой кнопкой мыши на переменную или  **Отладка > Быстрая проверка**) windows, чтобы контролировать значения переменных и выражений.  Отличие в том, что в окне **Контрольные значения** могут одновременно выводиться несколько переменных, а в окне **Быстрая проверка** — только одна.

Windows доступны только во время сеанса отладки. 
  
## <a name="observing-a-single-variable-with-quickwatch"></a>Наблюдение за одной переменной с помощью окна "Быстрая проверка"  
 Окно **Быстрая проверка** можно использовать для наблюдения за одной переменной. Например, предположим, что имеется следующий код:  
  
```CSharp
static void Main(string[] args)  
{  
    int a, b;  
    a = 1;  
    b = 2;  
    for (int i = 0; i < 10; i++)  
    {  
        a = a + b;  
    }   
}  
```  
  
 Можно наблюдать переменной в окне "Быстрая проверка" следующим образом:  
  
1.  Установите точку останова на строке `a = a + b;` .  
  
2.  Приступите к отладке. Выполнение прекратится в точке останова.  
  
3.  Откройте окно **Быстрая проверка** (щелкните переменную правой кнопкой мыши и выберите пункт **Быстрая проверка**или нажмите клавиши **SHIFT+F9**).

    Вы увидите переменной в **значения** окна со значением 1.

    ![Выражения быстрой проверки](../debugger/media/watchexpression.png "QuickWatchExpression")  

    Если требуется вычислить выражение, с помощью переменной, добавьте выражение например `a + b` для **выражение** и щелкните **пересчитать**. 
  
4.  Добавить переменную **Контрольные значения** окна из **Быстрая проверка** , щелкнув **Добавить контрольное значение**. 

    > [!NOTE]
    > **Быстрая проверка** окно является модального диалогового окна, поэтому не позволит продолжить отладку, пока он открыт.  
  
5.  Закройте окно **Быстрая проверка** . Теперь вы можете продолжать отладку, наблюдая за значением в окне **Контрольные значения** .  
  
## <a name="observing-variables-with-the-watch-window"></a>Наблюдение за переменными в окне "Контрольные значения"  
 С помощью окна **Контрольные значения** можно наблюдать за несколькими переменными. Например, предположим, что имеется следующий код:  
  
```C++  
int main()
{
    int a, b, c;
    a = 1;
    b = 2;
    c = 0;

    for (int i = 0; i < 10; i++)
    {
        a++;
        b *= 2;
        c = a + b;
    }

    return 0;
}
  
```  
  
 Добавьте значения трех переменных в окно "Контрольные значения", выполнив указанные ниже действия.  
  
1.  Установите точку останова на строке `c = a + b;` .  
  
2.  Начните отладку (**F5**). Выполнение прекратится в точке останова.  
  
3.  Откройте окно контрольного значения (**Отладка > Windows > Контрольные значения > Контрольные значения 1**, или **CTRL + ALT + W, 1**).  
  
4.  Добавьте переменную `a` в первую строку, переменную `b` — во вторую строку, а переменную `c` — в третью строку.

    Переменные можно добавить, щелкнув пустую строку и введите имя переменной.
  
5.  Продолжить отладку (нажмите клавишу **F11** перемещаться отладчик).  
  
 В процессе итерации по циклу `for` значения переменных должны меняться.  
  
 При программировании в машинных кодах иногда может потребоваться уточнить контекст имени переменной или выражения, содержащего имя переменной. Контекст — это функция, файл исходного кода и модуль, где находится переменная. Если необходимо определить контекст, можно использовать синтаксис оператора контекста. Для получения дополнительной информации см. [Context Operator (C++)](../debugger/context-operator-cpp.md).  
  
## <a name="observing-expressions-with-the-watch-window"></a>Наблюдение за выражениями в окне "Контрольные значения"  
 Теперь попробуем использовать выражение. Добавить можно любое допустимое выражение, которое распознает отладчик.  
  
 Например, если имеется код, приведенный в предыдущем разделе, можно вычислить среднее трех значений следующим образом:  
  
 ![Контрольное выражение](../debugger/media/watchexpression.png "WatchExpression")  
  
 В целом правила вычисления выражений в окне **Контрольные значения** аналогичны правилам вычисления выражений в используемом языке программирования. Если в выражении есть синтаксическая ошибка, должна произойти та же ошибка компилятора, которая возникла бы в редакторе кода. Ниже приведен пример:  
  
 ![Просмотрите ошибки выражение](../debugger/media/watchexpressionerror.png "WatchExpressionError")  
  
##  <a name="bkmk_refreshWatch"></a> Обновление устаревших контрольных значений  
 В некоторых случаях может появиться значок обновления (циклическая стрелка) при вычислении выражения в **Контрольные значения** окна.  Например, если у вас есть вычисление свойств выключено (**Сервис > Параметры > Отладка > Включить вычисление свойств и другие неявные вызовы функций**), и имеется следующий код:  
  
```CSharp  
static void Main(string[] args)  
{  
    List<string> list = new List<string>();  
    list.Add("hello");  
    list.Add("goodbye");  
}  
  
```  
  
 Если вы устанавливаете наблюдение за свойством `Count` списка, то должны увидеть что-то подобное:  
  
 ![RefreshWatch](../debugger/media/refreshwatch.png "RefreshWatch")  
  
 На предыдущем рисунке показаны ошибки или значение, которое является устаревшим. Обычно можно обновить значение, щелкнув значок, но в некоторых случаях может быть предпочтительнее не делать этого. Сначала нужно узнать, почему значение не было рассчитано.  
  
 При наведении указателя мыши на значок отображается всплывающая подсказка, в которой указаны причины, по которым нельзя вычислить значение выражения.  Значок с изогнутыми стрелками может отображаться по следующим причинам:  
  
-   При вычислении выражения возникла ошибка. Например, истекло время ожидания или переменная находилась вне области действия.  
  
-   Выражение содержит вызов функции, который мог вызвать побочный эффект в приложении (см. [побочные эффекты и выражения](#bkmk_sideEffects)).  
  
-   Автоматическое вычисление свойств и неявных вызовов функций отладчиком отключено (**Сервис > Параметры > Отладка > Включить вычисление свойств и другие неявные вызовы функций**), и затем выражение не может быть вычисляется автоматически.  
  
 Чтобы обновить значение, щелкните значок обновления или нажмите клавишу ПРОБЕЛ. Отладчик попытается пересчитать выражение. Если значок обновления отображался из-за отключения автоматического вычисления свойств и другие неявные вызовы функций, можно оценить выражение.  
  
 Если появляется значок в виде кружка с двумя волнистыми линиями, выражение не было вычислено из-за возможной зависимости между потоками. Иными словами, для вычисления коду требуется временно запустить другие потоки в приложении. Как правило, при нахождении в режиме приостановки выполнения все потоки в приложении остановлены. Разрешение временного запуска других потоков может привести к непредвиденным результатам, а также привести к тому, что отладчик будет игнорировать различные события, например точки останова и исключения, созданные в этих потоках.  
  
##  <a name="bkmk_sideEffects"></a> Side Effects and Expressions  
 Вычисление некоторых выражений может привести к изменению значения некоторой переменной или иным образом повлиять на состояние программы. Например, вычисление следующего выражения изменяет значение `var1`:  
  
```  
var1 = var2  
```  
  
 Этот код может привести к [побочный эффект](https://en.wikipedia.org/wiki/Side_effect_\(computer_science\)). Побочные эффекты могут усложнить отладку из-за изменения способа работы программы.  
  
 Выражения, имеющего побочные эффекты, вычисляется только один раз, при первом его вводе. Последующие вычисления не выполняются. Этот режим можно отменить, щелкнув значок обновления, который стоит рядом со значением.  
  
 Один из способов избежать любых побочных эффектов — отключить автоматическое вычисление функций (**Сервис > Параметры > Отладка > Включить вычисление свойств и другие неявные вызовы функций**).  
  
 Если вычисление свойств и неявных вызовов функций отключено, можно принудительно вычислить выражение с помощью модификатора формата **ac** (только в C#). См. раздел [Format Specifiers in C#](../debugger/format-specifiers-in-csharp.md).  
  
## <a name="bkmk_objectIds"></a> Использование идентификаторов объектов в окне "Контрольные значения" (C# и Visual Basic)  

 Бывают случаи, когда необходимо посмотреть поведение конкретного объекта. Например может потребоваться отслеживать объект, на который ссылается локальная переменная после эта переменная вышла за пределы области. В C# и Visual Basic можно создавать идентификаторы объектов для определенных экземпляров ссылочных типов и использовать их в окне "Контрольные значения" и условиях точек останова. Идентификатор объекта создается службами отладки среды CLR и связан с объектом.  
  
> [!NOTE]
>  Идентификаторы объектов создают слабые ссылки и не предотвращают сборку мусора для объекта. Они действительны только в рамках текущего сеанса отладки.  
  
 В приведенном ниже коде один метод создает `Person` с помощью локальной переменной, но вам нужно узнать, что `Person`его имя указано в другой метод:  
  
```CSharp  
class Person  
{  
    public Person(string name)  
    {  
        Name = name;  
    }  
    public string Name { get; set; }  
}  
  
public class Program  
{  
    List<Person> _people = new List<Person>();  
    public static void Main(string[] args)  
    {  
        MakePerson();  
        DoSomething();  
    }  
  
    private static void MakePerson()  
    {  
        var p = new Person("Bob");  
        _people.Add(p);  
    }  
  
    private static void DoSomething()  
    {  
        // more processing  
         Console.WriteLine("done");  
    }  
}  
  
```  
  
 Вы можете добавить ссылку на этот объект `Person` в окно **Контрольные значения** , выполнив указанные ниже действия.  
  
1.  Установите точку останова в коде после создания объекта.  
  
2.  Начните отладку и, когда выполнение остановится в точке останова, найдите переменную в окне **Локальные** , щелкните ее правой кнопкой мыши и выберите пункт **Создать идентификатор объекта**.  
  
3.  Вы увидите  **$**  и число в **локальные** окна, который представляет идентификатор объекта.  
  
4.  Добавьте идентификатор объекта в окно "Контрольные значения".  
  
5.  Установите точку останова, в которой вы хотите контролировать поведение объекта.  В приведенном выше коде это место находится внутри `DoSomething()` метод.  
  
6.  Продолжайте отладку и, когда выполнение остановится в методе `DoSomething()` , в окне **Контрольные значения** отобразится объект `Person` .  
  
> [!NOTE]
>  Требуется для просмотра свойств объектов, таких как `Person.Name` в приведенном выше примере необходимо включить вычисление свойств.  
  
## <a name="using-registers-in-the-watch-window-c-only"></a>Использование регистров в окне "Контрольные значения" (только C++)  
 При отладке машинного кода, можно добавить имена регистров, а также имена переменных с помощью  **$ \<имя регистра >** или  **@ \<имя регистра >**.  Для получения дополнительной информации см. [Pseudovariables](../debugger/pseudovariables.md).  
  
## <a name="dynamic-view-and-the-watch-window"></a>Динамическое представление и окно контрольного значения  
 Некоторые языки сценариев (например, JavaScript и Python) используется динамическая или [типизация](https://en.wikipedia.org/wiki/Duck_typing), и языках .NET (в версии 4.0 и более поздних) поддерживаются объекты, которые трудно наблюдать с помощью обычных окон отладки, так как они Возможно, среда выполнения свойства и методы, которые нельзя отобразить.  
  
 Когда Контрольные значения-окно отображает объект, созданный из типа, реализующего [интерфейс IDynamicMetaObjectProvider](https://docs.microsoft.com/en-us/dotnet/api/system.dynamic.idynamicmetaobjectprovider?view=netframework-4.7), отладчик добавляет специальный **динамическое представление** узел **видимые**  отображения. В этом узле показаны динамические члены динамического объекта, но не разрешено изменять их значения.  
  
 Если щелкнуть правой кнопкой мыши любой дочерний объект узла **Динамическое представление** и выбрать пункт **Добавить контрольное значение**, отладчик вставит новую контрольную переменную, которая приводит объект к динамическому объекту. Иными словами, **object Name** становится (**(dynamic)object).Name**.  
  
 Вычисление членов **динамического представления** может иметь побочные эффекты. Объяснение того, что такое побочные эффекты, см. в разделе [Side Effects and Expressions](#bkmk_sideEffects). Для C# отладчик автоматически не пересчитывает значения, отображаемые в **Динамическом представлении** при переходе на новую строку кода. В Visual Basic выражения, добавляемые с помощью **динамического представления** , автоматически обновляются.  
  
 Инструкции по обновлению значений динамического представления см. в разделе [Обновление устаревших контрольных значений](#bkmk_refreshWatch).  
  
 Если нужно отобразить только **динамическое представление** объекта, можно использовать описатель формата **dynamic** .  
  
-   C#: **ИмяОбъекта, dynamic**  
  
-   Visual Basic: **$dynamic, ИмяОбъекта**  
  
 **Динамическое представление** также улучшает процесс отладки для COM-объектов. Когда отладчик встречает COM-объект, инкапсулированный в **System.__ComObject**, он добавляет узел **Динамическое представление** для объекта.  
  
## <a name="see-also"></a>См. также  
 [Окна отладчика](../debugger/debugger-windows.md)
