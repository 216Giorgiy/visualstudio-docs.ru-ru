---
title: Сведения об отладке с помощью отладчика Visual Studio
ms.description: Learn how to start the Visual Studio debugger, step through code, and inspect data.
ms.custom: mvc
ms.date: 08/01/2018
ms.technology: vs-ide-debug
ms.topic: tutorial
dev_langs:
- CSharp
- C++
helpviewer_keywords:
- debugger
ms.assetid: 62734c0d-a75a-4576-8f73-0e97c19280e1
author: mikejo5000
ms.author: mikejo
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 1629e98c6d0afa4d259b7b983d1efe0633321c13
ms.sourcegitcommit: 0cf1e63b6e0e6a0130668278489b21a6e5038084
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/02/2018
ms.locfileid: "39468732"
---
# <a name="tutorial-learn-to-debug-using-visual-studio"></a>Учебник: Сведения об отладке, с помощью Visual Studio

В этой статье представлены возможности отладчика Visual Studio в пошаговое руководство. Если требуется полное представление о возможности отладчика, см. в разделе [обзором возможностей отладчика](../debugger/debugger-feature-tour.md). Когда вы *отладка приложения*, это обычно означает, что приложение выполняется с подключенным отладчиком. При этом отладчик предоставляет множество способов, чтобы увидеть, что делает код во время его выполнения. Можно пошагово выполнять код и просматривать значения, хранящиеся в переменных, можно задать watches от переменных см. в разделе, при изменении значения, можно проверить путь выполнения кода, см. в разделе, является ли ветви кода работает, и т. д. Если это в первый раз, которое вы пытались пройти отлаживать код, вы можете прочитать [отладки для начинающих](../debugger/debugging-absolute-beginners.md) прежде чем приступить к этой статье.

|         |         |
|---------|---------|
|  ![значок кинокамеры для видео](../install/media/video-icon.png "Просмотреть видео")  |    [Ознакомьтесь с видео](https://mva.microsoft.com/en-US/training-courses-embed/getting-started-with-visual-studio-2017-17798/Debugger-Feature-tour-of-Visual-studio-2017-sqwiwLD6D_1111787171) по отладке, показаны аналогичные действия. |

Несмотря на то что демонстрационного приложения C# и C++, средства применимы к Visual Basic, JavaScript и других языков, поддерживаемых Visual Studio (за исключением оговоренных случаев). Снимки экрана написаны на C#.

В этом руководстве рассмотрены следующие задачи:

> [!div class="checklist"]
> * Запустите отладчик и задавать точки останова.
> * Дополнительные команды для пошаговой проверки кода в отладчике
> * Проверить значения переменных в подсказках по данным и окон отладчика
> * Проверить стек вызовов

## <a name="prerequisites"></a>Предварительные требования

* Необходимо установить Visual Studio 2017 и **разработка классических приложений .NET** или **разработка классических приложений C++** рабочей нагрузки.

    Установите Visual Studio бесплатно со страницы [скачиваемых материалов Visual Studio](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=button+cta&utm_content=download+vs2017), если еще не сделали этого.

    Если вам нужно установить рабочую нагрузку, но среда Visual Studio уже имеется, щелкните ссылку **Открыть установщик Visual Studio** в левой области диалогового окна **Новый проект** (выберите пункты **Файл** > **Создать** > **Проект**). Запускается Visual Studio Installer. Выберите. **NET разработки настольных приложений** или **разработка классических приложений C++** рабочей нагрузки, затем выберите **изменить**.

## <a name="create-a-project"></a>Создание проекта

1. В Visual Studio последовательно выберите **Файл > Создать проект**.

2. В разделе **Visual C#** или **Visual C++**, выберите **Windows Desktop**, а затем в средней области выберите **консольное приложение** ( **Приложение командной строки Windows** в C++).

    Если вы не видите **консольное приложение** шаблон проекта, щелкните **открыть установщик Visual Studio** ссылку в левой части **новый проект** диалоговое окно. Запускается Visual Studio Installer. Выберите *разработка классических приложений .NET** или **разработка классических приложений C++** рабочей нагрузки, затем выберите **изменить**.

3. Введите имя, например **get работы Отладка** и нажмите кнопку **ОК**.

    Visual Studio создаст проект.

4. В *Program.cs* (C#) или *работы debugging.cpp get* (C++), замените код

    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;

    namespace get_started_debugging
    {
        class Program
        {
            static void Main(string[] args)
            {
            }
        }
    }
    ```

    ```c++
    int main()
    {
        return 0;
    }
    ```

    следующим кодом:

    ```csharp
    using System;
    using System.Collections.Generic;

    public class Shape
    {
        // A few example members
        public int X { get; private set; }
        public int Y { get; private set; }
        public int Height { get; set; }
        public int Width { get; set; }
   
        // Virtual method
        public virtual void Draw()
        {
            Console.WriteLine("Performing base class drawing tasks");
        }
    }

    class Circle : Shape
    {
        public override void Draw()
        {
            // Code to draw a circle...
            Console.WriteLine("Drawing a circle");
            base.Draw();
        }
    }

    class Rectangle : Shape
    {
        public override void Draw()
        {
            // Code to draw a rectangle...
            Console.WriteLine("Drawing a rectangle");
            base.Draw();
        }
    }

    class Triangle : Shape
    {
        public override void Draw()
        {
            // Code to draw a triangle...
            Console.WriteLine("Drawing a trangle");
            base.Draw();
        }
    }

    class Program
    {
        static void Main(string[] args)
        {

            var shapes = new List<Shape>
            {
                new Rectangle(),
                new Triangle(),
                new Circle()
            };

            foreach (var shape in shapes)
            {
                shape.Draw();
            }

            // Keep the console open in debug mode.
            Console.WriteLine("Press any key to exit.");
            Console.ReadKey();
        }

    }

    /* Output:
        Drawing a rectangle
        Performing base class drawing tasks
        Drawing a triangle
        Performing base class drawing tasks
        Drawing a circle
        Performing base class drawing tasks
    */
    ```

    ```c++
    #include "pch.h"

    #include <string>
    #include <vector>
    #include <iostream>

    class Shape
    {
        int privateX = 0;
        int privateY = 0;
        int privateHeight = 0;
        int privateWidth = 0;

        int getX() const { return privateX; }
        void setX(int value) { privateX = value; }

        int getY() const { return privateY; }
        void setY(int value) { privateY = value; }

        int getHeight() const { return privateHeight; }
        void setHeight(int value) { privateHeight = value; }

        int getWidth() const { return privateWidth; }
        void setWidth(int value) { privateWidth = value; }

        public:
        // Virtual method
        virtual void Draw()
        {
            std::wcout << L"Performing base class drawing tasks" << std::endl;
        }
    };

    class Circle : public Shape
    {
        public:
        void Draw() override
        {
        // Code to draw a circle...
        std::wcout << L"Drawing a circle" << std::endl;
        Shape::Draw();
        }
    };

    class Rectangle : public Shape
    {
        public:
        void Draw() override
        {
        // Code to draw a rectangle...
        std::wcout << L"Drawing a rectangle" << std::endl;
        Shape::Draw();
        }
    };

    class Triangle : public Shape
    {
        public:
        void Draw() override
        {
        // Code to draw a triangle...
        std::wcout << L"Drawing a trangle" << std::endl;
        Shape::Draw();
        }
    };

    int main(std::vector<std::wstring> &args)
    {
        auto shapes = std::vector<Shape*>
        {
            new Rectangle(),
            new Triangle(),
            new Circle()
        };

        for (auto shape : shapes)
        {
            shape->Draw();
        }
    }

    /* Output:
    Drawing a rectangle
    Performing base class drawing tasks
    Drawing a triangle
    Performing base class drawing tasks
    Drawing a circle
    Performing base class drawing tasks
    */
    ```

## <a name="start-the-debugger"></a>Запустите отладчик!

1. Нажмите клавишу **F5** (**Отладка > Начать отладку**) или **начать отладку** кнопку ![начать отладку](../debugger/media/dbg-tour-start-debugging.png "начать отладку ") на панели инструментов отладки.

     **F5** запускает приложение с помощью отладчика, присоединившись к приложению обработать, но сейчас мы еще не сделали ничего особенного, чтобы проанализировать код. Поэтому просто загружается приложение, и вы увидите выходные данные консоли.

    ```
    Drawing a rectangle
    Performing base class drawing tasks
    Drawing a triangle
    Performing base class drawing tasks
    Drawing a circle
    Performing base class drawing tasks
    ```

     В этом руководстве мы рассмотрим это более подробно в это приложение, с помощью отладчика и получите обзор отладчик функции.

2. Остановите отладчик, нажав клавишу red stop ![остановить отладку](../debugger/media/dbg-tour-stop-debugging.png "остановить отладку") кнопки.

## <a name="set-a-breakpoint-and-start-the-debugger"></a>Установите точку останова и запустите отладчик

1. В `foreach` цикла `Main` функция (`for` цикл в C++ `main` функции), установите точку останова, щелкнув область слева от первой строки кода.

    ![Установите точку останова](../debugger/media/get-started-set-breakpoint.png "SetABreakPoint")

    Где вы задали точку останова, появится красный кружок.

    Точки останова — это один из самых простых и важных компонентов надежной отладки. Точка останова указывает, где Visual Studio следует приостановить выполнение кода, чтобы вы могли проверить значения переменных или поведение памяти либо выполнение ветви кода. 

6. Нажмите клавишу **F5** или **начать отладку** кнопку, запускается приложение, и отладчик переходит к строке кода, где вы задали точку останова.

    ![Точки останова,](../debugger/media/get-started-hit-breakpoint.png "HitABreakPoint")

    Желтая стрелка представляет инструкцию, на котором отладчик приостановил, который также приостанавливает выполнение приложения в той же точке (Эта инструкция еще не выполнена).

     Если приложение еще не запущена, **F5** запускает отладчик и останавливается на первой точке останова. В противном случае **F5** продолжает выполнение приложения до следующей точки останова.

    Точки останова имеют полезная функция, если известно, что строки кода или в разделе кода, который вы хотите подробно рассмотреть.

## <a name="navigate-code-in-the-debugger-using-step-commands"></a>Навигация по коду в отладчике с помощью команды пошаговой отладки

Главным образом, здесь мы использовать сочетания клавиш, так как это хороший способ получения быстро, при выполнении приложения в отладчике (эквивалентные команды например меню команды отображаются в круглых скобках).

1. Нажмите клавишу **F11** (или выберите **Отладка > шаг с заходом**) один раз (несколько раз в C#) пока остановитесь на `shape.Draw` вызов метода `Main` метод (`shape->Draw` в C++).

1. Нажмите клавишу **F11** еще раз, чтобы перейти в код для `Rectangle` класса.

     ![Используйте клавишу F11 для кода, шаг с заходом](../debugger/media/get-started-f11.png "пошагово F11")

     F11 является **шаг с заходом** команды и перемещает приложение выполнения одной инструкции одновременно. F11 — это хороший способ проверить поток выполнения в наиболее полные сведения. (Чтобы переместиться код быстрее, мы покажем некоторые другие параметры также.) По умолчанию, отладчик пропускает непользовательский код (если для получения дополнительных сведений см. в разделе [Just My Code](../debugger/just-my-code.md)).

2. Нажмите клавишу **F10** (или выберите **Отладка > шаг с обходом**) несколько раз, пока отладчик останавливается на `base.Draw` вызова метода (`Shape::Draw` в C++), а затем нажмите клавишу **F10** Ещё один раз.

     ![Нажмите клавишу F10 для кода, шаг с обходом](../debugger/media/get-started-step-over.png "шагам F10")

     Обратите внимание, что это время, отладчик не выполняет вход в `Draw` метод базового класса (`Shape`). **F10** отладчик без шаг с заходом в функции или методы в коде приложения (код по-прежнему выполняется). Нажав клавишу F10 `base.Draw` (или `Shape::Draw`) вызова метода (а не **F11**), мы просто пропущен код реализации `base.Draw` (какие. Возможно, мы не интересны прямо сейчас).

## <a name="navigate-code-using-run-to-click"></a>Навигация по коду с помощью выполнение до щелчка

5. В редакторе кода, прокрутите вниз и наведите указатель мыши `Console.WriteLine` метод (`std::cout` в C++) в `Triangle` класс до зеленую **выполнение до щелкнутого** кнопку ![выполнение до щелкнутого] (../debugger/media/dbg-tour-run-to-click.png " RunToClick") отображается слева.

     ![Использовать выполнение до щелкнутого функция](../debugger/media/get-started-run-to-click.png "выполнение до щелкнутого")

    >  [!NOTE]
    > **Выполнение до щелкнутого** кнопку впервые появился в [!include[vs_dev15](../misc/includes/vs_dev15_md.md)]. Если вы не видите кнопку с зеленой стрелкой, используйте **F11** в этом примере вместо этого для развития отладчик в нужное место.

6. Нажмите кнопку **выполнение до щелкнутого** кнопку ![выполнение до щелкнутого](../debugger/media/dbg-tour-run-to-click.png "RunToClick").

    С помощью этой кнопки аналогично установке временной точки останова. **Выполнение до щелкнутого** удобна для решения проблем со быстро в видимой области кода приложения (можно щелкнуть в любом открытом файле).

    Отладчик перемещается на `Console.WriteLine` реализацию метода для `Triangle` класс (`std::cout` в C++).

    Пока выполнение приостановлено, можно заметить опечатка! Выходные данные «Нарисовать trangle» содержит ошибки. Мы смогли исправить ее прямо здесь во время выполнения приложения в отладчике.

## <a name="edit-code-and-continue-debugging"></a>Изменение кода и продолжение отладки

1. Щелкните «Нарисовать trangle» и введите исправление, изменение «trangle» на «triangle».

1. Нажмите клавишу **F11** один раз чтобы увидеть, что отладчик в следующий раз увеличит.

    > [!NOTE]
    > В зависимости от того, какой тип кода, изменение в отладчике может появиться предупреждающее сообщение. В некоторых случаях код необходимо перекомпилировать перед тем как продолжить.

## <a name="step-out"></a>Шаг с выходом

Предположим, что вы закончите изучение `Draw` метод в `Triangle` класса и хотите, чтобы эффективно использовать функции, но оставить в отладчике. Это можно сделать с помощью **шаг с выходом** команды.

1. Нажмите клавишу **Shift** + **F11** (или **Отладка > шаг с выходом**).

     Эта команда возобновляет выполнение приложения (и отладчик) до возврата текущей функции.

     Должен находиться в `foreach` цикл `Main` метод (`for` цикл в C++).

## <a name="restart-your-app-quickly"></a>Перезапустите приложение быстро

Нажмите кнопку **перезапустите** ![перезапустить приложение](../debugger/media/dbg-tour-restart.png "RestartApp") кнопку на панели инструментов отладки (**Ctrl** + **Shift**   +  **F5**).

При нажатии клавиши **перезапустите**, позволяет сэкономить время и остановите приложение и перезапуска отладчика. Отладчик останавливается на первой точке останова, достигается при выполнении кода.

Отладчик останавливается в точке останова, заданной, в `foreach` цикла (`for` цикл в C++).

## <a name="inspect-variables-with-data-tips"></a>Проверить значения переменных в подсказках по данным

Функции, позволяющие проверять значения переменных являются одним из наиболее полезных функций отладчика, и существуют разные способы сделать это. Часто при попытке выполнить отладку проблемы, вы пытаетесь определить ли переменные хранятся значения, которые они должны иметь определенное время.

1. Во время паузы на `foreach` цикла (`for` цикл в C++), нажмите клавишу **F11** после.

1. Наведите указатель мыши `shapes` и объект см. в разделе значением свойства по умолчанию `Count` свойство.

1. Разверните `shapes` объекту, чтобы увидеть все его свойства, такие как первый индекс в массиве `[0]`, который имеет значение `Rectangle` (C#) или адрес памяти (C++).

     ![Просмотреть подсказке](../debugger/media/get-started-data-tip.png "просмотреть подсказке по данным")

    Часто при отладке, требуется быстрый способ проверить значения свойств для объектов, и советы по данным — отличный способ сделать это.

## <a name="inspect-variables-with-the-autos-and-locals-windows"></a>Проверить значения переменных с помощью окна "Видимые" и "Локальные"

1. Рассмотрим **"Видимые"** окно в нижней части редактора кода.

     ![Проверить значения переменных в окне "Видимые"](../debugger/media/get-started-autos-window.png "окно \"Видимые\"")

    В **"Видимые"** окно, вы видите, переменные и их текущие значения. **"Видимые"** окне отображаются все переменные, используемые в текущей строке или Предыдущая строка (в C++, в окне отображаются переменные в предыдущем три строки кода. См. в документации для поведения конкретного языка).

    > [!NOTE]
    > В JavaScript **"Локальные"** окна, но не поддерживается **"Видимые"** окна.

2. Далее, рассмотрим **"Локальные"** окне на вкладке рядом с полем **"Видимые"** окна.

    **"Локальные"** окна показаны переменные, которые находятся в текущем [область](https://www.wikipedia.org/wiki/Scope_(computer_science)).

## <a name="set-a-watch"></a>Установка контрольных значений

1. Щелкните правой кнопкой мыши в окне редактора основного кода `shapes` объекта и выберите **Добавить контрольное значение**.

    **Watch** откроется окно в нижней части редактора кода. Можно использовать **Watch** окно, чтобы указать переменную или выражение, необходимо следить за на.

    Теперь у вас есть Контрольное значение на `shapes` объект и можно увидеть его значение изменить по мере продвижения по отладчика. В отличие от других окна переменных **Watch** окне всегда отображаются переменные, просмотре (они отображаются как отключенные, когда за пределы области действия).

## <a name="examine-the-call-stack"></a>Проверить стек вызовов

1. Во время паузы в `foreach` цикла (`for` цикл в C++), нажмите кнопку **стек вызовов** окно, в котором по умолчанию в нижней правой области.

1. Нажмите кнопку **F11** несколько раз, пока не увидите приостановки в отладчике `Circle.Draw` метода в редакторе кода. Рассмотрим **стек вызовов** окна.

    ![Проверить стек вызовов](../debugger/media/get-started-call-stack.png "ExamineCallStack")

    **Стек вызовов** окна показан порядок, в котором находятся получение называется методов и функций. Верхняя строка показывает текущую функцию ( `Circle.Draw` или `Circle::Draw` метод в этом приложении). Во второй строке показано, что `Circle.Draw` был вызван с `Main` метод (`main` в C++), и т. д.

    >  [!NOTE]
    > **Стек вызовов** окно аналогична точки зрения отладки в некоторых IDE, например Eclipse.

    Стек вызовов — хороший способ проверять и анализировать ход выполнения приложения.

    Можно дважды щелкнуть строку кода, чтобы рассмотреть исходного кода и также изменяет область текущего, проверяемое отладчиком. Это действие не перемещает отладчик.

    Можно также использовать контекстные меню из **стек вызовов** окно для выполнения других задач. Например, можно вставлять точки останова в указанных функций, перейдите с помощью отладчика **выполнить до текущей позиции**и изучите исходный код. Дополнительные сведения см. в разделе [как: Проверьте стек вызовов](../debugger/how-to-use-the-call-stack-window.md).

## <a name="change-the-execution-flow"></a>Изменить поток выполнения

1. Когда отладчик приостановит выполнение `Circle.Draw` вызов метода, нажмите клавишу **F11** несколько раз, пока отладчик приостанавливает на `base.Draw` вызова метода (`Shape::Draw` в C++).

1. Захватите желтая стрелка (указатель выполнения) в левой части и переместите желтая стрелка вверх на одну строку, чтобы с помощью мыши `Console.WriteLine` (`std::cout` в C++) вызова метода.

1. Нажмите клавишу **F11** еще раз.

    Повторно запустит отладчик `Console.WriteLine` метод (`std::cout` в C++).

    Можно изменить поток выполнения, можно, например протестировать различные кодовые пути выполнения, или повторно выполнить код без перезапуска отладчика.

    > [!WARNING]
    > Часто необходимо соблюдать осторожность, с помощью этой функции, и вы увидите предупреждение во всплывающей подсказке. Может появиться другие предупреждения, слишком. Перемещение указателя невозможно вернуть приложение в предыдущее состояние приложения.

1. Нажмите клавишу **F5** для продолжения выполнения приложения.

    Поздравляем с завершением этого учебника!

## <a name="next-steps"></a>Следующие шаги

В этом руководстве вы узнали, как запустить отладчик, пошаговое выполнение кода и проверять значения переменных. Вы можете получить подробный обзор функций отладчика, а также ссылки на дополнительные сведения.

> [!div class="nextstepaction"]
> [Обзор функций отладчика](../debugger/debugger-feature-tour.md)
