---
title: "Начало отладки многопоточных приложений | Документы Microsoft"
ms.custom: H1HackMay2017
ms.date: 06/02/2017
ms.reviewer: 
ms.suite: 
ms.technology:
- vs-ide-debug
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- CSharp
- VB
- FSharp
- C++
helpviewer_keywords:
- multithreaded debugging, tutorial
- tutorials, multithreaded debugging
ms.assetid: 62df746b-b0f6-4df4-83cf-b1d9d2e72833
caps.latest.revision: 38
author: mikejo5000
ms.author: mikejo
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 1d4298d60886d8fe8b402b59b1838a4171532ab1
ms.openlocfilehash: 3ffb550707280d76756cbd144ed03f4143ce144b
ms.contentlocale: ru-ru
ms.lasthandoff: 09/26/2017

---
# <a name="get-started-debugging-a-multithreaded-application-in-visual-studio"></a>Начало отладки многопоточных приложений в Visual Studio
Visual Studio предоставляет несколько средств и элементы пользовательского интерфейса для отладки многопоточных приложений. Этого учебника показано, как использовать маркеры потоков **Параллельные стеки** окне **контроль параллельных данных** окна, условные точки останова и точки останова фильтра. Этот учебник занимает всего несколько минут, но оно позволит ознакомиться со средствами для отладки многопоточных приложений.

|         |         |
|---------|---------|
| ![Посмотреть видео](../install/media/video-icon.png "WatchVideo") | [Посмотреть видео](#video) на многопотоковая отладка, показывающий аналогичные действия. |

Другие разделы предоставляют дополнительные сведения об использовании других многопоточных средства отладки.

- Аналогичные темы, показано, как использовать **место отладки** инструментов и **потоков** окна, в разделе [Пошаговое руководство: Отладка многопоточных приложений](../debugger/how-to-use-the-threads-window.md).

- Аналогичные раздел с примером, который использует <xref:System.Threading.Tasks.Task> (управляемый код) и среда выполнения с параллелизмом (C++), в разделе [Пошаговое руководство: отладка параллельного приложения](../debugger/walkthrough-debugging-a-parallel-application.md). Общие советы по отладке, применяемые в типы наиболее многопоточных приложений, прочитать этот раздел и связанный раздел.
  
Чтобы начать работу с учебником, необходим проект многопоточного приложения. Выполните следующие действия для создания этого проекта.  
  
#### <a name="to-create-the-multithreaded-app-project"></a>Чтобы создать проект многопоточного приложения  
  
1.  На **файл** меню, выберите **New** и нажмите кнопку **проекта**.  
  
     Откроется диалоговое окно **Новый проект** .  
  
2.  В **тип проекта**s выберите язык: **Visual C#**, **Visual C++**, или **Visual Basic**.  
  
3.  В **шаблоны** выберите **консольного приложения**.  
  
4.  В **имя** введите имя MyThreadWalkthroughApp.  
  
5.  Нажмите кнопку **ОК**.  
  
     Появится новый проект консольного приложения. Когда проект будет создан, откроется файл исходного кода. В зависимости от языка, которую вы выбрали может вызывать исходный файл Program.cs, MyThreadWalkthroughApp.cpp или Module1.vb.  
  
6.  Удалите код, который отображается в исходном файле и замените его на пример кода, показано ниже.

    ```csharp
    using System;
    using System.Threading;

    public class ServerClass
    {

        static int count = 0;
        // The method that will be called when the thread is started.
        public void InstanceMethod()
        {
            Console.WriteLine(
                "ServerClass.InstanceMethod is running on another thread.");

            int data = count++;
            // Pause for a moment to provide a delay to make
            // threads more apparent.
            Thread.Sleep(3000);
            Console.WriteLine(
                "The instance method called by the worker thread has ended.");
        }
    }

    public class Simple
    {
        public static void Main()
        {
            for (int i = 0; i < 10; i++)
            {
                CreateThreads();
            }
        }
        public static void CreateThreads()
        {
            ServerClass serverObject = new ServerClass();

            Thread InstanceCaller = new Thread(new ThreadStart(serverObject.InstanceMethod));
            // Start the thread.
            InstanceCaller.Start();

            Console.WriteLine("The Main() thread calls this after "
                + "starting the new InstanceCaller thread.");

        }
    }
    ```

    ```C++
    #include "stdafx.h"
    #include <thread>
    #include <iostream>
    #include <vector>

    int count = 0;

    void doSomeWork() {

        std::cout << "The doSomeWork function is running on another thread." << std::endl;
        int data = count++;
        // Pause for a moment to provide a delay to make
        // threads more apparent.
        std::this_thread::sleep_for(std::chrono::seconds(3));
        std::cout << "The function called by the worker thread has ended." << std::endl;
    }

    int main() {
        std::vector<std::thread> threads;

        for (int i = 0; i < 10; ++i) {

            threads.push_back(std::thread(doSomeWork));
            std::cout << "The Main() thread calls this after starting the new thread" << std::endl;
        }

        for (auto& thread : threads) {
            thread.join();
        }

        return 0;
    }
    ```

    ```VB
    Imports System.Threading

    Public Class ServerClass
        ' The method that will be called when the thread is started.
        Public count = 0
        Public Sub InstanceMethod()
            Console.WriteLine(
                    "ServerClass.InstanceMethod is running on another thread.")

            Dim data = count + 1
            ' Pause for a moment to provide a delay to make
            ' threads more apparent.
            Thread.Sleep(3000)
            Console.WriteLine(
                    "The instance method called by the worker thread has ended.")
        End Sub

    End Class

    Public Class Simple

        Public Shared Sub Main()

            Dim ts As New ThreadStarter
            For index = 1 To 10
                ts.CreateThreads()
            Next

        End Sub

    End Class
    Public Class ThreadStarter
        Public Sub CreateThreads()
            Dim serverObject As New ServerClass()

            ' Create the thread object, passing in the
            ' serverObject.InstanceMethod method using a
            ' ThreadStart delegate.
            Dim InstanceCaller As New Thread(AddressOf serverObject.InstanceMethod)

            ' Start the thread.
            InstanceCaller.Start()

            Console.WriteLine("The Main() thread calls this after " _
                        + "starting the new InstanceCaller thread.")

        End Sub
    End Class
    ```
  
7.  На **файл** меню, нажмите кнопку **сохранить все**.  
  
#### <a name="to-begin-the-tutorial"></a>Чтобы приступить к изучению учебника  
  
-   В редакторе исходного кода найдите следующий код: 
  
    ```CSharp  
    Thread.Sleep(3000);  
    Console.WriteLine();  
    ```  
  
    ```C++  
    Thread::Sleep(3000);  
    Console.WriteLine();  
    ```  
    ```VB
    Thread.Sleep(3000)
    Console.WriteLine()
    ```
  
#### <a name="to-start-debugging"></a>Начало отладки  
  
1.  Щелкните в левом поле `Thread.Sleep` или `Thread::Sleep` инструкцию, чтобы добавить новую точку останова.  
  
     Во внутренней области левой части редактора исходного кода появится красный кружок. Это означает, что точка останова установлена в этом месте. 
  
2.  На **отладки** меню, нажмите кнопку **начать отладку** (**F5**).  
  
     Visual Studio создает решение, приложение начинает выполняться с подключенным отладчиком и затем приложение останавливается в точке останова.  
  
    > [!NOTE]
    > При переключении фокуса в окно консоли, нажмите кнопку в [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] окно для возвращения фокуса в [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)].  
  
4.  В редакторе исходного кода найдите строку, которая содержит точку останова:  
  
    ```CSharp  
    Thread.Sleep(3000);  
    ```  
  
    ```C++  
    Thread::Sleep(3000);  
    ```

    ```VB
    Thread.Sleep(3000)
    ```    
  
#### <a name="ShowThreadsInSource"></a>Чтобы обнаружить маркер потока  

1.  В панели инструментов отладки нажмите **Показать потоки в исходном коде** кнопку ![Показать потоки в исходном коде](../debugger/media/dbg-multithreaded-show-threads.png "ThreadMarker").

2. Нажмите клавишу **F11** один раз, чтобы переместить отладчик одной строки кода.
  
3.  Посмотрите на переплет в левой части окна. В этой строке, вы увидите *маркер потока* значок ![маркер потока](../debugger/media/dbg-thread-marker.png "ThreadMarker") имеет вид 2 тряпичных нити. маркер потока указывает, что некий поток остановлен в этом месте.

    Обратите внимание, что маркер потока может частично скрыты с помощью точки останова. 
  
4.  Наведите указатель мыши на маркер потока. Появится подсказка. Подсказка сообщает имя и идентификационный номер каждого остановившегося тут потока. В этом случае оно, скорее всего, `<noname>`. 
  
5.  Щелкните правой кнопкой мыши маркер потока, чтобы просмотреть доступные параметры контекстного меню.
    
## <a name="ParallelStacks"></a>Просмотр расположения потоков

В **Параллельные стеки** окна, можно переключаться между представление "Потоки", а также (для программирования на основе задач) представление "задачи" и просмотреть стек вызовов для каждого потока. В этом приложении можно использовать представление "Потоки".

1. Откройте **Параллельные стеки** окно, выбрав **Отладка > Windows > Параллельные стеки**. Оно будет выглядеть примерно так (точные данные будут отличаться в зависимости от текущего расположения, каждый поток, оборудования и используемого языка программирования).

    ![Параллельных стеков окна](../debugger/media/dbg-multithreaded-parallel-stacks.png "ParallelStacksWindow")

    В этом примере слева направо мы получаем эти сведения:
    
    - Основной поток (слева) остановлена на `Thread.Start` (точка останова обозначается значком маркер потока ![маркер потока](../debugger/media/dbg-thread-marker.png "ThreadMarker")).
    - Были введены два потока `ServerClass.InstanceMethod`, один из которых является текущий поток (желтая стрелка), а другой поток остановлен в `Thread.Sleep`.
    - Новый поток (справа) также запускается (остановлена на `ThreadHelper.ThreadStart`).

2.  Щелкните правой кнопкой мыши записи в **Параллельные стеки** окна, чтобы отобразить доступные параметры контекстного меню.

    Можно выполнять различные действия из эти контекстные меню, но в этом учебнике мы рассмотрим несколько из этих сведений в **контроль параллельных данных** окна (в следующем разделе).

    > [!NOTE]
    > Если вы более заинтересованы в просмотре списка просмотра со сведениями о каждом потоке, используйте **потоков** окна вместо него. В разделе [Пошаговое руководство: Отладка многопоточных приложений](../debugger/how-to-use-the-threads-window.md).

## <a name="set-a-watch-on-a-variable"></a>Значение контрольного значения для переменной

1. Откройте **контроль параллельных данных** окно, выбрав **Отладка > Windows > контроль параллельных данных > контроль параллельных данных 1**.

2. Щелкните ячейку, в котором имеются `<Add Watch>` текста (или пустой заголовок ячейки в четвертом столбце), тип `data`, и нажмите клавишу ВВОД.

    В окне отображаются значения для переменной для каждого потока данных.

3. Снова щелкните ячейку, в которой отображаются `<Add Watch>` текста (или пустой заголовок ячейки в столбце 5-й) типа `count`, и нажмите клавишу ВВОД.

    В окне отображаются значения для переменной счетчика для каждого потока. (Если вы не видите еще такой большой объем информации, попробуйте еще несколько раз нажав клавишу F11, чтобы переместить выполнение потоков в отладчике.)

    ![Окно контрольных значений параллельных](../debugger/media/dbg-multithreaded-parallel-watch.png "ParallelWatchWindow")

4. Щелкните правой кнопкой мыши одну из строк в окне, чтобы просмотреть доступные параметры.

## <a name="flagging-and-unflagging-threads"></a>Пометка потоков и ее снятие  
Можно пометить поток, требуется уделить особое внимание. Пометка потоков — хороший способ, чтобы отслеживать важные потоки и игнорировать потоков, которые не важна.  
  
#### <a name="to-flag-threads"></a>Чтобы пометить потоки  

1. В **контроль параллельных данных** окна, удерживая нажатой клавишу SHIFT и выбрать несколько строк.

2. Щелкните правой кнопкой мыши и выберите **флаг**.

    Теперь помечаются все выбранные потоки. Теперь можно фильтровать на показ только помеченных потоков.
  
3.  В **контроль параллельных данных** окна, найдите **Показывать только отмеченные потоки** кнопку ![Показывать отмеченные потоки](../debugger/media/dbg-threads-show-flagged.png "ThreadMarker").  
  
4.  Нажмите кнопку **Показывать только отмеченные потоки** кнопки.  
  
    Теперь в списке отображаются только отмеченные потоки.

    > [!TIP]
    > Когда отметкой некоторые потоки можно правой кнопкой мыши строку кода в редакторе кода и выбрать **запуска отмеченные потоки до курсора** (не забудьте выбрать код, что все отмеченные потоки достигнет). Это приостанавливает потоки в выбранной строке кода, упрощая процесс для управления порядком выполнения по [Замораживание и размораживание потоков](#bkmk_freeze).

5.  Нажмите кнопку **Показывать только отмеченные потоки** кнопку для переключения обратно в **Показывать все потоки** режим.
    
#### <a name="to-unflag-threads"></a>Чтобы снять отметку с потока

Чтобы снять отметку с потока, щелкнуть правой кнопкой мыши один или несколько отмеченных потоков в **контроль параллельных данных** окна и выберите **снять отметку**.

## <a name="bkmk_freeze"></a>Замораживание и размораживание потоков 

> [!TIP]
> Можно заморозить или разморозить (приостанавливать и возобновлять) потоки для управления порядком, в котором потоки выполнения работы. Это может помочь при устранении проблем параллелизма, например взаимоблокировки и состояние гонки.
  
#### <a name="to-freeze-and-unfreeze-threads"></a>Чтобы заморозить и разморозить потоки  
  
1.  В **контроль параллельных данных** окна со всех выбранных строк, щелкните правой кнопкой мыши и выберите **закрепить**.

    Во втором столбце значок паузы теперь отображается для каждой строки. Значок паузы указывает, что поток заморожен.

2.  Отменить выбор строки, щелкнув только одну строку.

3.  Щелкните правой кнопкой мыши строку и выберите **Разморозить**.

    Значок паузы исчезает в этой строке, указывающее, что поток больше не зафиксировано.

4.  В редакторе кода и нажмите кнопку **F11**. Только нефиксированного поток выполняется.

    Экземпляр приложения также можно создать несколько новых потоков. Обратите внимание, что все новые потоки непомеченные заморожены.

## <a name="bkmk_follow_a_thread"></a>Выполните один поток, используя условные точки останова

В некоторых случаях может быть полезно следить за выполнением из одного потока в отладчике. Это можно сделать в том числе путем закрепления потоков, которые вас не интересуют, но в некоторых сценариях может потребоваться следовать один поток не замораживание других потоков (для воспроизведения определенной ошибки, например). Для выполнения в потоке без замораживание других потоков, можно избежать, приостановка выполнения кода, за исключением того, в том потоке, которые вас интересуют. Это можно сделать, задав [условную точку останова](../debugger/using-breakpoints.md#BKMK_Specify_a_breakpoint_condition_using_a_code_expression).

Можно установить точки останова в различных условиях, например имя или идентификатор потока. Другой метод, который может оказаться полезным является задайте условие для данных, которые будут уникальными для каждого потока. Это распространенный сценарий отладки, в котором больше интересует некоторые конкретного значения данных чем в любом определенном потоке.

#### <a name="to-follow-a-single-thread"></a>Для выполнения одного потока

1. Щелкните правой кнопкой мыши созданную ранее точку останова и выберите **условия**.

2. В **параметры точки останова** введите `data == 5` для условного выражения.

    ![Условную точку останова](../debugger/media/dbg-multithreaded-conditional-breakpoint.png "ConditionalBreakpoint")

    > [!TIP]
    > Если вас интересуют более определенного потока, используйте имя или идентификатор потока для условия. Для этого в **параметры точки останова** выберите **фильтра** вместо **условное выражение**и следуйте советам фильтра. Требуется имя потоков в коде приложения (поскольку потоки идентификаторы изменить при перезапуске отладчик).

3. Закрыть **параметры точки останова** окна.

4. Нажмите "перезапустить" ![перезапустить приложение](../debugger/media/dbg-tour-restart.png "RestartApp") кнопку, чтобы перезапустить сеанс отладки.

    Произойдет останов в коде в потоке, для которого переменной данных — 5. Желтая стрелка (текущий контекст отладчика) следует искать в **контроль параллельных данных** окна, чтобы убедиться, что.

5. Теперь можно шаг с обходом кода (F10) и шаг с заходом в код (F11) и следить за выполнением один поток.

    Пока условие точки останова является уникальным для потока, и отладчик не попадает в другие точки останова в других потоках (может потребоваться отключить их), вы выполните шаг с обходом кода и пошаговое выполнение кода без переключения на другие потоки.

    > [!NOTE]
    > При переходе отладчик все потоки будут выполняться. Тем не менее отладчик не будет Приостановка выполнения кода в других потоках, если только один из других потоков попадает на точку останова. 
  
## <a name="more-about-the-multithreaded-debugging-windows"></a>Дополнительные сведения о диалоговых окон отладки многопоточных 

#### <a name="to-switch-to-another-thread"></a>Для переключения на другой поток 

- Чтобы переключиться в другой поток, в разделе [как: переключиться в другой поток во время отладки](../debugger/how-to-switch-to-another-thread-while-debugging.md) 

## <a name="video"></a>Видео на многопотоковая Отладка

<div style="padding-top: 56.25%; position: relative; width: 100%;">
<iframe style="position: absolute;top: 0;left: 0;right: 0;bottom: 0;" width="100%" height="100%" src="https://mva.microsoft.com/en-US/training-courses-embed/getting-started-with-visual-studio-2017-17798/Debugging-Multi-threaded-Apps-in-Visual-Studio-2017-MoZPKMD6D_111787171" frameborder="0" allowfullscreen></iframe>
</div>

#### <a name="to-learn-more-about-the-parallel-stack-and-parallel-watch-windows"></a>Для получения дополнительных сведений о окна параллельных стека и контроль параллельных данных  
  
- В разделе [как: использование окна параллельных стека](../debugger/using-the-parallel-stacks-window.md) 

- В разделе [как: использование окна параллельных контрольных значений](../debugger/how-to-use-the-parallel-watch-window.md) 
  
## <a name="see-also"></a>См. также  
 [Отладка многопоточных приложений](../debugger/debug-multithreaded-applications-in-visual-studio.md)   
 [Практическое руководство. Переключение на другой поток при отладке](../debugger/how-to-switch-to-another-thread-while-debugging.md)

