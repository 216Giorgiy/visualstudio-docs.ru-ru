---
title: Отладка пользовательского кода только мой код | Документация Майкрософт
ms.custom: ''
ms.date: 05/18/2017
ms.technology: vs-ide-debug
ms.topic: conceptual
ms.assetid: 0f0df097-bbaf-46ad-9ad1-ef5f40435079
author: mikejo5000
ms.author: mikejo
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: f39b2ce216ce909837f37fd09fb556a4733098ce
ms.sourcegitcommit: 55f7ce2d5d2e458e35c45787f1935b237ee5c9f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2018
ms.locfileid: "42627345"
---
# <a name="specify-whether-to-debug-only-user-code-using-just-my-code-in-visual-studio"></a>Укажите, следует ли отладка пользовательского кода, с помощью "только мой код" в Visual Studio
Можно настроить Visual Studio автоматически шаг с обходом системы, платформы и другие вызовы, не написанный пользователем, и сворачивания такие вызовы в окна стека вызова. Компонент, который включает или отключает это поведение называется *Just My Code*. В этом разделе описывается использование только мой код в проектах C#, Visual Basic, C++ и JavaScript.

В большинстве языков программирования Just My Code включена по умолчанию.
  
##  <a name="BKMK_Enable_or_disable_Just_My_Code"></a> Включить или отключить только мой код  
 Чтобы включить или отключить только мой код, выберите **Сервис > Параметры** меню в Visual Studio. В **Отладка** > **Общие** узел, установите или снимите флажок **включить только мой код**.
  
 ![Включить только мой код в диалоговом окне Параметры](../debugger/media/dbg_justmycode_options.png "DBG_JustMyCode_Options")  
  
> [!NOTE]
>  **Включить только мой код** параметр — это глобальный параметр, который применяется ко всем проектам Visual Studio на всех языках.  
  
###  <a name="BKMK_Override_call_stack_filtering"></a> Показать встроенный код в представлениях стека вызова  
 В представлениях, Показать стек вызовов, таких как **стек вызовов** и **задачи** windows, Just My Code сворачивает код, не написанный пользователем в кадр с заметками и подписью `[External Code]`. Для просмотра свернутых кадров выберите **Показать внешний код** в контекстном меню стека вызова отображаться.

 ![Показать внешний код в окне стека вызовов](../debugger/media/dbg_justmycode_showexternalcode.png "DBG_JustMyCode_ShowExternalCode")
  
> [!NOTE]
>  **Показать внешний код** параметр сохраняется в профилировщик текущего пользователя. Он применяется ко всем проектам на всех языках, открываемых этим пользователем.
  
##  <a name="BKMK__NET_Framework_Just_My_Code"></a> Только мой код .NET framework  
  
###  <a name="BKMK_NET_User_and_non_user_code"></a> Пользовательский код и не написанный пользователем код  
 Чтобы отличить пользовательский код от другого кода, Just My Code рассматривает файлов символов (.pdb) и программную оптимизацию. Отладчик считает код, не написанным пользователем, если двоичный файл оптимизируется или если pdb-файл недоступен.
  
 Три атрибута также влияют на то, какой код отладчик считаем кодом пользователя:  
  
-   <xref:System.Diagnostics.DebuggerNonUserCodeAttribute> сообщает отладчику, что код, к которому он применяется, не является пользовательским.  
  
-   <xref:System.Diagnostics.DebuggerHiddenAttribute> скрывает код от отладчика, даже если режим "Только мой код" включен.  
  
-   <xref:System.Diagnostics.DebuggerStepThroughAttribute> указывает отладчику выполнить в пошаговом режим код, к которому он применяется, а не осуществлять шаг с заходом в этот код.  
  
 Весь остальной код считается пользовательским.  
  
###  <a name="BKMK_NET_Stepping_behavior"></a> Поведение пошагового выполнения  
 Когда вы **шаг с заходом** (сочетание клавиш: F11) не написанный пользователем, отладчик обходит код к следующему оператору пользователя. Когда вы **шаг с выходом** (Клавиатура: Shift + F11), отладчик переходит к следующей строке пользовательского кода. Если пользовательский код не обнаруживается, то выполнение продолжается, пока приложение завершает работу, точки останова или возникает исключение.  
  
###  <a name="BKMK_NET_Breakpoint_behavior"></a> Поведение точек останова  
 При включении Just My Code, вы можете **прервать все** (клавиатуры: Ctrl + Alt + Break) и остановить выполнение в месте, где имеется пользовательский код для отображения. Когда это происходит, отображается окно "Нет исходного кода". Если затем выбирается команда "Шаг", отладчик переходит к следующей строке пользовательского кода.  
  
###  <a name="BKMK_NET_Exception_behavior"></a> Поведение исключения  
 При возникновении необработанного исключения в коде, написанном не пользователем, отладчик прерывается на той строке в коде пользователя, где было создано исключение.  
  
 Если для этого исключения включена первичная обработка исключения, строка кода пользователя выделяется зеленым цветом. Стек вызовов отображает кадр с заметками с меткой **[внешний код]**.  
  
##  <a name="BKMK_C___Just_My_Code"></a> Только мой код C++  
  
###  <a name="BKMK_CPP_User_and_non_user_code"></a> Пользовательский код и не написанный пользователем код  
Функция "Только мой код" в C++ отличается от функции "Только мой код" для платформы .NET Framework и JavaScript, поскольку поведение пошагового выполнения не зависит от поведения стека вызовов.  

Начиная с Visual Studio 2017 15.8, можно указать необходимость включить только мой код для C++ с помощью **средства** > **параметры** > **Отладка**  >  **Общие** > **включить только мой код** (он включен по умолчанию). Это эквивалентно использованию [/JMC (Отладка только собственного кода)](/cpp/build/reference/jmc) параметр компилятора.
  
 **Стеки вызовов**  
  
 По умолчанию отладчик считает эти функции кодом, не написанным пользователем, в окнах стека вызовов.  
  
-   Функции с открытой исходной информацией в файле символов.  
  
-   Функции, в которых файлы символов указывают, что исходный файл, соответствующий кадру стека, отсутствует.  
  
-   Функции, определенные в файлах `*.natjmc`, находящихся в папке `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`.  
  
 **Шаг с заходом**  
  
 По умолчанию только функции, определенные в файлах `*.natstepfilter` (папка `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`), считаются кодом, не написанным пользователем.  
  
 Для настройки пошагового выполнения и поведения окна стека вызовов в `%USERPROFILE%\My Documents\Visual Studio 2017\Visualizers` вы можете создавать собственные `.natstepfilter` и `.natjmc`.  
  
###  <a name="BKMK_CPP_Stepping_behavior"></a> Поведение пошагового выполнения  
 Когда вы **шаг с заходом** (сочетание клавиш: F11) не написанный пользователем код из пользовательского кода, отладчик обходит код на следующую строку пользовательского кода. Когда вы **шаг с выходом** (Клавиатура: Shift + F11), отладчик переходит к следующей строке пользовательского кода. Если пользовательский код не обнаруживается, то выполнение продолжается, пока приложение завершает работу, точки останова или возникает исключение.  
  
 Если отладчик делает останов в коде, не написанном пользователем (например, если команда "Прервать все" останавливает в коде, не написанном пользователем), пошаговое выполнение продолжается в коде, не написанном пользователем.
  
###  <a name="BKMK_CPP_Exception_behavior"></a> Поведение исключения  
 Когда отладчик обнаруживает исключение, он останавливается на исключение независимо от того, находится ли он в пользователя или другого кода. **Не обработанное пользовательским кодом** параметры в **исключения** диалоговое окно учитываются.  
  
###  <a name="BKMK_CPP_Customize_stepping_behavior"></a> Настройка поведения пошагового выполнения  
 Вы можете определить функции, для которых будут выполняться шаги с обходом, внеся их в файлы `*.natstepfilter` как код, не написанный пользователем.  
  
-   Чтобы указать встроенный код для всех пользователей компьютера с Visual Studio, добавьте файл .natstepfilter в `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers` папку.  
  
-   Чтобы указать код, не написанный пользователем для отдельного пользователя, добавьте файл .natstepfilter в `%USERPROFILE%\My Documents\Visual Studio 2017\Visualizers` папку.  
  
 Файлы .natstepfilter представляют собой XML-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<StepFilter xmlns="http://schemas.microsoft.com/vstudio/debugger/natstepfilter/2010">  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Action>StepAction</Action>  
    </Function>  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Module>ModuleSpec</Module>  
        <Action>StepAction</Action>  
    </Function>  
</StepFilter>  
  
```  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|Функция|Обязательно. Указывает одну или несколько функций как функцию, не написанную пользователем.|  
|`Name`|Обязательно. Регулярное выражение в формате ECMA-262, содержащее полное имя функции для сопоставления. Пример:<br /><br /> `<Name>MyNS::MyClass.*</Name>`<br /><br /> сообщает отладчику, что все методы в `MyNS::MyClass`, должны считаться кодом, не написанным пользователем. Сопоставление учитывает регистр.|  
|`Module`|Необязательный. Регулярное выражение в формате ECMA-262, указывающее полный путь к модулю, содержащему функцию. Сопоставление не учитывает регистр.|  
|`Action`|Обязательно. Одно из следующих чувствительных к регистру значений:<br /><br /> -   `NoStepInto`  — указывает отладчику выполнять шаги с обходом соответствующей функции.<br />-   `StepInto`  — указывает отладчику выполнять шаги с заходом в соответствующие функции, отменяя все остальные `NoStepInto` для соответствующих функций.|  
  
###  <a name="BKMK_CPP_Customize_call_stack_behavior"></a> Настройка поведения стека вызовов  
 Вы можете указать модули, файлы исходного кода и функции, которые необходимо рассматривать как код, не написанный пользователем, в стеках вызовов, указав их в файлах `*.natjmc`.  
  
-   Чтобы указать встроенный код для всех пользователей компьютера с Visual Studio, добавьте файл .natjmc в `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers` папку.  
  
-   Чтобы указать код, не написанный пользователем для отдельного пользователя, добавьте файл .natjmc в `%USERPROFILE%\My Documents\Visual Studio 2017\Visualizers` папку.  
  
 Файлы .natjmc представляют собой XML-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NonUserCode xmlns="http://schemas.microsoft.com/vstudio/debugger/jmc/2015">  
  
  <!-- Modules -->  
  <Module Name="ModuleSpec" />  
  <Module Name="ModuleSpec" Company="CompanyName" />  
  
  <!-- Files -->  
  <File Name="FileSpec"/>  
  
  <!-- Functions -->  
  <Function Name="FunctionSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" ExceptionImplementation="true" />  
  
</NonUserCode>  
  
```  
  
 **Атрибуты элементов модуля**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательно. Полный путь к модулю или модулям. Можно использовать подстановочные знаки Windows `?` (ноль или один символ) и `*` (ноль или более символов). Например, примененная к объекту директива<br /><br /> `<Module Name="?:\3rdParty\UtilLibs\*" />`<br /><br /> указывает отладчику, что необходимо рассматривать все модули в `\3rdParty\UtilLibs` на любом диске как внешний код.|  
|`Company`|Необязательный. Название компании, публикующей модуль, внедренный в исполняемый файл. Этот атрибут можно использовать для устранения неоднозначности модулей.|  
  
 **Атрибуты элементов файла**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательно. Полный путь к файлу или файлам исходного кода, который необходимо считать внешним кодом. При задании пути можно использовать следующие подстановочные знаки Windows: `?` и `*`.|  
  
 **Атрибуты элементов функций**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательно. Полное имя функции, которую необходимо рассматривать как внешний код.|  
|`Module`|Необязательный. Имя модуля или полный путь к модулю, содержащему эту функцию. Этот атрибут можно использовать для устранения неоднозначности функций с одинаковыми именами.|  
|`ExceptionImplementation`|Если задано значение `true`, стек вызовов отображает функцию, которая создала исключение, а не данную функцию.|  
  
##  <a name="BKMK_JavaScript_Just_My_Code"></a> Только мой код JavaScript  
  
###  <a name="BKMK_JS_User_and_non_user_code"></a> Пользовательский код и не написанный пользователем код  
 **Классификации кода**  
  
 Режим "Только мой код" в JavaScript управляет пошаговым выполнением и отображением стека вызовов путем распределения кода по одной из следующих классификаций.  
  
|||  
|-|-|  
|**MyCode**|Код пользователя, которым вы распоряжаетесь и управляете.|  
|**LibraryCode**|Код, не написанный пользователем, полученный из библиотек, которыми вы пользуетесь регулярно и от которых зависит правильная работа приложения (например, WinJS или jQuery).|  
|**UnrelatedCode**|Непользовательский код, который может выполняться в приложении, но вы не являетесь его и приложение не зависит напрямую ей правильно функционировать. (Например, это может включать advertising SDK, отображающий объявления.) В проектах UWP любой код, который загружается в веб-приложения на основе HTTP или HTTPS URI также считается UnrelatedCode.|  
  
 Отладчик JavaScript автоматически классифицирует эти типы кода:  
  
-   Скрипт, который выполняется путем передачи строки предоставленной узлом `eval` функция классифицируется как **MyCode**.  
  
-   Скрипт, который выполняется путем передачи строки `Function` конструктор классифицируется как **LibraryCode**.  
  
-   Скрипт, содержащийся в ссылке платформы, например WinJS или Azure SDK, классифицируется как **LibraryCode**.  
  
-   Скрипт, который выполняется путем передачи строки `setTimeout`, `setImmediate`, или `setInterval` функции классифицируется как **UnrelatedCode**.  
  
-   С помощью `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json` во всех JavaScript-проектах Visual Studio определяется код, написанный другими пользователями, и код, не написанный пользователями.  
  
 Можно изменить классификации по умолчанию и классифицировать определенные файлы и url-адреса путем добавления файла .json с именем `mycode.json` в корневую папку проекта.  
  
 Весь остальной код классифицируется как **MyCode**.  
  
###  <a name="BKMK_JS_Stepping_behavior"></a> Поведение пошагового выполнения  
  
-   Если функция не является пользователем (**MyCode**) кода, **шаг с заходом** (сочетание клавиш: F11) ведет себя как **шаг с обходом** (Клавиатура: F10).  
  
-   Если шаг начинается в непользовательском (**LibraryCode** или **UnrelatedCode**) кода, пошаговое выполнение временно осуществляется, как если бы только мой код не включен. При выполнении шага обратно в пользовательский код, Just My Code возобновляется.  
  
-   Если шаг в коде пользователя приводит к выходу из текущего контекста выполнения (например, при выполнении шага в последней строке обработчика событий), отладчик останавливается на следующей выполняемой строке кода пользователя. Например, если обратный вызов выполняется в **LibraryCode** кода, отладчик продолжает, пока не будет выполнена следующая строка кода пользователя.
  
-   **Шаг с выходом** (Клавиатура: Shift + F11) останавливается на следующей строке пользовательского кода. Если пользовательский код не обнаруживается, то выполнение продолжается, пока приложение завершает работу, точки останова или возникает исключение.  
  
###  <a name="BKMK_JS_Breakpoint_behavior"></a> Поведение точек останова  
  
-   Точки останова, заданные в коде, всегда соблюдаются независимо от классификации этого кода  
  
-   Если ключевое слово `debugger` обнаруживается в:  
  
    -   **LibraryCode** кода, отладчик всегда останавливается.  
  
    -   **UnrelatedCode** кода, отладчик не останавливается.  
  
###  <a name="BKMK_JS_Exception_behavior"></a> Поведение исключения  
 Если необработанное исключение возникает в:  
  
-   **MyCode** или **LibraryCode** кода, отладчик всегда останавливается.  
  
-   **UnrelatedCode** кода, и **MyCode** или **LibraryCode** код находится в стеке вызовов, отладчик достигнет точки останова.  
  
 Если исключения первого шанса включены для исключения в диалоговом окне исключения и исключение **LibraryCode** или **UnrelatedCode** кода:  
  
-   Если исключение обрабатывается, отладчик не останавливается.  
  
-   Если исключение не обрабатывается, отладчик останавливается.  
  
###  <a name="BKMK_JS_Customize_Just_My_Code"></a> Настройка только мой код  
 Чтобы разделить код пользователя и код, не написанный пользователем, для отдельного проекта Visual Studio, добавьте файл .json с именем `mycode.json` в корневую папку проекта.  
  
 Классификации выполняются в следующем порядке:  
  
1.  Классификации по умолчанию  
  
2.  Классификации в файле `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json`  
  
3.  Классификации в файле `mycode. json` текущего проекта.  
  
 Каждый шаг классификации переопределяет предыдущие шаги. JSON-файл должен отображать все пары ключ-значение и **MyCode**, **библиотеки**, и **Unrelated** значения могут быть пустыми массивами.  
  
 Файлы .json кода пользователя используют следующий синтаксис:  
  
```json  
{  
    "Eval" : "Classification",  
    "Function" : "Classification",  
    "ScriptBlock" : "Classification",  
    "MyCode" : [  
        "UrlOrFileSpec",  
        . . .  
        "UrlOrFileSpec"  
    ],  
    "Libraries" : [  
        "UrlOrFileSpec",  
        . .  
        "UrlOrFileSpec"  
    ],  
    "Unrelated" : [  
        "UrlOrFileSpec",  
        . . .  
        "UrlOrFileSpec"  
    ]  
}  
  
```  
  
 **Eval, функция и ScriptBlock**  
  
 **Eval**, **функция**, и **ScriptBlock** пар ключ-значение как динамически определить классифицируется сформированного кода.  
  
|||  
|-|-|  
|**Eval**|Скрипт, который выполняется путем передачи строки предоставленной хостом функции `eval`. По умолчанию скрипт Eval классифицируется как **MyCode**.|  
|**Function**|Скрипт, который выполняется путем передачи строки конструктору `Function`. По умолчанию скрипт функция классифицируется как **LibraryCode**.|  
|**Блок сценария**|Скрипт, который выполняется путем передачи строки функциям `setTimeout`, `setImmediate` или `setInterval`. По умолчанию скрипт ScriptBlock классифицируется как **UnrelatedCode**.|  
  
 Можно изменить это значение на одно из следующих ключевых слов:  
  
-   `MyCode`  классифицирует скрипт как **MyCode**.  
  
-   `Library`  классифицирует скрипт как **LibraryCode**.  
  
-   `Unrelated`  классифицирует скрипт как **UnrelatedCode**.  
  
 **MyCode, библиотеки и не связана**  
  
 **MyCode**, **библиотеки**, и **Unrelated** пар ключ-значение укажите URL-адресов или файлы, которые вы хотите включить в классификацию:  
  
|||  
|-|-|  
|**MyCode**|Массив URL-адресов или файлы, которые классифицируются как **MyCode**.|  
|**Библиотеки**|Массив URL-адресов или файлы, которые классифицируются как **LibraryCode**.|  
|**Несвязанные**|Массив URL-адресов или файлы, которые классифицируются как **UnrelatedCode**.|  
  
 Строка URL-адреса или файла может содержать один или несколько символов `*`, соответствующих любому количеству символов. `*` равноценен регулярному выражению `.*`.
