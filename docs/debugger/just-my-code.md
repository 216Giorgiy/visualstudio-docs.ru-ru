---
title: Отладка кода пользователя только мой код | Документы Microsoft
ms.custom: ''
ms.date: 05/18/2017
ms.technology:
- vs-ide-debug
ms.topic: conceptual
ms.assetid: 0f0df097-bbaf-46ad-9ad1-ef5f40435079
author: mikejo5000
ms.author: mikejo
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: bf41b8d264d353b6c47acd2e0a762a57d46412e1
ms.sourcegitcommit: 6a9d5bd75e50947659fd6c837111a6a547884e2a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="specify-whether-to-debug-only-user-code-using-just-my-code-in-visual-studio"></a>Укажите, следует ли выполнить отладку пользовательского кода, с использованием "только мой код" в Visual Studio
Можно настроить Visual Studio автоматически шаг с обходом системные, платформенные и другие не являющиеся пользовательскими вызовы и свернуть такие вызовы в окне стека вызовов. Функция, которая включает или отключает это поведение называется *только мой код*. В этом разделе описывается использование только мой код в проектах C#, Visual Basic, C++ и JavaScript.

Для большинства языков программирования по умолчанию включен только мой код.
  
##  <a name="BKMK_Enable_or_disable_Just_My_Code"></a> Включить или отключить только мой код  
 Чтобы включить или отключить только мой код, выберите **Сервис > Параметры** меню в Visual Studio. В **Отладка** > **Общие** узла, установите или снимите флажок **включить только мой код**.
  
 ![Включить только мой код в диалоговом окне Параметры](../debugger/media/dbg_justmycode_options.png "DBG_JustMyCode_Options")  
  
> [!NOTE]
>  **Включить только мой код** параметр является глобальным параметром, который применяется ко всем проектам Visual Studio на всех языках.  
  
###  <a name="BKMK_Override_call_stack_filtering"></a> Показать непользовательском коде в представления стека вызовов  
 В представлениях, отображает стек вызовов, таких как **стек вызовов** и **задачи** windows только мой код сворачивает код, написанный не пользователем в кадр с аннотациями с меткой `[External Code]`. Для просмотра свернутых кадров выберите **Показать внешний код** контекстного меню стека вызовов отображения.

 ![Показать внешний код в окне стека вызовов](../debugger/media/dbg_justmycode_showexternalcode.png "DBG_JustMyCode_ShowExternalCode")
  
> [!NOTE]
>  **Показать внешний код** сохраняется в профилировщик текущего пользователя. Он применяется ко всем проектам на всех языках, открываемых этим пользователем.
  
##  <a name="BKMK__NET_Framework_Just_My_Code"></a> Только мой код .NET framework  
  
###  <a name="BKMK_NET_User_and_non_user_code"></a> Пользовательский код и не написанный пользователем код  
 Чтобы отличить пользовательский код от другого кода, только мой код рассматривает файлов символов (.pdb) и программную оптимизацию. Отладчик считает код, не написанным пользователем, если двоичный файл оптимизируется или если pdb-файл недоступен.
  
 Три атрибута также влияют на то, какой код отладчик считаем кодом пользователя:  
  
-   <xref:System.Diagnostics.DebuggerNonUserCodeAttribute> сообщает отладчику, что код, к которому он применяется, не является пользовательским.  
  
-   <xref:System.Diagnostics.DebuggerHiddenAttribute> скрывает код от отладчика, даже если режим "Только мой код" включен.  
  
-   <xref:System.Diagnostics.DebuggerStepThroughAttribute> указывает отладчику выполнить в пошаговом режим код, к которому он применяется, а не осуществлять шаг с заходом в этот код.  
  
 Весь остальной код считается пользовательским.  
  
###  <a name="BKMK_NET_Stepping_behavior"></a> Поведение пошагового выполнения  
 Когда вы **шаг с заходом** (сочетание клавиш: F11) не написанный пользователем, отладчик выполняет код переходом к следующему оператору пользователя. Когда вы **шаг с выходом** (Клавиатура: Shift + F11), отладчик переходит к следующей строке пользовательского кода. Если код пользователя не обнаруживается, то выполнение продолжается до приложение завершает работу, точки останова или возникает исключение.  
  
###  <a name="BKMK_NET_Breakpoint_behavior"></a> Поведение точки останова  
 Если включена только мой код, вы можете **прервать все** (Клавиатура: Ctrl + Alt + Break) и остановить выполнение в месте там, где нет кода пользователя для отображения. Когда это происходит, отображается окно "Нет исходного кода". Если затем выбирается команда "Шаг", отладчик переходит к следующей строке пользовательского кода.  
  
###  <a name="BKMK_NET_Exception_behavior"></a> Поведение исключения  
 При возникновении необработанного исключения в коде, написанном не пользователем, отладчик прерывается на той строке в коде пользователя, где было создано исключение.  
  
 Если для этого исключения включена первичная обработка исключения, строка кода пользователя выделяется зеленым цветом. Стек вызовов отображает кадр с аннотациями с меткой **[внешний код]**.  
  
##  <a name="BKMK_C___Just_My_Code"></a> Только мой код C++  
  
###  <a name="BKMK_CPP_User_and_non_user_code"></a> Пользовательский код и не написанный пользователем код  
 Функция "Только мой код" в C++ отличается от функции "Только мой код" для платформы .NET Framework и JavaScript, поскольку поведение пошагового выполнения не зависит от поведения стека вызовов.  
  
 **Стеки вызовов**  
  
 По умолчанию отладчик считает эти функции кодом, не написанным пользователем, в окнах стека вызовов.  
  
-   Функции с открытой исходной информацией в файле символов.  
  
-   Функции, в которых файлы символов указывают, что исходный файл, соответствующий кадру стека, отсутствует.  
  
-   Функции, определенные в файлах `*.natjmc`, находящихся в папке `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`.  
  
 **Шаг с заходом**  
  
 По умолчанию только функции, определенные в файлах `*.natstepfilter` (папка `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`), считаются кодом, не написанным пользователем.  
  
 Для настройки пошагового выполнения и поведения окна стека вызовов в `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` вы можете создавать собственные `.natstepfilter` и `.natjmc`.  
  
###  <a name="BKMK_CPP_Stepping_behavior"></a> Поведение пошагового выполнения  
 Когда вы **шаг с заходом** (сочетание клавиш: F11) не написанный пользователем код из пользовательского кода, отладчик выполняет этот код в следующей строке кода пользователя. Когда вы **шаг с выходом** (Клавиатура: Shift + F11), отладчик переходит к следующей строке пользовательского кода. Если код пользователя не обнаруживается, то выполнение продолжается до приложение завершает работу, точки останова или возникает исключение.  
  
 Если отладчик делает останов в коде, не написанном пользователем (например, если команда "Прервать все" останавливает в коде, не написанном пользователем), пошаговое выполнение продолжается в коде, не написанном пользователем.  
  
###  <a name="BKMK_CPP_Exception_behavior"></a> Поведение исключения  
 Если отладчик обнаруживает исключение, он останавливается на исключении независимо от того, он в непользовательском коде. **Пользовательским кодом** параметры в **исключения** диалоговое окно учитываются.  
  
###  <a name="BKMK_CPP_Customize_stepping_behavior"></a> Настройка поведения пошагового выполнения  
 Вы можете определить функции, для которых будут выполняться шаги с обходом, внеся их в файлы `*.natstepfilter` как код, не написанный пользователем.  
  
-   Чтобы определить код, написанный не пользователем для всех пользователей компьютера с Visual Studio, добавить файл .natstepfilter `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers` папки.  
  
-   Чтобы определить код, написанный не пользователем для отдельного пользователя, добавить файл .natstepfilter `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` папки.  
  
 Файлы .natstepfilter представляют собой XML-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<StepFilter xmlns="http://schemas.microsoft.com/vstudio/debugger/natstepfilter/2010">  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Action>StepAction</Action>  
    </Function>  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Module>ModuleSpec</Module>  
        <Action>StepAction</Action>  
    </Function>  
</StepFilter>  
  
```  
  
|Элемент|Описание|  
|-------------|-----------------|  
|Функция|Обязательно. Указывает одну или несколько функций как функцию, не написанную пользователем.|  
|`Name`|Обязательно. Регулярное выражение в формате ECMA-262, содержащее полное имя функции для сопоставления. Пример:<br /><br /> `<Name>MyNS::MyClass.*</Name>`<br /><br /> сообщает отладчику, что все методы в `MyNS::MyClass`, должны считаться кодом, не написанным пользователем. Сопоставление учитывает регистр.|  
|`Module`|Необязательный. Регулярное выражение в формате ECMA-262, указывающее полный путь к модулю, содержащему функцию. Сопоставление не учитывает регистр.|  
|`Action`|Обязательно. Одно из следующих чувствительных к регистру значений:<br /><br /> -   `NoStepInto`  — указывает отладчику, шаг с обходом соответствующей функции.<br />-   `StepInto`  — указывает отладчику выполнить шаг с заходом в соответствующие функции, отменяя все остальные `NoStepInto` для соответствующих функций.|  
  
###  <a name="BKMK_CPP_Customize_call_stack_behavior"></a> Настройка поведения стека вызовов  
 Вы можете указать модули, файлы исходного кода и функции, которые необходимо рассматривать как код, не написанный пользователем, в стеках вызовов, указав их в файлах `*.natjmc`.  
  
-   Чтобы определить код, написанный не пользователем для всех пользователей компьютера с Visual Studio, добавить файл .natjmc `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers` папки.  
  
-   Чтобы определить код, написанный не пользователем для отдельного пользователя, добавить файл .natjmc `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` папки.  
  
 Файлы .natjmc представляют собой XML-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NonUserCode xmlns="http://schemas.microsoft.com/vstudio/debugger/jmc/2015">  
  
  <!-- Modules -->  
  <Module Name="ModuleSpec" />  
  <Module Name="ModuleSpec" Company="CompanyName" />  
  
  <!-- Files -->  
  <File Name="FileSpec"/>  
  
  <!-- Functions -->  
  <Function Name="FunctionSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" ExceptionImplementation="true" />  
  
</NonUserCode>  
  
```  
  
 **Атрибуты элементов модуля**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательно. Полный путь к модулю или модулям. Можно использовать подстановочные знаки Windows `?` (ноль или один символ) и `*` (ноль или более символов). Например, примененная к объекту директива<br /><br /> `<Module Name="?:\3rdParty\UtilLibs\*" />`<br /><br /> указывает отладчику, что необходимо рассматривать все модули в `\3rdParty\UtilLibs` на любом диске как внешний код.|  
|`Company`|Необязательный. Название компании, публикующей модуль, внедренный в исполняемый файл. Этот атрибут можно использовать для устранения неоднозначности модулей.|  
  
 **Атрибуты элементов файла**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательно. Полный путь к файлу или файлам исходного кода, который необходимо считать внешним кодом. При задании пути можно использовать следующие подстановочные знаки Windows: `?` и `*`.|  
  
 **Атрибуты элементов функций**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательно. Полное имя функции, которую необходимо рассматривать как внешний код.|  
|`Module`|Необязательный. Имя модуля или полный путь к модулю, содержащему эту функцию. Этот атрибут можно использовать для устранения неоднозначности функций с одинаковыми именами.|  
|`ExceptionImplementation`|Если задано значение `true`, стек вызовов отображает функцию, которая создала исключение, а не данную функцию.|  
  
##  <a name="BKMK_JavaScript_Just_My_Code"></a> Только мой код JavaScript  
  
###  <a name="BKMK_JS_User_and_non_user_code"></a> Пользовательский код и не написанный пользователем код  
 **Классификации кода**  
  
 Режим "Только мой код" в JavaScript управляет пошаговым выполнением и отображением стека вызовов путем распределения кода по одной из следующих классификаций.  
  
|||  
|-|-|  
|**MyCode**|Код пользователя, которым вы распоряжаетесь и управляете.|  
|**LibraryCode**|Код, не написанный пользователем, полученный из библиотек, которыми вы пользуетесь регулярно и от которых зависит правильная работа приложения (например, WinJS или jQuery).|  
|**UnrelatedCode**|Не принадлежащий пользователю код, который может выполняться в приложении, но он не принадлежит вам, и приложение не зависит от него напрямую для правильной работы. (Например, это может включать SDK, отображающий объявления рекламу.) В проектах UWP любой код, который загружается в приложение из URI HTTP или HTTPS также считается UnrelatedCode.|  
  
 Отладчик JavaScript автоматически классифицирует эти типы кода:  
  
-   Скрипт, который выполняется путем передачи строки предоставленной хостом `eval` функция классифицируется как **MyCode**.  
  
-   Скрипт, который выполняется путем передачи строки `Function` конструктор классифицируется как **LibraryCode**.  
  
-   Скрипт, содержащийся в ссылке платформы, например WinJS или Azure SDK, классифицируется как **LibraryCode**.  
  
-   Скрипт, который выполняется путем передачи строки `setTimeout`, `setImmediate`, или `setInterval` функции классифицируется как **UnrelatedCode**.  
  
-   С помощью `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json` во всех JavaScript-проектах Visual Studio определяется код, написанный другими пользователями, и код, не написанный пользователями.  
  
 Можно изменить классификации по умолчанию и классифицировать определенные файлы и url-адреса путем добавления файла .json с именем `mycode.json` в корневую папку проекта.  
  
 Весь остальной код классифицируется как **MyCode**.  
  
###  <a name="BKMK_JS_Stepping_behavior"></a> Поведение пошагового выполнения  
  
-   Если функция не является пользователем (**MyCode**) код, **шаг с заходом** (сочетание клавиш: F11) ведет себя как **шаг с обходом** (Клавиатура: F10).  
  
-   Если шаг начинается в непользовательском (**LibraryCode** или **UnrelatedCode**) код, пошаговое выполнение временно осуществляется, как будто только мой код не включен. При переходе обратно в пользовательском коде, только мой код возобновляется.  
  
-   Если шаг в коде пользователя приводит к выходу из текущего контекста выполнения (например, при выполнении шага в последней строке обработчика событий), отладчик останавливается на следующей выполняемой строке кода пользователя. Например, если обратный вызов выполняется в **LibraryCode** кода, отладчик продолжает выполнение, пока не будет выполнена следующая строка кода пользователя.
  
-   **Шаг с выходом** (Клавиатура: Shift + F11) останавливается на следующей строке кода пользователя. Если код пользователя не обнаруживается, то выполнение продолжается до приложение завершает работу, точки останова или возникает исключение.  
  
###  <a name="BKMK_JS_Breakpoint_behavior"></a> Поведение точки останова  
  
-   Точки останова, заданные в коде, всегда соблюдаются независимо от классификации этого кода  
  
-   Если ключевое слово `debugger` обнаруживается в:  
  
    -   **LibraryCode** кода, отладчик всегда останавливается.  
  
    -   **UnrelatedCode** кода, отладчик не останавливается.  
  
###  <a name="BKMK_JS_Exception_behavior"></a> Поведение исключения  
 Если необработанное исключение возникает в:  
  
-   **MyCode** или **LibraryCode** кода, отладчик всегда останавливается.  
  
-   **UnrelatedCode** кода, и **MyCode** или **LibraryCode** код находится в стеке вызовов, отладчик останавливается.  
  
 Если исключения первого шанса включены для данного исключения диалоговое окно исключения и исключение **LibraryCode** или **UnrelatedCode** кода:  
  
-   Если исключение обрабатывается, отладчик не останавливается.  
  
-   Если исключение не обрабатывается, отладчик останавливается.  
  
###  <a name="BKMK_JS_Customize_Just_My_Code"></a> Настройка только мой код  
 Чтобы разделить код пользователя и код, не написанный пользователем, для отдельного проекта Visual Studio, добавьте файл .json с именем `mycode.json` в корневую папку проекта.  
  
 Классификации выполняются в следующем порядке:  
  
1.  Классификации по умолчанию  
  
2.  Классификации в файле `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json`  
  
3.  Классификации в файле `mycode. json` текущего проекта.  
  
 Каждый шаг классификации переопределяет предыдущие шаги. JSON-файл должен отображать все пары ключ-значение и **MyCode**, **библиотеки**, и **Unrelated** значения могут быть пустыми массивами.  
  
 Файлы .json кода пользователя используют следующий синтаксис:  
  
```json  
{  
    "Eval" : "Classification",  
    "Function" : "Classification",  
    "ScriptBlock" : "Classification",  
    "MyCode" : [  
        "UrlOrFileSpec",  
        . . .  
        "UrlOrFileSpec"  
    ],  
    "Libraries" : [  
        "UrlOrFileSpec",  
        . .  
        "UrlOrFileSpec"  
    ],  
    "Unrelated" : [  
        "UrlOrFileSpec",  
        . . .  
        "UrlOrFileSpec"  
    ]  
}  
  
```  
  
 **Eval, функция и ScriptBlock**  
  
 **Eval**, **функция**, и **ScriptBlock** пары ключ-значение как динамически определите классифицируется сформированного кода.  
  
|||  
|-|-|  
|**Eval**|Скрипт, который выполняется путем передачи строки предоставленной хостом функции `eval`. По умолчанию скрипт Eval классифицируется как **MyCode**.|  
|**Function**|Скрипт, который выполняется путем передачи строки конструктору `Function`. По умолчанию скрипт функция классифицируется как **LibraryCode**.|  
|**ScriptBlock**|Скрипт, который выполняется путем передачи строки функциям `setTimeout`, `setImmediate` или `setInterval`. По умолчанию скрипт ScriptBlock классифицируется как **UnrelatedCode**.|  
  
 Можно изменить это значение на одно из следующих ключевых слов:  
  
-   `MyCode`  классифицирует скрипт как **MyCode**.  
  
-   `Library`  классифицирует скрипт как **LibraryCode**.  
  
-   `Unrelated`  классифицирует скрипт как **UnrelatedCode**.  
  
 **MyCode, библиотеки и Unrelated**  
  
 **MyCode**, **библиотеки**, и **Unrelated** пары ключ-значение укажите URL-адресов или файлы, которые требуется включить в классификацию:  
  
|||  
|-|-|  
|**MyCode**|Массив URL-адресов или файлы, которые классифицируются как **MyCode**.|  
|**Библиотеки**|Массив URL-адресов или файлы, которые классифицируются как **LibraryCode**.|  
|**Несвязанные**|Массив URL-адресов или файлы, которые классифицируются как **UnrelatedCode**.|  
  
 Строка URL-адреса или файла может содержать один или несколько символов `*`, соответствующих любому количеству символов. `*` равноценен регулярному выражению `.*`.