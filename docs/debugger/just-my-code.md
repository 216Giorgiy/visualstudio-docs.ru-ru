---
title: "Только мой код | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-ide-debug"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "FSharp"
  - "VB"
  - "CSharp"
  - "C++"
ms.assetid: 0f0df097-bbaf-46ad-9ad1-ef5f40435079
caps.latest.revision: 9
caps.handback.revision: 7
author: "mikejo5000"
ms.author: "mikejo"
manager: "ghogen"
---
# Только мой код
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

Разработчики, использующие языки платформы .NET Framework, знакомы с функцией отладчика "Только мой код", которая выполняет системные, платформенные и другие не относящиеся к пользователю вызовы и сворачивает эти вызовы в окнах стека вызовов.  Режим "Только мой код" теперь предусмотрен для языков C\+\+ и JavaScript.  В этом разделе описаны особенности использования режима "Только мой код" в платформе .NET Framework и проектах, изначально основанных на C\+\+ и JavaScript.  
  
##  <a name="BKMK_Contents"></a> Содержание  
 [Включение и отключение режима "Только мой код"](#BKMK_Enable_or_disable_Just_My_Code)  
  
 ["Только мой код" в .NET Framework](#BKMK__NET_Framework_Just_My_Code)  
  
 ["Только мой код" в C++](#BKMK_C___Just_My_Code)  
  
 ["Только мой код" в JavaScript](#BKMK_JavaScript_Just_My_Code)  
  
##  <a name="BKMK_Enable_or_disable_Just_My_Code"></a> Включение и отключение режима "Только мой код"  
 Для включения или отключения режима "Только мой код" выберите **Параметры и настройки** в меню **Отладка**.  В узле **Отладка** \/ **Общие** установите или снимите флажок **Включить только мой код**.  
  
 ![Флажок "Включить только мой код" в диалоговом окне "Параметры"](../debugger/media/dbg_justmycode_options.png "DBG\_JustMyCode\_Options")  
  
> [!NOTE]
>  Параметр **Включить только мой код** является глобальным параметром, который применяется ко всем проектам Visual Studio на всех языках.  
  
###  <a name="BKMK_Override_call_stack_filtering"></a> Фильтрация стека вызовов переопределения  
 На экранах стека вызовов, таких как окна стека вызовов и задач, режим "Только мой код" сворачивает код, не написанный пользователем, в кадр с аннотациями и подписью `[External Code]`.  Для просмотра свернутых кадров выберите **Показать внешний код** в контекстном меню отображения стека вызовов.  
  
> [!NOTE]
>  Параметр **Показать внешний код** сохраняется в профилировщик текущего пользователя.  Он применяется ко всем проектам на всех языках, открываемых этим пользователем.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents)  
  
##  <a name="BKMK__NET_Framework_Just_My_Code"></a> "Только мой код" в .NET Framework  
 [Пользовательский код и код, не написанный пользователем](#BKMK_NET_User_and_non_user_code) **&#124;** [Поведение пошагового выполнения](#BKMK_NET_Stepping_behavior) **&#124;** [Поведение точки останова](#BKMK_NET_Breakpoint_behavior) **&#124;** [Поведение исключения](#BKMK_NET_Exception_behavior)  
  
###  <a name="BKMK_NET_User_and_non_user_code"></a> Пользовательский код и код, не написанный пользователем  
 Чтобы отличить пользовательский код от другого кода, функция "Только мой код" рассматривает открытые проекты, файлы символов \(.pdb\) и программную оптимизацию.  
  
1.  Если двоичный файл создается из открытого проекта Visual Studio, он всегда считается пользовательским кодом.  
  
2.  Отладчик считает код, не написанным пользователем, если двоичный файл оптимизируется или если pdb\-файл недоступен.  
  
 Три атрибута также влияют на то, какой код отладчик считаем кодом пользователя:  
  
-   <xref:System.Diagnostics.DebuggerNonUserCodeAttribute> сообщает отладчику, что код, к которому он применяется, не является пользовательским.  
  
-   <xref:System.Diagnostics.DebuggerHiddenAttribute> скрывает код от отладчика, даже если режим "Только мой код" включен.  
  
-   <xref:System.Diagnostics.DebuggerStepThroughAttribute> указывает отладчику выполнить в пошаговом режим код, к которому он применяется, а не осуществлять шаг с заходом в этот код.  
  
 Весь остальной код считается пользовательским.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в .NET Framework](#BKMK__NET_Framework_Just_My_Code)  
  
###  <a name="BKMK_NET_Stepping_behavior"></a> Поведение пошагового выполнения  
 При выполнении **Шага с заходом** \(клавиша F11\) внутрь кода, не написанного пользователем, отладчик выполняет этот код с переходом к следующему оператору пользователя.  При выполнении **Шага с выходом** \(сочетание клавиш: Shift \+ F11\) отладчик переходит к следующей строке пользовательского кода.  Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в .NET Framework](#BKMK__NET_Framework_Just_My_Code)  
  
###  <a name="BKMK_NET_Breakpoint_behavior"></a> Поведение точки останова  
 Если включен режим "Только мой код", можно выбрать **Прервать все** \(сочетание клавиш: Ctrl \+ Alt \+ Break\) и остановить выполнение в месте, где нет кода пользователя.  Когда это происходит, отображается окно "Нет исходного кода".  Если затем выбирается команда "Шаг", отладчик переходит к следующей строке пользовательского кода.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в .NET Framework](#BKMK__NET_Framework_Just_My_Code)  
  
###  <a name="BKMK_NET_Exception_behavior"></a> Поведение исключения  
 При возникновении необработанного исключения в коде, написанном не пользователем, отладчик прерывается на той строке в коде пользователя, где было создано исключение.  
  
 Если для этого исключения включена первичная обработка исключения, строка кода пользователя выделяется зеленым цветом.  Стек вызовов отображает кадр с аннотациями с подписью **\[Внешний код\]**.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в .NET Framework](#BKMK__NET_Framework_Just_My_Code)  
  
##  <a name="BKMK_C___Just_My_Code"></a> "Только мой код" в C\+\+  
 [Пользовательский код и код, не написанный пользователем](#BKMK_CPP_User_and_non_user_code) **&#124;** [Поведение пошагового выполнения](#BKMK_CPP_Stepping_behavior) **&#124;** [Поведение исключения](#BKMK_CPP_Exception_behavior) **&#124;** [Настройка поведения пошагового выполнения](#BKMK_CPP_Customize_stepping_behavior) **&#124;** [Настройка поведения стека вызовов](#BKMK_CPP_Customize_call_stack_behavior)  
  
###  <a name="BKMK_CPP_User_and_non_user_code"></a> Пользовательский код и код, не написанный пользователем  
 Функция "Только мой код" в C\+\+ отличается от функции "Только мой код" для платформы .NET Framework и JavaScript, поскольку поведение пошагового выполнения не зависит от поведения стека вызовов.  
  
 **Стеки вызовов**  
  
 По умолчанию отладчик считает эти функции кодом, не написанным пользователем, в окнах стека вызовов.  
  
-   Функции с открытой исходной информацией в файле символов.  
  
-   Функции, в которых файлы символов указывают, что исходный файл, соответствующий кадру стека, отсутствует.  
  
-   Функции, определенные в файлах `*.natjmc`, находящихся в папке `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`.  
  
 **Отладка по шагам**  
  
 По умолчанию только функции, определенные в файлах `*.natstepfilter` \(папка `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`\), считаются кодом, не написанным пользователем.  
  
 Для настройки пошагового выполнения и поведения окна стека вызовов в `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers` вы можете создавать собственные `.natstepfilter` и `.natjmc`.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в C++](#BKMK_C___Just_My_Code)  
  
###  <a name="BKMK_CPP_Stepping_behavior"></a> Поведение пошагового выполнения  
 При выполнении **Шага с заходом** \(клавиша F11\) внутрь кода, не написанного пользователем, из пользовательского кода отладчик выполняет этот код с переходом к следующей строке пользовательского кода.  При выполнении **Шага с выходом** \(сочетание клавиш: Shift \+ F11\) отладчик переходит к следующей строке пользовательского кода.  Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
 Если отладчик делает останов в коде, не написанном пользователем \(например, если команда "Прервать все" останавливает в коде, не написанном пользователем\), пошаговое выполнение продолжается в коде, не написанном пользователем.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в C++](#BKMK_C___Just_My_Code)  
  
###  <a name="BKMK_CPP_Exception_behavior"></a> Поведение исключения  
 Если отладчик обнаруживает исключение, он останавливается на исключении независимо от того, находится ли оно в коде пользователя.  Параметры **Не обработанные пользовательским кодом** в диалоговом окне **Исключения** игнорируются.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в C++](#BKMK_C___Just_My_Code)  
  
###  <a name="BKMK_CPP_Customize_stepping_behavior"></a> Настройка поведения пошагового выполнения  
 Вы можете определить функции, для которых будут выполняться шаги с обходом, внеся их в файлы `*.natstepfilter` как код, не написанный пользователем.  
  
-   Чтобы для всех пользователей компьютера с Visual Studio определить код, не написанный пользователями, вставьте  файл .natstepfilter в папку `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`.  
  
-   Чтобы определить код, не написанный пользователем, для отдельного пользователя, вставьте  файл .natstepfilter в папку `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers`.  
  
 .  Файлы .natstepfilter представляют собой XML\-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<StepFilter xmlns="http://schemas.microsoft.com/vstudio/debugger/natstepfilter/2010">  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Action>StepAction</Action>  
    </Function>  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Module>ModuleSpec</Module>  
        <Action>StepAction</Action>  
    </Function>  
</StepFilter>  
  
```  
  
|Элемент|Описание|  
|-------------|--------------|  
|Функция|Обязательный.  Указывает одну или несколько функций как функцию, не написанную пользователем.|  
|`Name`|Обязательный.  Регулярное выражение в формате ECMA\-262, содержащее полное имя функции для сопоставления.  Пример:<br /><br /> `<Name>MyNS::MyClass.*</Name>`<br /><br /> сообщает отладчику, что все методы в `MyNS::MyClass`, должны считаться кодом, не написанным пользователем.  Сопоставление учитывает регистр.|  
|`Module`|Необязательно.  Регулярное выражение в формате ECMA\-262, указывающее полный путь к модулю, содержащему функцию.  Сопоставление не учитывает регистр.|  
|`Action`|Обязательный.  Одно из следующих чувствительных к регистру значений:<br /><br /> -   `NoStepInto`  — указывает отладчику, что необходимо выполнить шаг с обходом соответствующей функции.<br />-   `StepInto`  — указывает отладчику, что необходимо осуществить шаги с заходом в соответствующие функции, отменяя все остальные инструкции `NoStepInto` для соответствующих функций.|  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в C++](#BKMK_C___Just_My_Code)  
  
###  <a name="BKMK_CPP_Customize_call_stack_behavior"></a> Настройка поведения стека вызовов  
 Вы можете указать модули, файлы исходного кода и функции, которые необходимо рассматривать как код, не написанный пользователем, в стеках вызовов, указав их в файлах `*.natjmc`.  
  
-   Чтобы для всех пользователей компьютера с Visual Studio определить код, не написанный пользователями, вставьте  файл .natjmc в папку `%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers`.  
  
-   Чтобы определить код, не написанный пользователем, для отдельного пользователя, вставьте  файл .natjmc в папку `%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers`.  
  
 .  Файлы .natjmc представляют собой XML\-файлы со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NonUserCode xmlns="http://schemas.microsoft.com/vstudio/debugger/jmc/2015">  
  
  <!-- Modules -->  
  <Module Name="ModuleSpec" />  
  <Module Name="ModuleSpec" Company="CompanyName" />  
  
  <!-- Files -->  
  <File Name="FileSpec"/>  
  
  <!-- Functions -->  
  <Function Name="FunctionSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" ExceptionImplementation="true" />  
  
</NonUserCode>  
  
```  
  
 **Атрибуты элементов модуля**  
  
|Атрибут|Описание|  
|-------------|--------------|  
|`Name`|Обязательный.  Полный путь к модулю или модулям.  Вы можете использовать следующие подстановочные знаки Windows: `?` \(ни одного или один символ\) и `*` \(ни одного или несколько символов\).  Например:<br /><br /> `<Module Name=”?:\3rdParty\UtilLibs\*” />`<br /><br /> указывает отладчику, что необходимо рассматривать все модули в `\3rdParty\UtilLibs` на любом диске как внешний код.|  
|`Company`|Необязательно.  Название компании, публикующей модуль, внедренный в исполняемый файл.  Этот атрибут можно использовать для устранения неоднозначности модулей.|  
  
 **Атрибуты элементов файла**  
  
|Атрибут|Описание|  
|-------------|--------------|  
|`Name`|Обязательный.  Полный путь к файлу или файлам исходного кода, который необходимо считать внешним кодом.  При задании пути можно использовать следующие подстановочные знаки Windows: `?` и `*`.|  
  
 **Атрибуты элементов функций**  
  
|Атрибут|Описание|  
|-------------|--------------|  
|`Name`|Обязательный.  Полное имя функции, которую необходимо рассматривать как внешний код.|  
|`Module`|Необязательно.  Имя модуля или полный путь к модулю, содержащему эту функцию.  Этот атрибут можно использовать для устранения неоднозначности функций с одинаковыми именами.|  
|`ExceptionImplementation`|Если задано значение `true`, стек вызовов отображает функцию, которая создала исключение, а не данную функцию.|  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в C++](#BKMK_C___Just_My_Code)  
  
##  <a name="BKMK_JavaScript_Just_My_Code"></a> "Только мой код" в JavaScript  
 [Пользовательский код и код, не написанный пользователем](#BKMK_JS_User_and_non_user_code) **&#124;** [Поведение пошагового выполнения](#BKMK_JS_Stepping_behavior) **&#124;** [Поведение точки останова](#BKMK_JS_Breakpoint_behavior) **&#124;** [Поведение исключения](#BKMK_JS_Exception_behavior) **&#124;** [Настройка режима "Только мой код"](#BKMK_JS_Customize_Just_My_Code)  
  
###  <a name="BKMK_JS_User_and_non_user_code"></a> Пользовательский код и код, не написанный пользователем  
 **Классификации кода**  
  
 Режим "Только мой код" в JavaScript управляет пошаговым выполнением и отображением стека вызовов путем распределения кода по одной из следующих классификаций.  
  
|||  
|-|-|  
|**MyCode**|Код пользователя, которым вы распоряжаетесь и управляете.|  
|**LibraryCode**|Код, не написанный пользователем, полученный из библиотек, которыми вы пользуетесь регулярно и от которых зависит правильная работа приложения \(например, WinJS или jQuery\).|  
|**UnrelatedCode**|Код, не написанный пользователем, который может выполняться в приложении, но вы не являетесь его владельцем, а ваше верная работа вашего приложения не зависит от него напрямую \(например, рекламный SDK, отображающий объявления\).  В проектах Магазина Windows любой код, который загружается в приложение из URI HTTP или HTTPS, также считается UnrelatedCode.|  
  
 Отладчик JavaScript автоматически классифицирует эти типы кода:  
  
-   Скрипт, который выполняется путем передачи строки предоставленной хостом функции `eval`, классифицируется как **MyCode**.  
  
-   Скрипт, который выполняется путем передачи строки конструктору `Function`, классифицируется как **LibraryCode**.  
  
-   Скрипт, который содержится в ссылке платформы, например WinJS или SDK Azure, классифицируется как **LibraryCode**.  
  
-   Скрипт, который выполняется путем передачи строки функциям `setTimeout`, `setImmediate` или `setInterval`, классифицируется как **UnrelatedCode**.  
  
-   С помощью `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json` во всех JavaScript\-проектах Visual Studio определяется код, написанный другими пользователями, и код, не написанный пользователями.  
  
 Можно изменить классификации по умолчанию и классифицировать определенные файлы и url\-адреса путем добавления файла .json с именем `mycode.json` в корневую папку проекта.  
  
 Весь остальной код классифицируется как **MyCode**.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в JavaScript](#BKMK_JavaScript_Just_My_Code)  
  
###  <a name="BKMK_JS_Stepping_behavior"></a> Поведение пошагового выполнения  
  
-   Если функция не относится к коду пользователя \(**MyCode**\), операция **Шаг с заходом** \(клавиша F11\) ведет себя как **Шаг с обходом** \(клавиша F10\).  
  
-   Если шаг начинается в коде, не написанном пользователем \(**LibraryCode** или **UnrelatedCode**\), пошаговое выполнение временно осуществляется, как будто режим "Только мой код" не включен.  Сразу после возвращения в код пользователя пошаговое выполнение в режиме "Только мой код" возобновляется.  
  
-   Если шаг в коде пользователя приводит к выходу из текущего контекста выполнения \(например, при выполнении шага в последней строке обработчика событий\), отладчик останавливается на следующей выполняемой строке кода пользователя.  Например, если обратный вызов выполняется в коде **LibraryCode**, отладчик продолжает выполнение, пока не будет выполнена следующая строка кода пользователя.  
  
-   **Шаг с выходом** \(сочетание клавиш: Shift \+ F11\) останавливается на следующей строке кода пользователя.  Если код пользователя не обнаруживается, выполнение продолжается до завершения работы приложения, достижения точки останова или возникновения исключения.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в JavaScript](#BKMK_JavaScript_Just_My_Code)  
  
###  <a name="BKMK_JS_Breakpoint_behavior"></a> Поведение точки останова  
  
-   Точки останова, заданные в каком\-либо коде, всегда соблюдаются независимо от классификации этого кода  
  
-   Если ключевое слово `debugger` обнаруживается в:  
  
    -   коде **LibraryCode**, отладчик всегда останавливается.  
  
    -   коде **UnrelatedCode**, отладчик не останавливается.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в JavaScript](#BKMK_JavaScript_Just_My_Code)  
  
###  <a name="BKMK_JS_Exception_behavior"></a> Поведение исключения  
 Если необработанное исключение возникает в:  
  
-   коде **MyCode** или **LibraryCode**, отладчик всегда останавливается.  
  
-   коде **UnrelatedCode**, **MyCode** или **LibraryCode** в стеке вызовов, отладчик останавливается.  
  
 Если для данного исключения включена первичная обработка в диалоговом окне "Исключения" и это исключение создается в коде **LibraryCode** или **UnrelatedCode**:  
  
-   Если исключение обрабатывается, отладчик не останавливается.  
  
-   Если исключение не обрабатывается, отладчик останавливается.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в JavaScript](#BKMK_JavaScript_Just_My_Code)  
  
###  <a name="BKMK_JS_Customize_Just_My_Code"></a> Настройка режима "Только мой код"  
 Чтобы разделить код пользователя и код, не написанный пользователем, для отдельного проекта Visual Studio, добавьте файл .json с именем `mycode.json` в корневую папку проекта.  
  
 Классификации выполняются в следующем порядке:  
  
1.  Классификации по умолчанию  
  
2.  Классификации в файле `%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json`  
  
3.  Классификации в файле `mycode. json` текущего проекта.  
  
 Каждый шаг классификации переопределяет предыдущие шаги.  Файл .json не должен отображать все пары "ключ\-значение", а значения **MyCode**, **Библиотеки** и **Unrelated** могут быть пустыми массивами.  
  
 Файлы .json кода пользователя используют следующий синтаксис:  
  
```json  
{  
    "Eval" : "Classification",  
    "Function" : "Classification",  
    "ScriptBlock" : "Classification",  
    "MyCode" : [  
        "UrlOrFileSpec”,  
        . . .  
        "UrlOrFileSpec”  
    ],  
    "Libraries" : [  
        "UrlOrFileSpec”,  
        . .  
        "UrlOrFileSpec”  
    ],  
    "Unrelated" : [  
        "UrlOrFileSpec”,  
        . . .  
        "UrlOrFileSpec”  
    ]  
}  
  
```  
  
 **Eval, функция и ScriptBlock**  
  
 Пары "ключ\-значение" **Eval**, **Функция** и **ScriptBlock** определяют, как классифицируется динамически создаваемый код.  
  
|||  
|-|-|  
|**Eval**|Скрипт, который выполняется путем передачи строки предоставленной хостом функции `eval`.  По умолчанию скрипт Eval классифицируется как **MyCode**.|  
|**Функция**|Скрипт, который выполняется путем передачи строки конструктору `Function`.  По умолчанию скрипт Функция классифицируется как **LibraryCode**.|  
|**ScriptBlock**|Скрипт, который выполняется путем передачи строки функциям `setTimeout`, `setImmediate` или `setInterval`.  По умолчанию скрипт ScriptBlock классифицируется как **UnrelatedCode**.|  
  
 Можно изменить это значение на одно из следующих ключевых слов:  
  
-   `MyCode`  классифицирует скрипт как **MyCode**.  
  
-   `Library`  классифицирует скрипт как **LibraryCode**.  
  
-   `Unrelated`  классифицирует скрипт как **UnrelatedCode**.  
  
 **MyCode, библиотеки и Unrelated**  
  
 Пары "ключ\-значение" **MyCode**, **Библиотеки** И **Unrelated** определяют URL\-адреса или файлы, которые необходимо включить в классификацию:  
  
|||  
|-|-|  
|**MyCode**|Массив URL\-адресов или файлы, которые классифицируются как **MyCode**.|  
|**Библиотеки**|Массив URL\-адресов или файлы, которые классифицируются как **LibraryCode**.|  
|**Самостоятельный**|Массив URL\-адресов или файлы, которые классифицируются как **UnrelatedCode**.|  
  
 Строка URL\-адреса или файла может содержать один или несколько символов `*`, соответствующих любому количеству символов.  `*` равноценен регулярному выражению `.*`.  
  
 ![К началу](~/debugger/media/pcs_backtotop.png "PCS\_BackToTop") [Содержание](#BKMK_Contents) **&#124;** ["Только мой код" в JavaScript](#BKMK_JavaScript_Just_My_Code)