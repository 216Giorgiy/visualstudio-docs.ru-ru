---
title: Иерархическое обновление
ms.date: 11/04/2016
ms.topic: conceptual
dev_langs:
- VB
- CSharp
helpviewer_keywords:
- saving data, changed data
- data [Visual Basic], hierarchical update
- saving updated data
- datasets [Visual Basic], hierarchical update
- hierarchical update
- saving data, hierarchical update
- modified data saving
- updated data saving
- related tables, saving
ms.assetid: 68bae3f6-ec9b-45ee-a33a-69395029f54c
author: gewarren
ms.author: gewarren
manager: douge
ms.prod: visual-studio-dev15
ms.technology: vs-data-tools
ms.workload:
- data-storage
ms.openlocfilehash: 442d6cd60597219c25b41f26ad8c2dc2151248ee
ms.sourcegitcommit: 58052c29fc61c9a1ca55a64a63a7fdcde34668a4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2018
ms.locfileid: "34747473"
---
# <a name="hierarchical-update"></a>Иерархическое обновление
*Иерархическое обновление* называется процесс сохранения обновленных данных (из набора данных двух или более связанных таблиц) в базу данных, сохраняя ограничения ссылочной целостности. *Ссылочная целостность* — это правила согласованности условий, заданные с помощью ограничений в базе данных, которые управляют поведением вставки, обновления и удаления связанных записей. Например это целостность данных обеспечивает создание записи клиента перед предоставлением заказов, которые должны быть созданы для этого клиента.  Дополнительные сведения о связях в наборах данных см. в разделе [отношения в наборах данных](../data-tools/relationships-in-datasets.md)

 Средства иерархического обновления используют `TableAdapterManager` управление `TableAdapter`s в типизированный набор данных. `TableAdapterManager` Компонент является [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)]-создается класс, поэтому он не является частью [!INCLUDE[dnprdnshort](../code-quality/includes/dnprdnshort_md.md)]. При перетаскивании таблицы из окна источников данных в форме Windows или на странице WPF Visual Studio добавляет переменную типа TableAdapterManager формы или страницы и появится в конструкторе в области компонентов. Дополнительные сведения о `TableAdapterManager` см. в описании TableAdapterManager справочном разделе [адаптеры таблиц TableAdapter](../data-tools/create-and-configure-tableadapters.md).

 По умолчанию набор данных считает связанные таблицы «, только связи» означает, что он не ограничивает ограничения внешнего ключа. Можно изменить эту настройку во время разработки с помощью конструктора наборов данных. Выберите линию связи между двумя таблицами, чтобы открыть **отношения** диалоговое окно. Изменения, внесенные в этом определить, каким образом TableAdapterManager ведет себя, если отправить изменения в связанных таблицах в базе данных.

## <a name="enable-hierarchical-update-in-a-dataset"></a>Включение иерархического обновления в наборе данных
 По умолчанию иерархическое обновление включено для всех новых наборов данных, которые добавляются или созданных в проекте. Включить или отключить иерархическое обновление, задав **иерархическое обновление** свойство типизированного набора данных в наборе данных, чтобы **True** или **False**:

 ![Параметр иерархическое обновление](../data-tools/media/hierarchical-update-setting.png)

## <a name="create-a-new-relation-between-tables"></a>Создать новую связь между таблицами
 Чтобы создать новую связь между двумя таблицами, в конструкторе наборов данных, выберите заголовок каждой таблицы, затем щелкните правой кнопкой мыши и выберите **добавить отношение**.

 ![Отношение меню добавления иерархическое обновление](../data-tools/media/hierarchical-update-add-relation-menu.png)

## <a name="understand-foreign-key-constraints-cascading-updates-and-deletes"></a>Понимать ограничения foreign key, каскадные обновления и удаления
 Важно понимать ограничения как внешнего ключа и каскадное поведения в базе данных создаются в коде созданный набор данных.

 По умолчанию таблиц данных в наборе данных создаются со связями (<xref:System.Data.DataRelation>), которые соответствуют связи в базе данных. Тем не менее как ограничение внешнего ключа связи в наборе данных не создается. <xref:System.Data.DataRelation> Настроен как **только связь** без <xref:System.Data.ForeignKeyConstraint.UpdateRule%2A> или <xref:System.Data.ForeignKeyConstraint.DeleteRule%2A> действует.

 По умолчанию каскадное обновление и удаление отключены даже в том случае, если связь в базе данных задаются каскадные обновления и/или удалением. Например создание нового клиента и нового заказа и последующая попытка сохранения данных может вызвать конфликт с ограничениями внешнего ключа, которые определены в базе данных. Дополнительные сведения см. в разделе [отключения ограничений при заполнении набора данных](turn-off-constraints-while-filling-a-dataset.md).

## <a name="set-the-order-to-perform-updates"></a>Задать порядок для выполнения обновлений
 Задание порядка выполнения обновления задает порядок отдельных вставляет, обновления и удаления, потребуется сохранить все измененные данные всех таблиц набора данных. При включении иерархического обновления операции вставки выполняются первыми, а затем обновляет, а затем удаляет. `TableAdapterManager` Предоставляет `UpdateOrder` свойство, которое может быть задано для выполнения обновления, во-первых, вставки и удаления.

> [!NOTE]
>  Важно понимать, что порядок обновления является полным. То есть при выполнении обновления, вставки и удаления выполняются для всех таблиц в наборе данных.

 Чтобы задать `UpdateOrder` свойство после перетаскивания элементов из [окно "Источники данных"](add-new-data-sources.md) на форму, выберите `TableAdapterManager` в область компонентов, а затем установите `UpdateOrder` свойство в **свойства** окна.

## <a name="create-a-backup-copy-of-a-dataset-before-performing-a-hierarchical-update"></a>Создать резервную копию набора данных перед выполнением иерархическое обновление
 При сохранении данных (путем вызова `TableAdapterManager.UpdateAll()` метод), `TableAdapterManager` пытается обновить данные для каждой таблицы в одной транзакции. Если происходит сбой любой части обновления для любой таблицы, вся транзакция откатывается. В большинстве случаев откат возвращает в исходное состояние приложения.

 Однако иногда может потребоваться восстановить набор данных из резервной копии. Одним из примеров могут возникнуть при использовании значения с автоматическим приращением. Например, если сохранения завершается неудачно, с автоматическим приращением значения не будут заменены в наборе данных и набора данных по-прежнему создать значения с автоматическим приращением. Это оставляет разрыв в нумерации, который может быть неприемлемо в приложении. В ситуациях, где это важно, `TableAdapterManager` предоставляет `BackupDataSetBeforeUpdate` свойство, которое заменяет существующий набор данных из резервной копии, если происходит сбой транзакции.

> [!NOTE]
>  Резервные копии находятся только в памяти во время `TableAdapterManager.UpdateAll` выполняется метод. Таким образом, нет программного доступа к этому резервному набору данных, так как он заменяет исходный набор данных либо выходит за пределы области после `TableAdapterManager.UpdateAll` метод завершения работы.

## <a name="modify-the-generated-save-code-to-perform-the-hierarchical-update"></a>Изменение сформированного кода сохранения для выполнения иерархического обновления
 Сохраните изменения из связанных таблиц данных набора данных в базу данных, вызвав метод `TableAdapterManager.UpdateAll` и передав имя набора данных, содержащего связанные таблицы. Например, запустите метод `TableAdapterManager.UpdateAll(NorthwindDataset)` для отправки обновлений из всех таблиц в NorthwindDataset во внутреннюю базу данных.

 После удаления элементов из **источники данных** окна, автоматически добавляется код для `Form_Load` событий для заполнения каждой таблицы ( `TableAdapter.Fill` методов). Код также добавляется к **Сохранить** нажатия кнопки <xref:System.Windows.Forms.BindingNavigator> для сохранения данных из набора данных в базе данных ( `TableAdapterManager.UpdateAll` метода).

 Сформированный код сохранения также содержит строку, вызывающую метод `CustomersBindingSource.EndEdit`. В частности, он вызывает <xref:System.Windows.Forms.BindingSource.EndEdit%2A> метод первого <xref:System.Windows.Forms.BindingSource>, добавленного в форму. Другими словами, этот код создается только для первой таблицы, которое перетаскивается из **источники данных** на форму. Вызов <xref:System.Windows.Forms.BindingSource.EndEdit%2A> фиксирует все актуальные изменения для всех редактируемых в настоящее время элементов управления с привязкой к данным. Таким образом, если элемент управления с привязкой к данным по-прежнему имеет фокус и вы нажимаете **Сохранить** кнопку все ожидающие правки в этом элементе управления фиксируются до фактического сохранения ( `TableAdapterManager.UpdateAll` метода).

> [!NOTE]
>  Конструктор наборов данных только добавляет `BindingSource.EndEdit` код для первой таблицы, перетащенной на форму. Таким образом, вам необходимо добавить строку кода, вызывающую метод `BindingSource.EndEdit` для каждой связанной таблицы на форме. В рамках данного пошагового руководства это означает, что вам нужно добавить вызов метода `OrdersBindingSource.EndEdit`.

#### <a name="to-update-the-code-to-commit-changes-to-the-related-tables-before-saving"></a>Обновление кода для фиксации изменений в связанных таблицах перед сохранением

1.  Дважды щелкните **Сохранить** кнопку <xref:System.Windows.Forms.BindingNavigator> Открытие **Form1** в редакторе кода.

2.  Добавьте строку кода для вызова метода `OrdersBindingSource.EndEdit` после строки, вызывающей метод `CustomersBindingSource.EndEdit`. Код в **Сохранить** нажатия кнопки события должен выглядеть следующим образом:

     [!code-vb[VSProDataOrcasHierarchicalUpdate#1](../data-tools/codesnippet/VisualBasic/hierarchical-update_1.vb)]
     [!code-csharp[VSProDataOrcasHierarchicalUpdate#1](../data-tools/codesnippet/CSharp/hierarchical-update_1.cs)]

Кроме фиксации изменений в связанной дочерней таблице перед сохранением данных в базе данных, вам также может понадобиться фиксировать недавно созданные родительские записи перед добавлением новых дочерних записей в базу данных. Другими словами, вам может понадобиться добавить новую родительскую запись (клиент) в базу данных, прежде чем ограничение внешнего ключа позволит добавить в набор данных дочерние записи (заказы). Для этого можно использовать дочернее событие `BindingSource.AddingNew`.

> [!NOTE]
> Нужно ли Фиксация новых родительских записей зависит от типа элемента управления, который используется для привязки к источнику данных. В этом пошаговом руководстве вы используете отдельные элементы управления для привязки к родительской таблице. Для этого дополнительный код для фиксации новой родительской записи. Если бы вместо этого родительские записи отображались в сложном элементе управления, например <xref:System.Windows.Forms.DataGridView>, этот дополнительный <xref:System.Windows.Forms.BindingSource.EndEdit%2A> вызова родительской записи не требовался бы. Это вызвано тем, что базовая функциональность привязки к данным элемента управления обрабатывает фиксацию новых записей.

#### <a name="to-add-code-to-commit-parent-records-in-the-dataset-before-adding-new-child-records"></a>Добавление кода для фиксации родительских записей в наборе данных перед добавлением новых дочерних записей

1.  Создайте обработчик событий для события `OrdersBindingSource.AddingNew`.

    -   Откройте **Form1** в режиме конструктора выберите **OrdersBindingSource** в области компонентов, выберите **событий** в **свойства** окна, и Дважды щелкните **AddingNew** событий.

2.  Добавьте строку кода в обработчик событий, который вызывает `CustomersBindingSource.EndEdit` метод. Код в обработчике событий `OrdersBindingSource_AddingNew` должен выглядеть примерно следующим образом:

     [!code-vb[VSProDataOrcasHierarchicalUpdate#2](../data-tools/codesnippet/VisualBasic/hierarchical-update_2.vb)]
     [!code-csharp[VSProDataOrcasHierarchicalUpdate#2](../data-tools/codesnippet/CSharp/hierarchical-update_2.cs)]

## <a name="tableadaptermanager-reference"></a>Справочник по TableAdapterManager
 По умолчанию `TableAdapterManager` класс создается при создании набора данных, содержащего связанные таблицы. Чтобы предотвратить создаваемого класса, измените значение `Hierarchical Update` свойства набора данных в значение false. При перетаскивании таблицы, имеющей связь на поверхность разработки формы Windows Forms или страницы WPF Visual Studio объявляет переменную-член класса. Если вы не используете привязки данных, необходимо вручную объявить переменную.

 `TableAdapterManager` Класс не является частью [!INCLUDE[dnprdnshort](../code-quality/includes/dnprdnshort_md.md)]. Таким образом вам не удается найти в документации. Он создается во время разработки, как часть процесса создания набора данных.

 Ниже перечислены часто используемые методы и свойства `TableAdapterManager` класса:

|Член|Описание:|
|------------|-----------------|
|Метод `UpdateAll`|Сохраняет все данные из всех таблиц данных.|
|Свойство `BackUpDataSetBeforeUpdate`|Определяет, следует ли создавать резервную копию набора данных перед выполнением `TableAdapterManager.UpdateAll` метод. Логическое значение.|
|*tableName* `TableAdapter` свойство|Представляет `TableAdapter`. Созданный `TableAdapterManager` содержит свойство для каждого `TableAdapter` он управляет. Например, создан набор данных с таблицей Customers и Orders с `TableAdapterManager` , содержащий `CustomersTableAdapter` и `OrdersTableAdapter` свойства.|
|Свойство `UpdateOrder`|Управляет порядком отдельные инструкции insert, update и delete команды. Задайте одно из значений в `TableAdapterManager.UpdateOrderOption` перечисления.<br /><br /> По умолчанию `UpdateOrder` равно **InsertUpdateDelete**. Это означает, что операции вставки, а затем обновляет, а затем удаляет выполняются для всех таблиц в наборе данных.|

## <a name="see-also"></a>См. также

- [Сохранение данных обратно в базу данных](../data-tools/save-data-back-to-the-database.md)